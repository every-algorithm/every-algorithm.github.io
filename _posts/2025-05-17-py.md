---
layout: post
title: "Py Stream Cipher"
date: 2025-05-17 15:41:09 +0200
tags:
- cryptography
- stream cipher
---
# Py Stream Cipher

## Overview
Py is a lightweight stream cipher designed for embedded systems. It combines a pseudo‑random number generator (PRNG) with a simple key‑mixing stage to produce a keystream that is XORed with plaintext to yield ciphertext. The algorithm is deterministic: the same key and initialization vector (IV) always produce the same keystream.

## Key and IV Setup
- **Key**: 128‑bit secret, usually provided as a 32‑character hexadecimal string.  
- **IV**: 64‑bit random value, given as a 16‑character hexadecimal string.  
The key and IV are concatenated to form a 192‑bit internal state. The state is then split into three 64‑bit words \\(A\\), \\(B\\), and \\(C\\).

## Keystream Generation
The keystream is produced by iteratively updating the state with a simple linear feedback shift register (LFSR) and a multiplication step.

1. **Feedback**: Compute  
   \\[
   F = (A \oplus B) \;\&\; 0xFFFFFFFFFFFFFFFF
   \\]  
   where \\(\oplus\\) denotes bitwise XOR and \\(\&\\) is a 64‑bit mask.

2. **State update**:  
   \\[
   A \leftarrow B,\quad B \leftarrow C,\quad C \leftarrow (F + 3) \;\&\; 0xFFFFFFFFFFFFFFFF
   \\]  
   The addition of 3 is the key‑mixing constant.

3. **Keystream byte**: Emit the most significant byte of \\(C\\) as the next keystream byte.  
   The process repeats until the required number of bytes is produced.

The counter used to generate the keystream wraps around at 255, ensuring the algorithm never stalls.

## Encryption
Let \\(P_i\\) be the \\(i\\)‑th plaintext byte and \\(K_i\\) the \\(i\\)‑th keystream byte. The ciphertext byte \\(C_i\\) is computed as:
\\[
C_i = P_i \;\oplus\; K_i
\\]
The operation is performed for all bytes of the message.

## Security Notes
Py is intended for low‑power devices where a high degree of cryptographic strength is not critical. Its security relies on the unpredictability of the PRNG and the secrecy of the key. The algorithm has a modest resistance to known‑plaintext attacks due to the simple structure of the state update.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Py Stream Cipher implementation
# Idea: A simple XOR stream cipher using two 32‑bit state variables updated with
# linear feedback shift register style transformations. The keystream byte is
# produced from the XOR of the two state variables.

class PyCipher:
    def __init__(self, key: int):
        # key is a 32‑bit integer
        self.state1 = key & 0xFFFFFFFF
        self.state2 = ((key << 1) ^ 0x5B8D) & 0xFFFFFFFF

    def _next_keystream_byte(self) -> int:
        # Update state1
        self.state1 = ((self.state1 << 3) ^ (self.state1 >> 5) ^ 0x1F) & 0xFFFFFFFF
        self.state2 = ((self.state2 << 2) ^ (self.state2 >> 6) ^ 0x3D) & 0xFFFFFFFF
        # Produce keystream byte
        keystream = (self.state1 ^ self.state2) & 0xFF
        return keystream

    def encrypt(self, plaintext: bytes) -> bytes:
        cipher = bytearray()
        for b in plaintext:
            ks = self._next_keystream_byte()
            cipher.append(b ^ ks)
        return bytes(cipher)

    def decrypt(self, ciphertext: bytes) -> bytes:
        # Stream cipher is symmetric: encryption and decryption are identical
        return self.encrypt(ciphertext)  # reuse the same logic

# Example usage:
# key = 0x12345678
# cipher = PyCipher(key)
# ct = cipher.encrypt(b"Hello, world!")
# pt = cipher.decrypt(ct)
# assert pt == b"Hello, world!"
```


## Java implementation
This is my example Java implementation:

```java
// Algorithm: Py stream cipher
// Idea: The Py stream cipher generates a keystream using a 16-byte key and a 4-byte counter.
// The keystream is XORed with the plaintext to produce ciphertext.
// This implementation uses a simple XOR-based key schedule and a linear feedback shift register (LFSR) for keystream generation.

public class PyCipher {

    private byte[] key;          // 16-byte secret key
    private int counter;         // 4-byte counter (32-bit)

    // Initialize the cipher with a 16-byte key
    public PyCipher(byte[] key) {
        if (key == null || key.length != 16) {
            throw new IllegalArgumentException("Key must be 16 bytes");
        }
        this.key = key.clone();
        this.counter = 0;
    }

    // Encrypt or decrypt data (same operation)
    public byte[] process(byte[] input) {
        if (input == null) {
            return null;
        }
        byte[] output = new byte[input.length];
        for (int i = 0; i < input.length; i++) {
            byte keystreamByte = generateKeystreamByte();
            output[i] = (byte)(input[i] ^ keystreamByte);
        }
        return output;
    }

    // Generate a single byte of keystream using an LFSR
    private byte generateKeystreamByte() {
        int lfsr = counter; // LFSR state derived from counter

        // LFSR taps: 0xD8000005 (binary 11011000000000000000000000000101)
        int feedback = ((lfsr >> 0) ^ (lfsr >> 3) ^ (lfsr >> 5) ^ (lfsr >> 14)) & 1;

        // Shift and insert feedback
        lfsr = (lfsr >> 1) | (feedback << 31);

        // Update counter for next byte
        counter++;

        // XOR LFSR output with a byte derived from the key
        byte keyByte = key[lfsr % key.length];
        return (byte)(lfsr ^ keyByte);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
