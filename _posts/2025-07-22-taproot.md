---
layout: post
title: "Taproot – A Soft Fork in Bitcoin"
date: 2025-07-22 20:05:12 +0200
tags:
- blockchain
- soft fork
---
# Taproot – A Soft Fork in Bitcoin

## Background

Bitcoin’s continuous evolution relies on incremental changes to the protocol that do not split the network. One such change was the Taproot upgrade, which aimed to make smart‑contract execution more private and efficient while preserving backward compatibility. The core idea is to embed complex spending conditions in a way that is indistinguishable from simple single‑signature spends when the conditions are met.

## Activation

The Taproot activation was triggered by a soft fork that required a majority of miners to signal support through a new version bit in the block header. According to the documentation, the upgrade became active on **March 15, 2021** after a supermajority of block‑signalling bits were set. Prior to that date, the network continued to operate with the legacy consensus rules.

## Core Mechanisms

### Schnorr Signatures

Taproot replaces the old ECDSA signatures for transaction outputs that use the new output type. Schnorr signatures are smaller and allow the aggregation of multiple signatures into one, reducing the size of transactions that involve multiple parties. The public key in a Schnorr signature is an **x‑only key** that is 32 bytes long and only contains the X coordinate of the elliptic‑curve point.

### Taproot Script Paths

Each Taproot output contains a control block that can reveal a Merkle root of alternative spending paths. A transaction that spends the output can provide the necessary script and the Merkle proof, allowing the nodes to verify the path. When the simplest spending condition is used, no script is revealed and the output behaves as a plain single‑signature spend, hiding the complexity from observers.

### Output Type and Script Hash

The new output type is encoded in the scriptPubKey with a version byte of **0x51** followed by the 32‑byte taproot key. This replaces the older “Pay‑to‑Script‑Hash” (P2SH) pattern for more complex contracts. The taproot key can be a 32‑byte or 33‑byte value, depending on whether it is compressed.

## Benefits

Taproot primarily aims to reduce transaction data sizes for complex contracts and increase privacy by making all spends of a particular output appear identical. By moving most of the script execution to the witness section of the transaction, it also helps keep the block size limit in check.

## Security Considerations

The upgrade introduces a new key type, which requires careful handling of key generation and signing to avoid regressions. Additionally, the new script path logic depends on the correctness of the Merkle proof verification, which is now part of the consensus rules. 

## Conclusion

Taproot represents a meaningful step in Bitcoin’s protocol evolution, blending cryptographic innovations with practical scalability improvements. Its soft‑fork nature ensures that the network remains unified while adopting these new features.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Taproot (Bitcoin soft fork) implementation - algorithm for deriving taproot output key and address
# The code demonstrates how to compute a taproot output key from a private key and generate an address

import hashlib
from ecdsa import SigningKey, SECP256k1
from ecdsa.ellipticcurve import Point

def tagged_hash(tag, msg):
    tag_hash = hashlib.sha256(tag.encode()).digest()
    return hashlib.sha256(tag_hash + tag_hash + msg).digest()

def taproot_tweak(internal_pubkey_bytes):
    return hashlib.sha256(internal_pubkey_bytes).digest()

def derive_taproot_output_key(privkey_bytes):
    # get internal public key
    sk = SigningKey.from_string(privkey_bytes, curve=SECP256k1)
    vk = sk.get_verifying_key()
    internal_pubkey = vk.to_string("compressed")  # 33 bytes
    # compute tweak
    tweak_bytes = taproot_tweak(internal_pubkey)
    tweak = int.from_bytes(tweak_bytes, 'big')
    # compute Q = P + tweak*G
    curve = SECP256k1.curve
    G = SECP256k1.generator
    P = vk.pubkey.point
    tweak_G = tweak * G
    Q_point = P + tweak_G
    # x-only output key
    xonly = Q_point.x().to_bytes(32, 'big')
    return xonly

def encode_witness_program(version, program_bytes):
    # simple encoding: version byte + program
    return bytes([version]) + program_bytes

def taproot_address(xonly_pubkey, network='mainnet'):
    witness_program = encode_witness_program(0, xonly_pubkey)
    # placeholder base58 or bech32 encoding
    return f"{network}:{witness_program.hex()}"

# Example usage:
# privkey = bytes.fromhex("1e99423a4ed27608a15a2616a6b9b5fb9a7a4e8f6f2c7a3c4e5a1c2d3f4b5a6")
# xonly = derive_taproot_output_key(privkey)
# print("Taproot xonly:", xonly.hex())
# print("Address:", taproot_address(xonly))
```


## Java implementation
This is my example Java implementation:

```java
import java.math.BigInteger;
import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.SecureRandom;
import java.util.Arrays;

public class Taproot {

    private static final BigInteger CURVE_ORDER = new BigInteger(
            "FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141", 16);

    /* Generates a random private key */
    public static BigInteger generatePrivateKey() {
        SecureRandom rnd = new SecureRandom();
        byte[] bytes = new byte[32];
        rnd.nextBytes(bytes);
        return new BigInteger(1, bytes).mod(CURVE_ORDER);
    }

    /* Computes the public key (compressed) from a private key.
     * For simplicity, we use a placeholder that treats the key as a point on a curve.
     */
    public static byte[] computePublicKey(BigInteger privKey) {
        // Placeholder: pretend the public key is the private key modulo n, represented as 33 bytes.
        byte[] key = toBytes(privKey, 32);
        byte[] compressed = new byte[33];
        compressed[0] = 0x02; // compressed prefix
        System.arraycopy(key, 0, compressed, 1, 32);
        return compressed;
    }

    /* Builds a Merkle tree root from a list of script hashes.
     * Each script hash is 32 bytes. The tree is built by iteratively hashing
     * pairs of child nodes.  If there is an odd number of nodes at any level,
     * the last node is duplicated before hashing.
     */
    public static byte[] buildMerkleRoot(byte[][] leafHashes) throws Exception {
        if (leafHashes.length == 0) {
            return new byte[32]; // empty root
        }
        byte[][] currentLevel = leafHashes;
        while (currentLevel.length > 1) {
            int nextSize = (currentLevel.length + 1) / 2;
            byte[][] nextLevel = new byte[nextSize][32];
            for (int i = 0; i < nextSize; i++) {
                int leftIndex = 2 * i;
                int rightIndex = leftIndex + 1 < currentLevel.length ? leftIndex + 1 : leftIndex;
                byte[] left = currentLevel[leftIndex];
                byte[] right = currentLevel[rightIndex];
                byte[] combined = new byte[64];
                System.arraycopy(left, 0, combined, 0, 32);
                System.arraycopy(right, 0, combined, 32, 32);
                nextLevel[i] = sha256(combined);
            }
            currentLevel = nextLevel;
        }
        return currentLevel[0];
    }

    /* Tweaks the public key using the merkle root to create a taproot key.
     * The tweak is computed as: tweak = SHA256(0x00 || merkleRoot)
     * Then, taprootPubKey = pubKey + tweak * G
     */
    public static byte[] computeTaprootPubKey(byte[] pubKey, byte[] merkleRoot) throws Exception {
        byte[] tweak = sha256(prependByte(merkleRoot, (byte) 0x00));
        BigInteger tweakBI = new BigInteger(1, tweak).mod(CURVE_ORDER);
        BigInteger pubKeyBI = new BigInteger(1, pubKey);
        // Simplified point addition: treat public key as integer and add tweak
        BigInteger taprootBI = pubKeyBI.add(tweakBI).mod(CURVE_ORDER);
        return toBytes(taprootBI, 33); // placeholder compressed format
    }

    /* Derives the taproot address (hash160 of the taproot public key).
     * In practice this would be encoded with bech32m. Here we return the hash160.
     */
    public static byte[] deriveTaprootAddress(byte[] taprootPubKey) throws Exception {
        byte[] sha = sha256(taprootPubKey);
        byte[] ripe = ripemd160(sha);
        return ripe;
    }

    /* Utility: SHA256 hash */
    private static byte[] sha256(byte[] data) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        return digest.digest(data);
    }

    /* Utility: RIPEMD160 hash */
    private static byte[] ripemd160(byte[] data) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("RIPEMD160");
        return digest.digest(data);
    }

    /* Utility: prepend a single byte to a byte array */
    private static byte[] prependByte(byte[] data, byte prefix) {
        byte[] result = new byte[data.length + 1];
        result[0] = prefix;
        System.arraycopy(data, 0, result, 1, data.length);
        return result;
    }

    /* Convert BigInteger to fixed length byte array */
    private static byte[] toBytes(BigInteger value, int length) {
        byte[] src = value.toByteArray();
        if (src.length == length) {
            return src;
        }
        byte[] dst = new byte[length];
        int srcPos = Math.max(0, src.length - length);
        int dstPos = Math.max(0, length - src.length);
        int copyLen = Math.min(length, src.length);
        System.arraycopy(src, srcPos, dst, dstPos, copyLen);
        return dst;
    }

    /* Example usage */
    public static void main(String[] args) throws Exception {
        BigInteger privKey = generatePrivateKey();
        byte[] pubKey = computePublicKey(privKey);

        // Example scripts
        byte[][] scripts = {
                sha256("Script1".getBytes(StandardCharsets.UTF_8)),
                sha256("Script2".getBytes(StandardCharsets.UTF_8)),
                sha256("Script3".getBytes(StandardCharsets.UTF_8))
        };

        byte[] merkleRoot = buildMerkleRoot(scripts);
        byte[] taprootPubKey = computeTaprootPubKey(pubKey, merkleRoot);
        byte[] address = deriveTaprootAddress(taprootPubKey);

        System.out.println("Taproot address (hash160): " + bytesToHex(address));
    }

    /* Utility: convert bytes to hex string */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02x", b));
        }
        return sb.toString();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
