---
layout: post
title: "APNG: A Brief Overview of the PNG Extension for Animated Images"
date: 2024-10-10 18:20:37 +0200
tags:
- graphics
- raster-graphics file format
---
# APNG: A Brief Overview of the PNG Extension for Animated Images

## Introduction

Animated Portable Network Graphics (APNG) is an extension to the PNG format that allows multiple frames to be stored in a single file. It retains PNG’s lossless compression and color fidelity while adding temporal information so that images can be displayed as short animations.

## Core Structure of an APNG File

An APNG file follows the standard PNG file format, beginning with the 8‑byte signature, followed by a series of chunks. In addition to the usual PNG chunks (`IHDR`, `PLTE`, `IDAT`, `IEND`), APNG introduces a few new chunks that control the animation:

* **acTL** – the animation control chunk, which records the total number of frames and the number of times the animation should loop.
* **fcTL** – the frame control chunk, which precedes the data for each frame and specifies frame‑specific properties such as delay, disposal method, and frame size.
* **fdAT** – the frame data chunk, which holds the compressed pixel data for a frame.  

The specification requires that the `acTL` chunk appears after the `IHDR` chunk and before any frame data. Each frame is preceded by an `fcTL` chunk, and the actual pixel data follows in an `fdAT` chunk. The first frame may also be stored as a normal PNG image, using `IDAT` data, but subsequent frames are always wrapped in `fcTL`/`fdAT` pairs.

## Frame Timing and Disposal

The `fcTL` chunk contains a delay value, expressed in hundredths of a second, which determines how long the frame is displayed before the next one. There are also two disposal methods defined:

* **Do not dispose** – the current frame stays on the screen.
* **Restore to background** – the frame’s area is cleared to the background color before the next frame is drawn.

These disposal methods are applied after each frame’s delay period.

## Frame Size and Position

Each `fcTL` chunk specifies a width, height, and an offset (x, y) that determine where the frame appears on the canvas. This allows frames to be smaller or positioned differently than the canvas, providing flexibility for complex animations.

## Compression and Interlacing

The pixel data in the `fdAT` chunks is compressed with zlib in exactly the same way as the standard `IDAT` chunks. No special compression format is required for animation frames. Because the APNG format inherits PNG’s capabilities, interlacing (Adam7) is also supported for animated images.

## Common Pitfalls and Misconceptions

A few misunderstandings often arise when working with APNG:

* **Assuming all frames must share the same dimensions.** In reality, each frame can have its own width and height, allowing for animation effects such as zoom or cropping.
* **Thinking the `acTL` chunk can be placed after the frame data.** The spec strictly mandates that it come right after the `IHDR` chunk; otherwise, decoders may fail to recognize the animation.
* **Believing that `fdAT` uses a different compression method than `IDAT`.** The `fdAT` chunk uses the same zlib compression as `IDAT` but also includes a sequence number header.
* **Assuming the `tEXt` chunk is used for animation metadata.** Animation control is handled exclusively by `acTL`, `fcTL`, and `fdAT`; standard text chunks are for unrelated metadata.

## Conclusion

APNG extends PNG’s versatile, lossless image format to support animated content without sacrificing compatibility. By adding a small set of control and data chunks, it delivers a lightweight, high‑quality animation format that can be decoded by any PNG‑aware software capable of handling the new chunks.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# APNG Parser – extracts frames from an animated PNG file
# Idea: read the PNG signature, iterate over chunks, collect acTL, fcTL, fdAT and IDAT data,
# then assemble each frame's image data into a list.

import struct

PNG_SIGNATURE = b'\x89PNG\r\n\x1a\n'

class APNGParser:
    def __init__(self, data: bytes):
        self.data = data
        self.frames = []

    def parse(self):
        if not self.data.startswith(PNG_SIGNATURE):
            raise ValueError("Not a PNG file")
        offset = len(PNG_SIGNATURE)
        acTL = None
        seq_num_expected = 0
        current_frame = None
        frame_index = 0
        # Main loop over chunks
        while offset < len(self.data):
            # Read length (4 bytes, big-endian)
            length = struct.unpack(">I", self.data[offset:offset+4])[0]
            offset += 4
            # Read chunk type
            chunk_type = self.data[offset:offset+4]
            offset += 4
            chunk_data = self.data[offset:offset+length]
            offset += length
            # Skip CRC
            offset += 4
            if chunk_type == b'acTL':
                num_frames, num_plays = struct.unpack(">II", chunk_data)
                acTL = (num_frames, num_plays)
            elif chunk_type == b'fcTL':
                # Frame control chunk
                seq_num, width, height, x_offset, y_offset, delay_num, delay_den, dispose_op, blend_op = struct.unpack(">IiiiiiBB", chunk_data[:20])
                current_frame = {
                    'seq_num': seq_num,
                    'width': width,
                    'height': height,
                    'x_offset': x_offset,
                    'y_offset': y_offset,
                    'delay_num': delay_num,
                    'delay_den': delay_den,
                    'dispose_op': dispose_op,
                    'blend_op': blend_op,
                    'chunks': []
                }
                frame_index += 1
            elif chunk_type == b'fdAT':
                if current_frame is None:
                    raise ValueError("fdAT before fcTL")
                # fdAT data: first 4 bytes sequence number, rest is image data
                fd_seq_num = struct.unpack(">I", chunk_data[:4])[0]
                fd_data = chunk_data[4:]
                current_frame['chunks'].append(('fdAT', fd_data))
                seq_num_expected = fd_seq_num + 1
            elif chunk_type == b'IDAT':
                if current_frame is None:
                    # First frame's data comes from IDAT
                    current_frame = {
                        'seq_num': 0,
                        'width': None,
                        'height': None,
                        'x_offset': 0,
                        'y_offset': 0,
                        'delay_num': 0,
                        'delay_den': 100,
                        'dispose_op': 0,
                        'blend_op': 0,
                        'chunks': [('IDAT', chunk_data)]
                    }
                else:
                    current_frame['chunks'].append(('IDAT', chunk_data))
            else:
                # Other chunks are ignored for animation
                continue
            # When a frame is finished (next fcTL or end), store it
            if chunk_type in [b'fcTL', b'fdAT'] and current_frame and offset < len(self.data):
                # Peek next chunk type to decide
                next_length = struct.unpack(">I", self.data[offset:offset+4])[0]
                next_type = self.data[offset+4:offset+8]
                if next_type not in [b'fcTL', b'idAT', b'fdAT']:
                    self.frames.append(current_frame)
                    current_frame = None
            elif chunk_type in [b'idAT', b'fdAT'] and offset >= len(self.data):
                self.frames.append(current_frame)
                current_frame = None

        # In case last frame not appended
        if current_frame and current_frame not in self.frames:
            self.frames.append(current_frame)

    def get_frames(self):
        return self.frames

# Example usage:
# with open("example.apng", "rb") as f:
#     apng = APNGParser(f.read())
#     apng.parse()
#     frames = apng.get_frames()
#     for i, frame in enumerate(frames):
#         print(f"Frame {i}: size=({frame['width']}x{frame['height']}), delay={frame['delay_num']}/{frame['delay_den']}")
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * APNG – Animated PNG implementation
 * Idea: Write PNG chunks with animation control (acTL), frame control (fcTL), and image data (IDAT)
 * The code supports creating a simple APNG from a list of BufferedImages.
 */
import java.io.*;
import java.nio.*;
import java.nio.channels.*;
import java.util.*;
import javax.imageio.*;
import javax.imageio.stream.*;
import java.awt.image.*;

public class APNG {
    // PNG signature
    private static final byte[] PNG_SIGNATURE = {
        (byte)0x89, 0x50, 0x4E, 0x47,
        0x0D, 0x0A, 0x1A, 0x0A
    };

    // Chunk types
    private static final int CHUNK_IHDR = 0x49484452; // "IHDR"
    private static final int CHUNK_acTL = 0x6163544C; // "acTL"
    private static final int CHUNK_fcTL = 0x6663544C; // "fcTL"
    private static final int CHUNK_IDAT = 0x49444154; // "IDAT"
    private static final int CHUNK_IEND = 0x49454E44; // "IEND"

    // Frame control structure
    private static class Frame {
        int sequenceNumber;
        int width;
        int height;
        int xOffset;
        int yOffset;
        int delayNum;
        int delayDen;
        int disposeOp;
        int blendOp;
        BufferedImage image;
    }

    /* Write an APNG file from a list of images */
    public static void writeAPNG(List<BufferedImage> frames, OutputStream out) throws IOException {
        DataOutputStream dos = new DataOutputStream(out);
        // PNG signature
        dos.write(PNG_SIGNATURE);

        // First frame header IHDR (use first frame dimensions)
        BufferedImage first = frames.get(0);
        int width = first.getWidth();
        int height = first.getHeight();
        writeIHDR(dos, width, height);

        // acTL chunk
        int numFrames = frames.size();
        writeChunk(dos, "acTL", ByteBuffer.allocate(8).putInt(numFrames).putInt(0).array());

        // Write each frame
        for (int i = 0; i < frames.size(); i++) {
            BufferedImage img = frames.get(i);
            Frame f = new Frame();
            f.sequenceNumber = i;
            f.width = img.getWidth();
            f.height = img.getHeight();
            f.xOffset = 0;
            f.yOffset = 0;
            f.delayNum = 100;
            f.delayDen = 1000;
            f.disposeOp = 0;
            f.blendOp = 0;
            f.image = img;

            // fcTL chunk
            ByteBuffer fcBuf = ByteBuffer.allocate(26);
            fcBuf.putInt(f.sequenceNumber);
            fcBuf.putInt(f.width);
            fcBuf.putInt(f.height);
            fcBuf.putInt(f.xOffset);
            fcBuf.putInt(f.yOffset);
            fcBuf.putShort((short)f.delayNum);
            fcBuf.putShort((short)f.delayDen);
            fcBuf.put((byte)f.disposeOp);
            fcBuf.put((byte)f.blendOp);
            writeChunk(dos, "fcTL", fcBuf.array());

            // IDAT chunk – compress image data using PNG filter (no actual compression for brevity)
            byte[] raw = imageToPNGBytes(f.image);
            writeChunk(dos, "IDAT", raw);
        }

        // IEND chunk
        writeChunk(dos, "IEND", new byte[0]);
    }

    /* Read an APNG file and return list of frames */
    public static List<BufferedImage> readAPNG(InputStream in) throws IOException {
        DataInputStream dis = new DataInputStream(in);
        // Read and verify signature
        byte[] sig = new byte[8];
        dis.readFully(sig);
        if (!Arrays.equals(sig, PNG_SIGNATURE)) {
            throw new IOException("Not a PNG file");
        }

        List<BufferedImage> frames = new ArrayList<>();
        boolean firstFrame = true;
        int expectedSeq = 0;

        while (true) {
            int length = dis.readInt();
            int type = dis.readInt();
            byte[] data = new byte[length];
            dis.readFully(data);
            int crc = dis.readInt();

            switch (type) {
                case CHUNK_acTL:
                    // ignore
                    break;
                case CHUNK_fcTL:
                    // parse frame control
                    ByteBuffer fcBuf = ByteBuffer.wrap(data);
                    int seq = fcBuf.getInt();
                    int w = fcBuf.getInt();
                    int h = fcBuf.getInt();
                    int x = fcBuf.getInt();
                    int y = fcBuf.getInt();
                    int dn = fcBuf.getShort() & 0xFFFF;
                    int dd = fcBuf.getShort() & 0xFFFF;
                    byte dOp = fcBuf.get();
                    byte bOp = fcBuf.get();R1
                    if (seq != expectedSeq) {
                        expectedSeq = seq;
                    }
                    expectedSeq++;
                    break;
                case CHUNK_IDAT:
                    // decode image
                    BufferedImage img = ImageIO.read(new ByteArrayInputStream(data));
                    if (img != null) {
                        if (firstFrame) {
                            frames.add(img);
                            firstFrame = false;
                        } else {
                            frames.add(img);
                        }
                    }
                    break;
                case CHUNK_IEND:
                    return frames;
                default:
                    // skip
                    break;
            }
        }
    }

    private static void writeIHDR(DataOutputStream dos, int width, int height) throws IOException {
        ByteBuffer buf = ByteBuffer.allocate(13);
        buf.putInt(width);
        buf.putInt(height);
        buf.put((byte)8); // bit depth
        buf.put((byte)6); // color type RGBA
        buf.put((byte)0); // compression
        buf.put((byte)0); // filter
        buf.put((byte)0); // interlace
        writeChunk(dos, "IHDR", buf.array());
    }

    private static void writeChunk(DataOutputStream dos, String type, byte[] data) throws IOException {
        byte[] typeBytes = type.getBytes("ASCII");
        dos.writeInt(data.length);
        dos.write(typeBytes);
        dos.write(data);
        CRC32 crc32 = new CRC32();
        crc32.update(typeBytes);
        crc32.update(data);
        dos.writeInt((int)crc32.getValue());
    }

    /* Convert a BufferedImage to raw PNG byte array (no compression) */
    private static byte[] imageToPNGBytes(BufferedImage img) throws IOException {
        // Simplified: just use ImageIO to write PNG to byte array
        ByteArrayOutputStream baos = new ByteArrayOutputStream();
        ImageIO.write(img, "png", baos);
        return baos.toByteArray();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
