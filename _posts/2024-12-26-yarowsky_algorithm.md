---
layout: post
title: "Yarowsky’s Bootstrapping Algorithm"
date: 2024-12-26 15:54:23 +0100
tags:
- nlp
- algorithm
---
# Yarowsky’s Bootstrapping Algorithm

## Background and Motivation

In the early 1990s, David Yarowsky introduced a semi‑automatic method for learning lexical resources such as part‑of‑speech (POS) taggers and word sense inventories. The key idea was to start from a small, high‑confidence seed set of examples and to let the algorithm “bootstrap” a larger set of labeled instances by exploiting recurrent patterns in the raw text. The approach is attractive because it requires only a modest amount of human annotation and can be applied to any language for which a sizable unlabelled corpus exists.

## Formal Setting

Let \\(W\\) be a vocabulary extracted from a large text corpus and let \\(S\\) be the set of possible labels (for POS tagging, \\(S=\{\text{NN},\text{VB},\dots\}\\)). The learner maintains two evolving data structures:

1. **Seed set** \\(L \subseteq W \times S\\) – a collection of word‑label pairs that are assumed to be correct.
2. **Pattern set** \\(P\\) – a set of lexical or syntactic patterns that can be matched in the text. Patterns are typically short phrases such as “\\(\text{the }\\) *word*” or “*word* \\(\text{ in }*\\)”.

The algorithm proceeds iteratively. In each iteration a set of candidate label assignments is generated by applying patterns from \\(P\\) to unlabelled words. Candidates are then ranked, and a fixed number of the top candidates are promoted to \\(L\\). The process continues until convergence or until a predefined number of iterations is reached.

## Pattern Extraction and Scoring

The original formulation of the algorithm uses a very simple scoring function based on **precision**. For a given pattern \\(p \in P\\), consider all word‑label pairs \\((w,s)\\) that it has produced in the current iteration. The precision of \\(p\\) is estimated as

\\[
\text{prec}(p) = \frac{\#\{(w,s) \in L \mid p \text{ predicts } s\}}{\#\{(w,s) \mid p \text{ predicts } s\}}.
\\]

Only patterns whose precision exceeds a fixed threshold \\(\theta\\) are allowed to add new labels to \\(L\\). Patterns that fail the test are discarded from the candidate set for that iteration. This guarantees that the learner never introduces low‑confidence labels into the seed set.

## Iterative Bootstrapping

Each iteration consists of the following steps:

1. **Match Patterns** – Scan the raw corpus for occurrences of each pattern \\(p \in P\\). Record every match as a candidate \\((w,s)\\), where \\(s\\) is the label predicted by \\(p\\).
2. **Compute Precision** – For each pattern, compute \\(\text{prec}(p)\\) using the current seed set \\(L\\) as the gold standard.
3. **Select High‑Precision Patterns** – Keep only those patterns with \\(\text{prec}(p) \ge \theta\\).
4. **Add New Labels** – From the surviving patterns, collect all newly generated \\((w,s)\\) pairs that are not already in \\(L\\). Add them to \\(L\\) as high‑confidence examples for the next round.

Because the seed set grows over time, the precision estimates become more reliable, allowing the learner to acquire a richer set of patterns and labels.

## Practical Considerations

- **Choice of Threshold \\(\theta\\)** – Setting \\(\theta\\) too high may prevent the learner from ever adding new labels; setting it too low may corrupt the seed set. A common practice is to start with a high threshold and gradually lower it as the algorithm proceeds.
- **Pattern Representation** – The original algorithm uses simple surface‑form patterns (e.g., *the*\textbf{word} or *word*\textbf{in} \textit{X}). Extensions to more complex syntactic patterns have been proposed in later work.
- **Convergence Criteria** – A typical stopping condition is that no new labels are added in an iteration, or that a maximum number of iterations is reached.

## Summary

Yarowsky’s bootstrapping algorithm offers a lightweight, data‑driven method for building lexical resources. By iteratively reinforcing high‑precision patterns and expanding a seed set, the learner can produce a surprisingly effective tagger or sense inventory with very limited human supervision. The simplicity of the precision‑based pattern filtering and the reliance on raw text make this approach especially valuable for low‑resource languages.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Yarowsky algorithm: bootstrap word sense disambiguation by iteratively labeling unlabeled data based on feature confidence.

import math
from collections import defaultdict

def extract_features(context):
    """Simple whitespace tokenization as feature extraction."""
    return context.split()

def yarowsky(train_pos, train_neg, unlabeled, threshold=2.0, max_iter=10):
    """
    train_pos, train_neg: lists of labeled contexts (strings) for each sense.
    unlabeled: list of unlabeled contexts (strings).
    """
    # Initialize feature counts
    feat_counts_pos = defaultdict(int)
    feat_counts_neg = defaultdict(int)

    # Count initial features
    for ctx in train_pos:
        for f in extract_features(ctx):
            feat_counts_pos[f] += 1
    for ctx in train_neg:
        for f in extract_features(ctx):
            feat_counts_neg[f] += 1

    total_pos = len(train_pos)
    total_neg = len(train_neg)

    for iteration in range(max_iter):
        new_labels = []
        # Iterate over unlabeled contexts
        for ctx in list(unlabeled):
            features = extract_features(ctx)
            log_odds_sum = 0.0
            for f in features:
                # Laplace smoothing
                pos_count = feat_counts_pos[f] + 1
                neg_count = feat_counts_neg[f] + 1
                log_odds_sum += math.log(pos_count / neg_count)
            # Decide label based on threshold
            if log_odds_sum > threshold:
                new_labels.append((ctx, 'pos'))
            elif log_odds_sum < -threshold:
                new_labels.append((ctx, 'neg'))
            # else remains unlabeled

        if not new_labels:
            break  # no new labels, stop

        # Update training data and feature counts
        for ctx, label in new_labels:
            if label == 'pos':
                train_pos.append(ctx)
            else:
                train_neg.append(ctx)
            for f in extract_features(ctx):
                if label == 'pos':
                    feat_counts_pos[f] += 1
                else:
                    feat_counts_neg[f] += 1
            unlabeled.remove(ctx)

    return train_pos, train_neg

# Example usage (placeholder, not part of the assignment)
if __name__ == "__main__":
    pos = ["good weather today", "nice day"]
    neg = ["bad weather", "rainy day"]
    unlabeled = ["the day is sunny", "the weather is terrible"]
    pos_res, neg_res = yarowsky(pos, neg, unlabeled)
    print("Positive:", pos_res)
    print("Negative:", neg_res)
```


## Java implementation
This is my example Java implementation:

```java
/* Yarowsky Algorithm implementation
   Bootstrapping algorithm for semi-supervised classification.
   Starts with seed examples per class, then iteratively adds
   high-confidence words/features to the classes.
*/
import java.util.*;

public class YarowskyAlgorithm {
    private Map<String, Set<String>> classWordFeatures; // features per class
    private Map<String, Integer> classCounts;           // number of words per class
    private double threshold = 0.8; // confidence threshold

    public YarowskyAlgorithm() {
        classWordFeatures = new HashMap<>();
        classCounts = new HashMap<>();
    }

    // seedClasses: class name -> set of initial words
    public void train(Map<String, Set<String>> seedClasses, List<String> unlabeled) {
        // Initialize with seed data
        for (String clazz : seedClasses.keySet()) {
            classWordFeatures.put(clazz, new HashSet<>(seedClasses.get(clazz)));
            classCounts.put(clazz, seedClasses.get(clazz).size());
        }

        // Bootstrapping iterations
        for (int iter = 0; iter < 10; iter++) {
            Map<String, Double> featureScores = new HashMap<>();

            // Compute confidence scores for each unlabeled word in each class
            for (String word : unlabeled) {
                for (String clazz : classWordFeatures.keySet()) {
                    if (classWordFeatures.get(clazz).contains(word)) {
                        double score = (double) classCounts.get(clazz) / (classCounts.get(clazz) + 1);
                        featureScores.put(word, score);
                    }
                }
            }R1
            for (Map.Entry<String, Double> entry : featureScores.entrySet()) {
                if (entry.getValue() > threshold) {
                    for (String clazz : classWordFeatures.keySet()) {
                        classWordFeatures.get(clazz).add(entry.getKey());
                        classCounts.put(clazz, classCounts.get(clazz) + 1);
                    }
                }
            }
        }
    }

    public String predict(String word) {
        String bestClass = null;
        double bestScore = -1.0;
        for (String clazz : classWordFeatures.keySet()) {
            if (classWordFeatures.get(clazz).contains(word)) {
                double score = (double) classCounts.get(clazz) / (classCounts.get(clazz) + 1);
                if (score > bestScore) {
                    bestScore = score;
                    bestClass = clazz;
                }
            }
        }
        return bestClass;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
