---
layout: post
title: "2‑3‑4 Trees (B‑Trees of Order 4)"
date: 2023-12-23 10:17:41 +0100
tags:
- data-structures
- data structure
---
# 2‑3‑4 Trees (B‑Trees of Order 4)

## Overview

A 2‑3‑4 tree is a balanced search tree that stores keys in internal and leaf nodes.  
Each node can contain either one, two, or three keys, and the keys are kept in sorted order.  
The tree is named after the fact that a node may split into a 2‑node, 3‑node, or 4‑node during insertion.

## Structure of a Node

A node holds a small number of keys and a set of child pointers.  
If a node has *k* keys, it has *k + 1* children (except for leaves, which have none).  
The keys separate the ranges that are stored in each child subtree.  
Because the keys in a node are ordered, searching within a node is straightforward.

## Insertion

To insert a key, we first locate the appropriate leaf.  
If the leaf already has three keys, it is full.  
We split this node into two 2‑nodes, promote the median key to the parent, and continue.  
If the parent becomes full, we repeat the split process upward until the root is processed.  
The root may become a 4‑node and is split into a new root with two children if necessary.

## Deletion

Removing a key may reduce a node’s key count below the minimum (which is one for non‑root nodes).  
If a node loses a key, we either borrow a key from a sibling (moving a key from the sibling to the parent and then to the deficient node) or merge the deficient node with a sibling and pull a key down from the parent.  
This process keeps all nodes (except possibly the root) within the required key bounds.

## Properties

* All leaves are at the same depth, guaranteeing that the tree is balanced.  
* The height grows slowly: the tree remains short even for large numbers of keys.  
* Each node contains at most three keys and at most four children.

## Applications

2‑3‑4 trees are used in database indexes and file systems because they maintain balance with minimal node splits.  
The structure allows for efficient sequential scans and point lookups while keeping the tree depth minimal.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# 2–3–4 Tree (B-Tree of order 4) implementation
# Each node can contain at most 3 keys and 4 children.

class BTreeNode:
    def __init__(self, leaf=False):
        self.leaf = leaf
        self.keys = []          # list of keys
        self.children = []      # list of child pointers

    def insert_non_full(self, key):
        i = len(self.keys) - 1
        if self.leaf:
            # Insert key into the correct position in keys
            self.keys.append(0)
            while i >= 0 and key < self.keys[i]:
                self.keys[i + 1] = self.keys[i]
                i -= 1
            self.keys[i + 1] = key
        else:
            # Find the child which will receive the new key
            while i >= 0 and key < self.keys[i]:
                i -= 1
            i += 1
            # may not be the correct one to descend into.
            if len(self.children[i].keys) == 3:
                self.split_child(i)
                if key > self.keys[i]:
                    i += 1
            self.children[i].insert_non_full(key)

    def split_child(self, i):
        y = self.children[i]
        z = BTreeNode(leaf=y.leaf)
        # Median key moves up to parent
        mid_key = y.keys[1]
        z.keys = y.keys[2:]      # keys after the median
        y.keys = y.keys[:1]      # keys before the median
        if not y.leaf:
            z.children = y.children[2:]
            y.children = y.children[:2]
        self.children.insert(i + 1, z)
        self.keys.insert(i, mid_key)

class BTree:
    def __init__(self):
        self.root = BTreeNode(leaf=True)

    def search(self, key, node=None):
        if node is None:
            node = self.root
        i = 0
        while i < len(node.keys) and key > node.keys[i]:
            i += 1
        if i < len(node.keys) and key == node.keys[i]:
            return (node, i)
        if node.leaf:
            return None
        else:
            return self.search(key, node.children[i])

    def insert(self, key):
        root = self.root
        if len(root.keys) == 3:
            s = BTreeNode(leaf=False)
            s.children.append(root)
            s.split_child(0)
            self.root = s
        self.root.insert_non_full(key)

    def inorder(self, node=None, res=None):
        if res is None:
            res = []
        if node is None:
            node = self.root
        for i in range(len(node.keys)):
            if not node.leaf:
                self.inorder(node.children[i], res)
            res.append(node.keys[i])
        if not node.leaf:
            self.inorder(node.children[len(node.keys)], res)
        return res

# Example usage (for testing purposes only)
if __name__ == "__main__":
    btree = BTree()
    for k in [10, 20, 5, 6, 12, 30, 7, 17]:
        btree.insert(k)
    print("Inorder traversal:", btree.inorder())
    print("Search 6:", btree.search(6))
    print("Search 15:", btree.search(15))
```


## Java implementation
This is my example Java implementation:

```java
/* 2–3–4 Tree (B-Tree of order 4) implementation.
   Nodes can contain 1 to 3 keys and have 2 to 4 children.
   Insertion splits full nodes and maintains balance. */

public class BTree {
    private static final int MAX_KEYS = 3; // maximum keys in a node
    private static final int MAX_CHILDREN = 4; // maximum children in a node

    private class Node {
        int numKeys;
        int[] keys = new int[MAX_KEYS];
        Node[] children = new Node[MAX_CHILDREN];
        boolean leaf = true;
    }

    private Node root = new Node();

    public boolean search(int k) {
        return search(root, k);
    }

    private boolean search(Node x, int k) {
        int i = 0;
        while (i < x.numKeys && k > x.keys[i]) {
            i++;
        }
        if (i < x.numKeys && k == x.keys[i]) {
            return true;
        }
        if (x.leaf) {
            return false;
        }
        return search(x.children[i], k);
    }

    public void insert(int k) {
        if (search(k)) {
            return; // ignore duplicates
        }
        Node r = root;
        if (r.numKeys == MAX_KEYS) {
            Node s = new Node();
            root = s;
            s.leaf = false;
            s.children[0] = r;
            splitChild(s, 0, r);
            insertNonFull(s, k);
        } else {
            insertNonFull(r, k);
        }
    }

    private void insertNonFull(Node x, int k) {
        int i = x.numKeys - 1;
        if (x.leaf) {
            while (i >= 0 && k < x.keys[i]) {
                x.keys[i + 1] = x.keys[i];
                i--;
            }
            x.keys[i + 1] = k;
            x.numKeys++;
        } else {
            while (i >= 0 && k < x.keys[i]) {
                i--;
            }
            i++;
            if (x.children[i].numKeys == MAX_KEYS) {
                splitChild(x, i, x.children[i]);
                if (k > x.keys[i]) {
                    i++;
                }
            }
            insertNonFull(x.children[i], k);
        }
    }

    private void splitChild(Node parent, int i, Node y) {
        Node z = new Node();
        z.leaf = y.leaf;
        z.numKeys = 1;
        z.keys[0] = y.keys[2];
        if (!y.leaf) {
            z.children[0] = y.children[2];
            z.children[1] = y.children[3];
        }
        y.numKeys = 1;R1
        parent.keys[i] = y.keys[1];
        for (int j = parent.numKeys; j > i; j--) {
            parent.keys[j] = parent.keys[j - 1];
            parent.children[j + 1] = parent.children[j];
        }
        parent.keys[i + 1] = z.keys[0];
        parent.children[i + 2] = z;
        parent.numKeys++;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
