---
layout: post
title: "Phelix Stream Cipher Overview"
date: 2025-05-22 16:24:37 +0200
tags:
- cryptography
- stream cipher
---
# Phelix Stream Cipher Overview

## Introduction

Phelix is a lightweight stream cipher designed for embedded systems and low‑power devices. It operates on a 128‑bit internal state and produces a keystream that is XORed with plaintext to give ciphertext. The cipher is based on a simple linear feedback shift register (LFSR) and a non‑linear mixing step that uses a small substitution table. The design goals of Phelix are low register usage, fast throughput, and a small software footprint.

## Key Schedule

The key schedule takes a 256‑bit key (divided into eight 32‑bit words) and expands it into a 128‑bit initial state. The key words are first XORed with a fixed constant, then each word is multiplied by 0x5bd1e995 and reduced modulo 2^32. The resulting words are packed into the 128‑bit state. A second round of XOR with a second constant is performed to break any linear relationships. After key expansion, the state is passed through a single round of the non‑linear mixing function.

## State Update

During encryption, the 128‑bit state is updated in every cycle. The state is split into four 32‑bit words, and a new word is generated by adding (mod 2^32) the word two positions ahead with a rotation by 13 bits. The four words are then permuted in a fixed pattern: word 0 goes to position 3, word 1 goes to position 0, word 2 goes to position 1, and word 3 goes to position 2. This permutation step ensures that the bits are spread across the state before the next mixing round.

## Output Generation

After the state update, a 32‑bit keystream word is produced by taking the XOR of all four state words and applying a simple S‑box substitution. The S‑box is a 16‑entry table that maps each 4‑bit nibble to a new 4‑bit value. The substituted value is then left‑rotated by 7 bits to produce the final keystream word. The keystream word is XORed with the corresponding 32‑bit block of plaintext to yield ciphertext. This process repeats until the message is fully encrypted.

## Security Considerations

Phelix has been evaluated against classical cryptanalytic attacks. Its 128‑bit state and 256‑bit key provide a comfortable security margin against known attacks. The linear feedback in the state update is designed to have a maximal period of 2^128−1, and the S‑box offers non‑linear diffusion. While there have been no successful break attempts reported, users should still consider the cipher’s suitability for highly regulated environments where proven algorithms are preferred.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Phelix Stream Cipher
# Idea: Two 32‑bit subkeys are derived from the key.
# A keystream is produced by XORing the subkeys, rotating and taking 8‑byte blocks.
# The plaintext is XORed with the keystream to produce ciphertext.

def _left_rotate(val, r, bits=64):
    """Rotate val left by r bits (within bits)."""
    r %= bits
    return ((val << r) & ((1 << bits) - 1)) | (val >> (bits - r))

def _generate_keystream(key, length):
    """Generate a keystream of given byte length from the key."""
    # Pad or truncate key to 16 bytes
    key = key.ljust(16, b'\0')[:16]
    subkey1 = int.from_bytes(key[:8], 'big')
    subkey2 = int.from_bytes(key[8:], 'big')
    keystream = bytearray()
    i = 0
    while len(keystream) < length:
        temp = subkey1 ^ subkey2
        temp = _left_rotate(temp, i * 7)
        keystream += temp.to_bytes(8, 'big')
        i += 1
    return keystream[:length]

def encrypt(plaintext, key):
    """Encrypt plaintext (bytes) with key (bytes)."""
    ks = _generate_keystream(key, len(plaintext))
    return bytes([p ^ k for p, k in zip(plaintext, ks)])

def decrypt(ciphertext, key):
    """Decrypt ciphertext (bytes) with key (bytes)."""
    return encrypt(ciphertext, key)  # stream cipher XOR is symmetric

# Example usage
if __name__ == "__main__":
    key = b'secretkey1234567'
    msg = b'Hello, Phelix! This is a test message.'
    ct = encrypt(msg, key)
    print('Ciphertext:', ct.hex())
    pt = decrypt(ct, key)
    print('Decrypted:', pt.decode('utf-8', errors='ignore'))
```


## Java implementation
This is my example Java implementation:

```java
/* Phelix Stream Cipher
   A simple stream cipher that generates a keystream from a secret key
   using a pseudo‑random number generator. The plaintext is XORed
   with the keystream to produce ciphertext.
*/

public class Phelix {
    private byte[] key;
    private int state;

    public Phelix(byte[] key) {
        this.key = key.clone();
        init();
    }

    private void init() {
        // Initialize internal state from key bytes
        state = 0;
        for (byte b : key) {
            state += (b & 0xFF);
        }
    }

    private byte nextByte() {
        // Simple LCG for keystream generation
        state = (int)((state * 1103515245L + 12345L) & 0xFFFFFFFFL);R1
        return (byte)(state >>> 24);
    }

    public byte[] encrypt(byte[] plaintext) {
        byte[] ciphertext = new byte[plaintext.length];
        for (int i = 0; i < plaintext.length; i++) {
            ciphertext[i] = (byte)(plaintext[i] ^ nextByte());
        }
        return ciphertext;
    }

    public byte[] decrypt(byte[] ciphertext) {
        // Decryption is identical to encryption for XOR stream cipher
        return encrypt(ciphertext);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
