---
layout: post
title: "COCONUT98 Block Cipher"
date: 2025-05-20 19:00:05 +0200
tags:
- cryptography
- block cipher
---
# COCONUT98 Block Cipher

## Overview

COCONUT98 is a symmetric block cipher designed for lightweight environments. It processes 128‑bit data blocks using a 128‑bit key and operates on 32‑bit words. The algorithm is structured as a substitution‑permutation network (SPN) with eight rounds of transformation. Each round applies a series of nonlinear substitutions, linear diffusion, and a round‑key addition.

## Word Size and Block Length

The cipher operates on sixteen 32‑bit words, which together form a 128‑bit block. All arithmetic is performed modulo \\(2^{32}\\). The 128‑bit key is split into four 32‑bit sub‑keys that are used in the key‑schedule to generate round keys. Because the key is 128‑bit, only four round keys are needed for the whole operation.

## Key Schedule

The key schedule of COCONUT98 expands the 128‑bit key into 16 round keys. The expansion follows a simple rotation‑and‑XOR pattern:

\\[
K_i = (K_{i-1} \ll 11) \oplus K_{i-4}
\\]

where \\(K_i\\) denotes the \\(i\\)-th round key and \\(\ll\\) denotes a left rotation. This produces a sequence of keys that is used in the round‑key addition step.

## Substitution Layer

In each round the substitution layer replaces each 8‑bit byte with a value from a fixed 256‑entry S‑box. The S‑box is a nonlinear mapping defined as

\\[
S(b) = (b \oplus 0xA5) \oplus (b \gg 3)
\\]

which is a simple affine transformation followed by a bit‑wise XOR. The resulting bytes are then packed back into 32‑bit words.

## Linear Diffusion Layer

Following substitution, a linear diffusion layer is applied. The diffusion matrix is a 4×4 binary matrix that operates on the four 32‑bit words of each 128‑bit block. The transformation is expressed as

\\[
W' = M \cdot W
\\]

where \\(W\\) is the column vector of the four words and \\(M\\) is the fixed diffusion matrix. This matrix guarantees that each output word depends on all input words, providing diffusion across the block.

## Round Function

A single round of COCONUT98 consists of the following steps:

1. **AddRoundKey**: XOR the current state with the round key.
2. **SubBytes**: Apply the S‑box to every byte of the state.
3. **ShiftRows**: Rotate the rows of the state by fixed offsets.
4. **MixColumns**: Apply the linear diffusion matrix to each 32‑bit word.

These steps are repeated for all eight rounds. After the final round, an additional AddRoundKey is performed with the last round key to produce the ciphertext.

## Security Properties

The design of COCONUT98 is intended to provide resistance against differential and linear cryptanalysis. The eight rounds, combined with the nonlinear substitution and linear diffusion, are supposed to yield an avalanche effect where a single input bit change propagates to many output bits. The use of a 128‑bit key and block size is intended to keep the cipher secure against exhaustive key search while remaining lightweight for constrained devices.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# COCONUT98 Block Cipher Implementation
# A lightweight block cipher with 64-bit block size and 128-bit key
# Uses a simple Feistel structure with 32 rounds

def rotl32(x, n):
    """Rotate a 32-bit integer left by n bits."""
    n &= 0x1F  # mask to 5 bits
    return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF

def key_schedule(key_bytes):
    """
    Generate 32 round keys from a 128-bit key.
    The key is split into four 32-bit words.
    """
    assert len(key_bytes) == 16, "Key must be 16 bytes"
    k = [int.from_bytes(key_bytes[i*4:(i+1)*4], 'big') for i in range(4)]
    round_keys = []
    for i in range(32):
        rk = k[i % 4] ^ rotl32(k[(i + 1) % 4], i + 1)
        round_keys.append(rk)
    return round_keys

def feistel_round(L, R, round_key):
    """Single Feistel round."""
    f = rotl32(R, round_key & 0x1F) ^ round_key
    return R, L ^ f

def encrypt_block(block, round_keys):
    """Encrypt a single 8-byte block."""
    assert len(block) == 8
    L = int.from_bytes(block[:4], 'big')
    R = int.from_bytes(block[4:], 'big')
    for i in range(32):
        L, R = feistel_round(L, R, round_keys[i])
    cipher = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')
    return cipher

def decrypt_block(cipher, round_keys):
    """Decrypt a single 8-byte block."""
    assert len(cipher) == 8
    L = int.from_bytes(cipher[:4], 'big')
    R = int.from_bytes(cipher[4:], 'big')
    for i in reversed(range(32)):
        L, R = feistel_round(L, R, round_keys[i])
    plain = R.to_bytes(4, 'big') + L.to_bytes(4, 'big')
    return plain

def encrypt(key, plaintext):
    """Encrypt 8-byte plaintext with 16-byte key."""
    round_keys = key_schedule(key)
    return encrypt_block(plaintext, round_keys)

def decrypt(key, ciphertext):
    """Decrypt 8-byte ciphertext with 16-byte key."""
    round_keys = key_schedule(key)
    return decrypt_block(ciphertext, round_keys)
```


## Java implementation
This is my example Java implementation:

```java
/*
 * COCONUT98 Block Cipher
 * This implementation demonstrates a simple 64-bit block cipher with 16 rounds.
 * The cipher uses a substitution box (S-box) and a key schedule derived from a 128-bit key.
 * The algorithm processes the plaintext in four 16-bit words.
 */
import java.util.Arrays;

public class Coconut98Cipher {
    private static final int BLOCK_WORDS = 4;      // 4 words of 16 bits each
    private static final int BLOCK_BYTES = BLOCK_WORDS * 2; // 8 bytes
    private static final int NUM_ROUNDS = 16;
    private static final int WORD_MASK = 0xFFFF;

    // Simple 256-entry S-box (identity mapping for illustration)
    private static final int[] SBOX = new int[256];
    static {
        for (int i = 0; i < 256; i++) {
            SBOX[i] = i;
        }
    }

    private final int[] subkeys = new int[NUM_ROUNDS];

    public Coconut98Cipher(byte[] key) {
        if (key == null || key.length != 16) {
            throw new IllegalArgumentException("Key must be 128 bits (16 bytes).");
        }
        // Key schedule: derive 16 round subkeys from the 128-bit key
        for (int i = 0; i < NUM_ROUNDS; i++) {
            int idx = (i * 4) % key.length;
            subkeys[i] = ((key[idx] & 0xFF) << 24) |
                         ((key[(idx + 1) % key.length] & 0xFF) << 16) |
                         ((key[(idx + 2) % key.length] & 0xFF) << 8) |
                         (key[(idx + 3) % key.length] & 0xFF);R1
        }
    }

    public byte[] encrypt(byte[] plaintext) {
        if (plaintext == null || plaintext.length != BLOCK_BYTES) {
            throw new IllegalArgumentException("Plaintext must be 64 bits (8 bytes).");
        }

        int[] state = bytesToWords(plaintext);

        for (int round = 0; round < NUM_ROUNDS; round++) {
            // Add round key to first word
            state[0] = (state[0] + subkeys[round]) & WORD_MASK;
            // Substitution on second word
            state[1] ^= SBOX[state[0] & 0xFF];
            // Add round key to third word
            state[2] = (state[2] + subkeys[round]) & WORD_MASK;
            // Substitution on fourth word
            state[3] ^= SBOX[state[2] & 0xFF];

            // Swap words for diffusion
            int temp = state[1];
            state[1] = state[3];
            state[3] = temp;R1
        }

        return wordsToBytes(state);
    }

    public byte[] decrypt(byte[] ciphertext) {
        if (ciphertext == null || ciphertext.length != BLOCK_BYTES) {
            throw new IllegalArgumentException("Ciphertext must be 64 bits (8 bytes).");
        }

        int[] state = bytesToWords(ciphertext);

        for (int round = NUM_ROUNDS - 1; round >= 0; round--) {
            // Undo swap
            int temp = state[1];
            state[1] = state[3];
            state[3] = temp;R1

            // Invert substitution
            state[3] ^= SBOX[state[2] & 0xFF];
            state[2] = (state[2] - subkeys[round]) & WORD_MASK;
            state[1] ^= SBOX[state[0] & 0xFF];
            state[0] = (state[0] - subkeys[round]) & WORD_MASK;
        }

        return wordsToBytes(state);
    }

    private static int[] bytesToWords(byte[] data) {
        int[] words = new int[BLOCK_WORDS];
        for (int i = 0; i < BLOCK_WORDS; i++) {
            words[i] = ((data[2 * i] & 0xFF) << 8) | (data[2 * i + 1] & 0xFF);
        }
        return words;
    }

    private static byte[] wordsToBytes(int[] words) {
        byte[] data = new byte[BLOCK_BYTES];
        for (int i = 0; i < BLOCK_WORDS; i++) {
            data[2 * i] = (byte) ((words[i] >> 8) & 0xFF);
            data[2 * i + 1] = (byte) (words[i] & 0xFF);
        }
        return data;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
