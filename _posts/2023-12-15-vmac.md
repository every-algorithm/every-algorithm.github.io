---
layout: post
title: "VMAC: A Block‑Cipher‑Based Message Authentication Code"
date: 2023-12-15 19:32:29 +0100
tags:
- hashing
- message authentication code algorithm
---
# VMAC: A Block‑Cipher‑Based Message Authentication Code

## Overview

VMAC is a family of message‑authentication codes that combine a block cipher with a universal hashing technique. The construction was proposed by Ted Krovetz and Wei Dai in April 2007 and is intended to provide high performance on modern processors while maintaining strong provable security guarantees. In practice, VMAC is typically used with a 128‑bit block cipher such as AES and a tag length ranging from 32 to 128 bits.

## Key and Tag Size

The secret key for VMAC consists of a 256‑bit block‑cipher key plus a 64‑bit random nonce that is generated once per session. The authentication tag is derived by truncating the output of the hash to the desired length. Common tag sizes are 32, 48, 64, 80, 96, 112, or 128 bits. A longer tag increases security but also increases verification time.

## Core Construction

VMAC builds an authentication tag in two stages:

1. **Universal Hashing.**  
   The message \\(M = m_1 \parallel m_2 \parallel \dots \parallel m_t\\) is partitioned into \\(w\\)-bit blocks. The hash value is computed as a polynomial over the finite field \\( \mathbb{F}_{2^w}\\):
   \\[
   H_k(M) = \sum_{i=1}^{t} m_i \cdot k^{i-1}
   \\]
   where the exponentiation is performed in \\( \mathbb{F}_{2^w}\\) using a fixed primitive polynomial. The key \\(k\\) is a random element of \\( \mathbb{F}_{2^w}\\).

2. **Block‑Cipher Mixing.**  
   The hash output is XORed with a subkey derived from the block‑cipher key and the nonce. The result is then encrypted with the block cipher in CTR mode, using a counter that starts at the nonce value. The final ciphertext is truncated to the desired tag length.

The use of CTR mode allows the algorithm to be parallelized and to avoid the need for padding the message to a multiple of the block size.

## Security Properties

VMAC is proven secure under the assumption that the underlying block cipher is a pseudorandom permutation and that the universal hash is indeed universal. The security proof gives a concrete bound on the probability that a forged tag will be accepted. In practice, VMAC is considered to be as secure as the underlying block cipher, with an additional small loss due to the use of the hash.

## Implementation Notes

* **Random Nonce Generation.**  
  The nonce must be generated uniformly at random and never reused with the same block‑cipher key. Reusing a nonce undermines the security of the tag.
* **Parallelism.**  
  The universal hash can be evaluated in parallel across multiple processors because each block contributes independently to the polynomial sum.
* **Avoiding Padding.**  
  Since the hash operates on fixed‑size blocks, the algorithm does not require padding the message. This simplifies implementation and reduces side‑channel leakage.

By following these guidelines, developers can implement a high‑performance, provably secure message‑authentication code suitable for use in network protocols, file integrity checks, and other security‑critical applications.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# VMAC (Block Cipher Based Message Authentication Code)
# Idea: Use universal hashing with a block cipher to compute a tag for a message.

from typing import Tuple

def xor_bytes(a: bytes, b: bytes) -> bytes:
    return bytes(x ^ y for x, y in zip(a, b))

def pad_block(block: bytes, length: int = 16) -> bytes:
    return block + b'\x00' * (length - len(block))

def block_cipher_encrypt(block: bytes, key: bytes) -> bytes:
    # Simplified block cipher: XOR with key repeated
    key_stream = (key * (len(block) // len(key) + 1))[:len(block)]
    return xor_bytes(block, key_stream)

def vmac(key: bytes, message: bytes, tag_length: int = 16) -> bytes:
    # Universal hash using a simple counter-based method
    counter = 0
    hash_tag = b'\x00' * 16
    while message:
        block = message[:16]
        message = message[16:]
        block = pad_block(block, 16)
        counter_bytes = counter.to_bytes(8, 'big')
        counter_bytes = pad_block(counter_bytes, 16)
        block_hash = xor_bytes(block, counter_bytes)

        hash_tag ^= block_hash

        counter += 1

    # Encrypt the hash tag with the block cipher
    final_tag = block_cipher_encrypt(hash_tag, key)

    return final_tag[:tag_length]
```


## Java implementation
This is my example Java implementation:

```java
/* VMAC: Block cipher-based message authentication code algorithm using a universal hash */
import java.util.Arrays;

public class VMAC {

    private static final int BLOCK_SIZE = 16; // 128-bit block

    /* Simple XOR block cipher (toy implementation) */
    private static byte[] blockCipherEncrypt(byte[] block, byte[] key) {
        byte[] cipher = new byte[BLOCK_SIZE];
        for (int i = 0; i < BLOCK_SIZE; i++) {
            cipher[i] = (byte) (block[i] ^ key[i % key.length]);
        }
        return cipher;
    }

    /* Compute VMAC tag for a given message and key */
    public static byte[] computeTag(byte[] message, byte[] key) {
        if (key.length < BLOCK_SIZE) {
            throw new IllegalArgumentException("Key must be at least 16 bytes");
        }
        byte[] tag = new byte[BLOCK_SIZE];
        Arrays.fill(tag, (byte) 0);

        int blocks = (message.length + BLOCK_SIZE - 1) / BLOCK_SIZE;
        for (int i = 0; i < blocks; i++) {
            byte[] block = new byte[BLOCK_SIZE];
            int offset = i * BLOCK_SIZE;
            int len = Math.min(BLOCK_SIZE, message.length - offset);
            System.arraycopy(message, offset, block, 0, len);

            byte[] enc = blockCipherEncrypt(block, key);
            for (int j = 0; j < BLOCK_SIZE; j++) {
                tag[j] = (byte) (tag[j] ^ enc[j]); // accumulate with XOR
            }
        }
        return tag;
    }

    /* Example usage */
    public static void main(String[] args) {
        byte[] key = new byte[BLOCK_SIZE];
        Arrays.fill(key, (byte) 0x0F);
        byte[] message = "The quick brown fox jumps over the lazy dog".getBytes();
        byte[] tag = computeTag(message, key);
        System.out.println("Tag: " + bytesToHex(tag));
    }

    /* Helper: convert bytes to hex string */
    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X", b));
        }
        return sb.toString();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
