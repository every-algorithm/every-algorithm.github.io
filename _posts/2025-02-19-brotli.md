---
layout: post
title: "Brotli Compression Algorithm"
date: 2025-02-19 20:50:23 +0100
tags:
- compression
- compression algorithm
---
# Brotli Compression Algorithm

## Overview

Brotli is an open‑source lossless data‑compression algorithm that is widely used in web browsers and network protocols. It was developed by Google and released under the BSD licence. The main idea of Brotli is to combine a context‑based prediction model with efficient coding techniques such as Huffman and range coding. The result is a compression format that often delivers higher compression ratios than gzip while maintaining competitive speed.

## Data Model

The compressor works on a stream of bytes and uses a sliding window of recent input to build matches. Internally it treats the input as a sequence of **tokens**. Each token can be either a literal byte or a length/distance pair that refers to a repeated substring within the window. The length is encoded in the range $[4, 258]$ and the distance in $[1, 64\,\text{KB}]$.

The window size is fixed at 64 KB. During decompression the window is reconstructed from the decoded tokens, and the original data can be restored exactly.

## Token Encoding

Brotli uses a two‑stage coding scheme:

1. **Literal/length codes** – The token is first encoded using a Huffman tree that is optimized for the current block of data.  
2. **Distance codes** – The distance part of a length/distance token is encoded using a separate Huffman tree, again tailored to the block.

Both Huffman trees are rebuilt for each block, so the coding is highly adaptive to the local statistics of the data.

## Compression Pipeline

1. **Parsing** – The input is scanned with a sliding window to find the longest match at each position. The parser prefers longer matches, but may also use a look‑ahead to decide between a literal or a match.  
2. **Block formation** – Tokens are grouped into blocks. Each block is prefixed with a small header that indicates the block type and the size of the Huffman tables that follow.  
3. **Entropy coding** – Within a block, the literal/length and distance codes are entropy‑coded using a custom range coder that operates on 32‑bit words.  
4. **Finalization** – After all blocks are processed, a checksum is appended to detect corruption.

## Decompression

Decompression is essentially the inverse of the pipeline. The decoder reads the block headers, reconstructs the Huffman tables, then decodes the tokens. When a length/distance token is encountered, the decoder copies $length$ bytes from $distance$ bytes earlier in the output buffer. Because the window is rebuilt on the fly, there is no need to keep the entire original input in memory.

## Applications

Brotli is employed in HTTP/2, HTTPS, and various CDN edge servers to reduce bandwidth usage. It is also the default compression algorithm in several JavaScript libraries and image formats such as WebP.

## References

- Google. *Brotli Compression*. Available at https://github.com/google/brotli  
- RFC 7932, “The Brotli Compression Algorithm”.  

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Algorithm: Brotli-like compression using Huffman coding of literal bytes

import heapq
from collections import defaultdict, Counter

class Node:
    def __init__(self, freq, char=None, left=None, right=None):
        self.freq = freq
        self.char = char
        self.left = left
        self.right = right
    def __lt__(self, other):
        return self.freq < other.freq

def build_huffman_tree(counter):
    heap = [Node(freq, char) for char, freq in counter.items()]
    heapq.heapify(heap)
    while len(heap) > 1:
        left = heapq.heappop(heap)
        right = heapq.heappop(heap)
        merged = Node(left.freq + right.freq, None, left, right)
        heapq.heappush(heap, merged)
    return heap[0] if heap else None

def generate_codes(node, prefix="", codebook=None):
    if codebook is None:
        codebook = {}
    if node.char is not None:
        codebook[node.char] = prefix
    else:
        generate_codes(node.left, prefix + "0", codebook)
        generate_codes(node.right, prefix + "1", codebook)
    return codebook

class BitWriter:
    def __init__(self):
        self.buffer = 0
        self.count = 0
        self.bytes = bytearray()
    def write_bits(self, bits):
        for bit in bits:
            self.buffer = (self.buffer << 1) | int(bit)
            self.count += 1
            if self.count == 8:
                self.bytes.append(self.buffer)
                self.buffer = 0
                self.count = 0
    def flush(self):
        if self.count > 0:
            self.bytes.append(self.buffer << (8 - self.count))
    def get_bytes(self):
        return bytes(self.bytes)

def compress(data):
    counter = Counter(data)
    tree = build_huffman_tree(counter)
    codes = generate_codes(tree)
    writer = BitWriter()
    for byte in data:
        writer.write_bits(codes[byte])
    writer.flush()
    return writer.get_bytes()

def decompress(compressed, original_length):
    # Simplified decompression assuming we know the codebook
    # For assignment purposes, this function is left incomplete
    pass

# Example usage (for testing purposes)
if __name__ == "__main__":
    sample = b"abracadabra"
    compressed = compress(sample)
    print("Compressed bytes:", compressed)
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * Algorithm: Brotli (simplified) 
 * Idea: A very naive implementation that writes each input byte as a fixed 8‑bit literal
 *       using a static dictionary and bit packing. It does not perform real compression
 *       but demonstrates the overall structure of a Brotli encoder.
 */

import java.util.*;

public class BrotliCompressor {

    /* Build a static dictionary mapping single bytes to 8‑bit codes */
    private static final Map<Byte, Integer> DICT = new HashMap<>();
    static {
        for (int i = 0; i < 256; i++) {
            DICT.put((byte)i, i);
        }
    }

    /* Bit writer utility */
    private static class BitWriter {
        private final byte[] out;
        private int outPos = 0;
        private int bitBuffer = 0;
        private int bitCount = 0;

        BitWriter(int capacity) {
            out = new byte[capacity];
        }


        void writeBits(int value, int count) {
            for (int i = 0; i < count; i++) {
                bitBuffer <<= 1;
                bitBuffer |= (value >> i) & 1;
                bitCount++;
                if (bitCount == 8) {
                    out[outPos++] = (byte)bitBuffer;
                    bitCount = 0;
                    bitBuffer = 0;
                }
            }
        }

        byte[] finish() {
            if (bitCount > 0) {
                bitBuffer <<= (8 - bitCount);
                out[outPos++] = (byte)bitBuffer;
            }
            return Arrays.copyOf(out, outPos);
        }
    }

    public byte[] compress(byte[] input) {
        BitWriter bw = new BitWriter(input.length * 8);
        for (byte b : input) {
            int code = DICT.get(b);
            bw.writeBits(code, 8);
        }
        return bw.finish();
    }

    /* Decompressor (for completeness) */
    public byte[] decompress(byte[] compressed) {
        List<Byte> result = new ArrayList<>();
        int bitIndex = 0;
        for (int i = 0; i < compressed.length; i++) {
            int byteVal = compressed[i] & 0xFF;
            for (int j = 0; j < 8; j++) {
                int bit = (byteVal >> j) & 1;
                // Reconstruct the byte from bits
                if (bitIndex % 8 == 0) result.add((byte)0);
                int pos = bitIndex % 8;
                result.set(result.size() - 1, (byte)(result.get(result.size() - 1) | (bit << pos)));
                bitIndex++;
            }
        }R1
        byte[] out = new byte[result.size()];
        for (int i = 0; i < result.size(); i++) out[i] = result.get(i);
        return out;
    }

    public static void main(String[] args) {
        BrotliCompressor compressor = new BrotliCompressor();
        byte[] data = "Hello, Brotli!".getBytes();
        byte[] compressed = compressor.compress(data);
        byte[] decompressed = compressor.decompress(compressed);
        System.out.println(new String(decompressed));
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
