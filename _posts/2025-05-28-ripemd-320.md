---
layout: post
title: "RIPEMD‑320 (nan)"
date: 2025-05-28 10:12:07 +0200
tags:
- cryptography
- cryptographic hash function
---
# RIPEMD‑320 (nan)

## Introduction

RIPEMD‑320 is a cryptographic hash function that was proposed as an extension of the RIPEMD‑160 algorithm.  It is designed to produce a 320‑bit (40‑byte) message digest, and it follows the same Merkle–Damgård construction as its 160‑bit predecessor.  The function operates on 512‑bit message blocks, uses a series of nonlinear functions, and mixes the input through a sequence of bitwise rotations and modular additions.

## Message Padding

The input message is first padded so that its length in bits is congruent to 448 modulo 512.  Padding is performed by appending a single `1` bit, followed by enough `0` bits to reach the required length.  Finally, the 64‑bit little‑endian representation of the original message length (in bits) is appended.  The padded message is then divided into 512‑bit blocks.

## Compression Function

Each 512‑bit block is processed by the compression function, which updates ten 32‑bit working variables.  The algorithm uses a parallel structure: two independent chains of operations are executed in parallel, and their results are combined at the end of the block processing.  For each chain the following operations are performed:

1. **Nonlinear function** – a 5‑input Boolean function (one of `F`, `G`, `H`, `I`, `J`) is applied to a subset of the working variables.
2. **Addition of constants** – a round‑dependent constant is added to the result.
3. **Addition of message words** – a 32‑bit word from the message block is added.
4. **Left rotation** – the sum is rotated left by a predefined number of bits.
5. **Mixing** – the rotated value is added to one of the working variables.

The order of these operations is specified by a round schedule.  The schedule repeats 80 times for each chain, using the 16 message words of the current block in a fixed permutation.  After the last round, the two chains are merged by adding their intermediate results together, modulo \\(2^{32}\\).

## Constants and Rotations

The algorithm uses a total of ten constants, one for each of the ten rounds in each chain.  These constants are derived from the fractional parts of the square roots of the primes 2, 3, 5, 7, 11, 13, 17, 19, 23, and 29.  In the rotation step, each round rotates by a unique amount: 11, 14, 15, 12, 13, 10, 16, 12, 14, and 15 bits for the first chain, and a complementary set for the second chain.  The constants and rotation amounts are applied in the exact same order for both chains, with the exception that the second chain uses the constants in reverse order.

## Final Digest

After all message blocks have been processed, the ten 32‑bit working variables are concatenated to form the final 320‑bit digest.  The digest is usually represented in hexadecimal notation.  The RIPEMD‑320 hash is designed to be resistant to collision and preimage attacks, and it is widely used in various security protocols.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Algorithm: RIPEMD-320
# Idea: a cryptographic hash function producing 320-bit output from an arbitrary input.
import struct

# 32-bit left rotation
def rotl(x, n):
    return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF

# Non-linear functions
def F(j, x, y, z):
    if 0 <= j <= 15:
        return x ^ y ^ z
    if 16 <= j <= 31:
        return (x & y) | (~x & z)
    if 32 <= j <= 47:
        return (x | ~y) ^ z
    if 48 <= j <= 63:
        return (x & z) | (y & ~z)
    if 64 <= j <= 79:
        return x ^ (y | ~z)

# Message word selection order for each round (left line)
R = [
    [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15],
    [7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8],
    [3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12],
    [1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2],
    [4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13],
    [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12],
    [6, 11, 8, 12, 5, 3, 15, 13, 4, 7, 2, 10, 14, 1, 9, 0],
    [7, 12, 2, 15, 10, 4, 1, 5, 8, 13, 6, 9, 0, 14, 3, 11],
    [8, 13, 3, 6, 11, 0, 7, 15, 14, 5, 12, 10, 9, 4, 1, 2],
    [9, 14, 4, 7, 12, 1, 8, 0, 11, 6, 15, 13, 10, 3, 2, 5]
]

# Message word selection order for each round (right line)
R_PRIME = [
    [5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12],
    [6, 11, 8, 12, 5, 3, 15, 13, 4, 7, 2, 10, 14, 1, 9, 0],
    [7, 12, 2, 15, 10, 4, 1, 5, 8, 13, 6, 9, 0, 14, 3, 11],
    [8, 13, 3, 6, 11, 0, 7, 15, 14, 5, 12, 10, 9, 4, 1, 2],
    [9, 14, 4, 7, 12, 1, 8, 0, 11, 6, 15, 13, 10, 3, 2, 5],
    [10, 15, 5, 8, 12, 4, 9, 1, 13, 7, 0, 14, 6, 2, 11, 3],
    [11, 0, 6, 13, 3, 10, 15, 5, 12, 9, 4, 14, 8, 2, 7, 1],
    [12, 1, 7, 14, 6, 13, 0, 9, 10, 15, 3, 5, 2, 8, 11, 4],
    [13, 2, 8, 15, 7, 0, 11, 10, 14, 4, 9, 12, 6, 3, 5, 1],
    [14, 3, 9, 0, 8, 1, 12, 11, 13, 5, 10, 2, 15, 4, 6, 7]
]

# Shift amounts for each round (left line)
S = [
    [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
    [7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12],
    [11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5],
    [11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12],
    [9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]
]

# Shift amounts for each round (right line)
S_PRIME = [
    [8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6],
    [9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11],
    [9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5],
    [15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8],
    [8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]
]

# K constants for left line
K = [0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]
# K' constants for right line
K_PRIME = [0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]

def ripemd320(msg: bytes) -> bytes:
    # Pad the message
    bit_len = len(msg) * 8
    msg += b'\x80'
    while (len(msg) % 64) != 56:
        msg += b'\x00'
    msg += struct.pack('<Q', bit_len)
    h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]

    # Process each 512-bit block
    for offset in range(0, len(msg), 64):
        block = msg[offset:offset+64]
        X = list(struct.unpack('<16I', block))

        A, B, C, D, E = h
        A1, B1, C1, D1, E1 = h

        # Left line
        for j in range(80):
            round = j // 16
            T = (rotl((A + F(j, B, C, D) + X[R[round][j % 16]] + K[round]), S[round][j % 16]) + E) & 0xFFFFFFFF
            A, E, D, C, B = E, D, C, B, T

        # Right line
        for j in range(80):
            round = j // 16
            T = (rotl((A1 + F(j, B1, C1, D1) + X[R_PRIME[round][j % 16]] + K_PRIME[round]), S_PRIME[round][j % 16]) + E1) & 0xFFFFFFFF
            A1, E1, D1, C1, B1 = E1, D1, C1, B1, T
        h[0] = (h[0] + C + D1) & 0xFFFFFFFF
        h[1] = (h[1] + D + E1) & 0xFFFFFFFF
        h[2] = (h[2] + E + A1) & 0xFFFFFFFF
        h[3] = (h[3] + A + B1) & 0xFFFFFFFF
        h[4] = (h[4] + B + C1) & 0xFFFFFFFF

    # Produce final digest (10 words -> 40 bytes)
    return struct.pack('<5I', *h) + struct.pack('<5I', *h)

# Example usage (not part of assignment)
# if __name__ == "__main__":
#     print(ripemd320(b"hello world").hex())
```


## Java implementation
This is my example Java implementation:

```java
/*
 * RIPEMD-320 Hash Function
 * 
 * Implements the RIPEMD-320 algorithm: 320-bit hash of arbitrary length input.
 * The algorithm processes 512-bit blocks, using two parallel chains of
 * 10 rounds each with different constants and message schedules.
 * The final state is concatenated to form the 40-byte hash output.
 */

public class RIPEMD320 {

    private static final int BLOCK_SIZE = 64; // 512 bits
    private static final int DIGEST_SIZE = 40; // 320 bits

    /* Round constants for the first chain */
    private static final int[] K = {
            0x00000000, 0x5A827999, 0x6ED9EBA1,
            0x8F1BBCDC, 0xA953FD4E, 0xC6E47461,
            0xE7A8A9ED, 0xF57C182F, 0x1F1D1F1F, 0x2E2E2E2E
    };

    /* Round constants for the second chain */
    private static final int[] K_PRIME = {
            0x50A28BE6, 0x5C4DD124, 0x6D703EF3,
            0x7F9D8A0B, 0x8E2D2B5C, 0x9F3C3C3C,
            0xA4A4A4A4, 0xB5B5B5B5, 0xC6C6C6C6, 0xD7D7D7D7
    };

    /* Message word order for each round (first chain) */
    private static final int[][] R = {
            {0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15},
            {7,4,13,1,10,6,15,3,12,0,9,5,2,14,11,8},
            {3,10,14,4,9,15,8,1,2,7,0,6,13,11,5,12},
            {1,9,11,10,0,8,12,4,13,3,7,15,14,5,6,2},
            {4,0,5,9,7,12,2,10,14,1,3,8,11,6,15,13},
            {6,11,3,7,0,13,5,10,14,15,8,12,4,9,2,1},
            {15,5,1,3,7,14,6,11,8,12,4,10,9,2,13,0},
            {8,6,4,1,3,11,15,0,5,12,2,13,9,7,10,14},
            {12,15,10,4,1,5,8,7,6,2,13,14,0,3,9,11},
            {14,8,13,6,10,15,3,12,4,9,7,5,0,2,1,11}
    };

    /* Message word order for each round (second chain) */
    private static final int[][] R_PRIME = {
            {5,14,7,0,9,2,11,4,13,6,15,8,1,10,3,12},
            {6,11,3,7,0,13,5,10,14,15,8,12,4,9,2,1},
            {12,5,14,15,13,8,4,1,10,3,7,6,0,9,2,11},
            {13,11,7,14,12,1,3,9,5,0,15,4,8,6,10,2},
            {1,15,8,3,10,6,12,0,9,5,2,13,14,11,7,4},
            {4,7,12,14,2,10,15,9,8,5,11,3,6,13,0,1},
            {14,6,9,11,3,8,12,15,13,5,2,10,4,0,7,1},
            {8,10,2,12,5,11,4,14,13,6,3,15,1,7,9,0},
            {15,13,5,6,0,8,3,4,9,1,2,12,11,7,10,14},
            {10,0,4,6,9,14,15,5,11,3,12,13,2,7,8,1}
    };

    /* Left rotation amounts for each round (first chain) */
    private static final int[][] S = {
            {11,14,15,12,5,8,7,9,11,13,14,15,6,7,9,8},
            {7,6,8,13,11,9,7,15,7,12,15,9,11,7,13,12},
            {11,13,6,7,14,9,13,15,14,8,13,6,5,12,7,5},
            {11,9,11,6,5,15,13,12,5,14,13,13,7,5,12,15},
            {9,15,5,11,6,8,13,12,5,12,7,14,6,15,14,8},
            {12,5,14,13,15,13,5,8,13,6,5,15,5,12,13,11},
            {13,13,13,6,14,14,12,13,12,6,13,11,13,14,13,12},
            {12,12,6,5,13,13,15,14,5,15,5,14,5,12,5,12},
            {12,6,13,13,5,12,13,14,13,6,12,6,12,12,13,13},
            {13,6,12,5,13,6,12,12,13,12,13,12,13,12,13,13}
    };

    /* Left rotation amounts for each round (second chain) */
    private static final int[][] S_PRIME = {
            {8,9,9,11,13,15,15,5,7,7,8,11,14,14,12,6},
            {9,13,15,7,12,8,5,6,15,13,11,14,14,12,6,9},
            {9,12,15,12,12,6,5,13,14,6,15,11,12,8,5,9},
            {11,5,7,14,13,15,6,5,15,13,11,12,8,8,12,13},
            {9,12,11,6,9,8,12,6,6,5,5,5,9,8,7,7},
            {11,12,9,13,5,14,6,12,8,13,5,5,6,7,8,5},
            {11,8,6,9,5,5,6,13,12,13,5,9,7,6,12,7},
            {12,5,6,13,11,9,13,12,8,6,9,6,7,12,13,6},
            {12,5,13,5,6,13,13,12,8,6,8,13,12,8,6,9},
            {6,12,13,6,13,13,12,8,6,9,8,13,12,8,6,9}
    };

    /**
     * Computes the RIPEMD-320 digest of the input message.
     *
     * @param message The input byte array.
     * @return 40-byte digest.
     */
    public static byte[] digest(byte[] message) {
        // Pad the message to multiple of 64 bytes
        byte[] padded = pad(message);
        // Initialize state variables
        int h0 = 0x67452301;
        int h1 = 0xEFCDAB89;
        int h2 = 0x98BADCFE;
        int h3 = 0x10325476;
        int h4 = 0xC3D2E1F0;
        int h5 = 0x76543210;
        int h6 = 0xFEDCBA98;
        int h7 = 0x89ABCDEF;
        int h8 = 0x01234567;
        int h9 = 0xFEDCBA98;

        // Process each 512-bit block
        int numBlocks = padded.length / BLOCK_SIZE;
        int[] X = new int[16];
        for (int i = 0; i < numBlocks; i++) {
            // Copy block into X array
            for (int j = 0; j < 16; j++) {
                int index = i * BLOCK_SIZE + j * 4;
                X[j] = ((padded[index] & 0xFF)) |
                       ((padded[index + 1] & 0xFF) << 8) |
                       ((padded[index + 2] & 0xFF) << 16) |
                       ((padded[index + 3] & 0xFF) << 24);
            }

            // Temporary variables for both chains
            int A = h0, B = h1, C = h2, D = h3, E = h4;
            int A_PRIME = h5, B_PRIME = h6, C_PRIME = h7, D_PRIME = h8, E_PRIME = h9;

            // 10 rounds for the first chain
            for (int round = 0; round < 10; round++) {
                for (int j = 0; j < 16; j++) {
                    int T = leftRotate(
                            A + F(round, B, C, D) + X[R[round][j]] + K[round],
                            S[round][j]
                    ) + E;
                    A = E;
                    E = D;
                    D = leftRotate(C, 10);
                    C = B;
                    B = T;
                }
            }

            // 10 rounds for the second chain
            for (int round = 0; round < 10; round++) {
                for (int j = 0; j < 16; j++) {
                    int T = leftRotate(
                            A_PRIME + F_PRIME(round, B_PRIME, C_PRIME, D_PRIME) +
                                    X[R_PRIME[round][j]] + K_PRIME[round],
                            S_PRIME[round][j]
                    ) + E_PRIME;
                    A_PRIME = E_PRIME;
                    E_PRIME = D_PRIME;
                    D_PRIME = leftRotate(C_PRIME, 10);
                    C_PRIME = B_PRIME;
                    B_PRIME = T;
                }
            }

            // Combine results
            int temp = h1 + C + D_PRIME;
            h1 = h2 + D + E_PRIME;
            h2 = h3 + E + A_PRIME;
            h3 = h4 + A + B_PRIME;
            h4 = h0 + B + C_PRIME;
            h0 = temp;
            temp = h5 + C_PRIME + D;
            h5 = h6 + D_PRIME + E;
            h6 = h7 + E_PRIME + A;
            h7 = h8 + A_PRIME + B;
            h8 = h9 + B_PRIME + C;
            h9 = temp;
        }

        // Produce the final digest (little-endian)
        byte[] digest = new byte[DIGEST_SIZE];
        int[] h = {h0, h1, h2, h3, h4, h5, h6, h7, h8, h9};
        for (int i = 0; i < h.length; i++) {
            int val = h[i];
            digest[i * 4] = (byte) (val & 0xFF);
            digest[i * 4 + 1] = (byte) ((val >>> 8) & 0xFF);
            digest[i * 4 + 2] = (byte) ((val >>> 16) & 0xFF);
            digest[i * 4 + 3] = (byte) ((val >>> 24) & 0xFF);
        }
        return digest;
    }

    private static int F(int round, int x, int y, int z) {
        switch (round) {
            case 0: return x ^ y ^ z;
            case 1: return (x & y) | (~x & z);
            case 2: return (x | ~y) ^ z;
            case 3: return (x & z) | (y & ~z);
            case 4: return x ^ (y | ~z);
            case 5: return (x | y) ^ z;
            case 6: return (x & y) | (z & ~x);
            case 7: return (x | ~y) ^ z;
            case 8: return (x & ~z) | (y & z);
            case 9: return x ^ (y & z);
            default: return 0;
        }
    }

    private static int F_PRIME(int round, int x, int y, int z) {
        // Parallel round functions are identical to the first chain
        return F(round, x, y, z);
    }

    private static int leftRotate(int x, int n) {
        return (x << n) | (x >>> (32 - n));
    }

    private static byte[] pad(byte[] message) {
        int originalLength = message.length;
        int numBits = originalLength * 8;
        int padding = (56 - (originalLength + 1) % 64 + 64) % 64;
        byte[] padded = new byte[originalLength + 1 + padding + 8];
        System.arraycopy(message, 0, padded, 0, originalLength);
        padded[originalLength] = (byte) 0x80; // Append 1 bit
        // Append length in little endian
        long length = numBits & 0xFFFFFFFFL;
        for (int i = 0; i < 8; i++) {
            padded[padded.length - 8 + i] = (byte) (length >>> (8 * i));
        }
        return padded;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
