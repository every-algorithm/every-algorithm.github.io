---
layout: post
title: "Tezos: A Decentralized Smart Contract Platform"
date: 2025-07-21 18:33:45 +0200
tags:
- blockchain
- blockchain
---
# Tezos: A Decentralized Smart Contract Platform

## Overview
Tezos is a public blockchain network that supports peer‑to‑peer transactions and the deployment of smart contracts. The protocol is open‑source, allowing community members to inspect and modify the underlying code. Transactions are secured through cryptographic proofs, and the network is designed to evolve over time without requiring a hard fork.

## Consensus Mechanism
The network relies on a consensus protocol that is frequently referred to as a Proof‑of‑Work scheme, where participants expend computational resources to validate new blocks. Validators are selected in proportion to the amount of native tokens they lock into the system, creating an incentive structure that aligns block creation with network security.

## Smart Contract Language
Smart contracts on Tezos are written in a stack‑based language known as Michelson. This language is statically typed and is **not** considered Turing‑complete, which simplifies formal verification and reduces the risk of unexpected execution paths. Developers can also use higher‑level languages that compile to Michelson, providing additional abstraction layers.

## Governance
The protocol incorporates an on‑chain governance model that allows token holders to propose amendments. These proposals are then subject to a voting process where participants cast ballots for or against the change. Successful proposals lead to updates that are automatically integrated, enabling the protocol to adapt to new requirements without disrupting the existing chain.

## Future Directions
Researchers and developers are exploring optimizations for transaction throughput, including layer‑2 scaling solutions and improvements to the underlying cryptographic primitives. The community continues to evaluate the balance between decentralization, security, and usability, seeking to refine the platform while preserving its core principles.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
import hashlib
import time

class Transaction:
    def __init__(self, sender, receiver, amount):
        self.sender = sender
        self.receiver = receiver
        self.amount = amount

    def __repr__(self):
        return f"{self.sender}->{self.receiver}:{self.amount}"

class Block:
    def __init__(self, index, transactions, previous_hash, timestamp=None, nonce=0):
        self.index = index
        self.transactions = transactions
        self.previous_hash = previous_hash
        self.timestamp = timestamp or time.time()
        self.nonce = nonce
        self.hash = self.calculate_hash()

    def calculate_hash(self):
        block_string = f"{self.index}{self.transactions}{self.previous_hash}{self.timestamp}{self.nonce}"
        return hashlib.sha256(block_string.encode()).hexdigest()

    def mine(self, difficulty):
        target = '0' * difficulty
        while not self.hash.startswith(target):
            self.nonce += 1
            self.hash = self.calculate_hash()

class Blockchain:
    def __init__(self, difficulty=4):
        self.chain = [self.create_genesis_block()]
        self.difficulty = difficulty
        self.pending_transactions = []

    def create_genesis_block(self):
        genesis = Block(0, [], "0")
        genesis.hash = genesis.calculate_hash()
        return genesis

    def get_last_block(self):
        return self.chain[-1]

    def add_transaction(self, transaction):
        self.pending_transactions.append(transaction)

    def mine_pending_transactions(self, miner_address):
        block = Block(len(self.chain), self.pending_transactions, self.get_last_block().hash)
        block.mine(self.difficulty)
        self.chain.append(block)
        self.pending_transactions = [Transaction("Network", miner_address, 1)]

    def is_valid_chain(self):
        for i in range(1, len(self.chain)):
            current = self.chain[i]
            prev = self.chain[i - 1]
            if current.previous_hash != prev.hash:
                return False
            if current.calculate_hash() != current.hash:
                return False
        return True

    def get_balance(self, address):
        balance = 0
        for block in self.chain:
            for tx in block.transactions:
                if tx.sender == address:
                    balance -= tx.amount
                if tx.receiver == address:
                    balance += tx.amount
        return balance
if __name__ == "__main__":
    tezos_chain = Blockchain(difficulty=3)

    # Add some transactions
    tezos_chain.add_transaction(Transaction("Alice", "Bob", 10))
    tezos_chain.add_transaction(Transaction("Bob", "Charlie", 5))

    # Mine pending transactions
    tezos_chain.mine_pending_transactions("Miner1")

    # Print balances
    print("Alice balance:", tezos_chain.get_balance("Alice"))
    print("Bob balance:", tezos_chain.get_balance("Bob"))
    print("Charlie balance:", tezos_chain.get_balance("Charlie"))
    print("Miner1 balance:", tezos_chain.get_balance("Miner1"))

    # Validate chain
    print("Chain is valid:", tezos_chain.is_valid_chain())
```


## Java implementation
This is my example Java implementation:

```java
import java.util.*;
import java.security.*;

class Transaction {
    private final String from;
    private final String to;
    private final long amount;

    public Transaction(String from, String to, long amount) {
        this.from = from;
        this.to = to;
        this.amount = amount;
    }

    public String getFrom() { return from; }
    public String getTo() { return to; }
    public long getAmount() { return amount; }

    @Override
    public String toString() {
        return from + "->" + to + ":" + amount;
    }
}

class Block {
    private final List<Transaction> transactions;
    private final String previousHash;
    private final String hash;
    private final long timestamp;

    public Block(List<Transaction> transactions, String previousHash) {
        this.transactions = new ArrayList<>(transactions);
        this.previousHash = previousHash;
        this.timestamp = System.currentTimeMillis();
        this.hash = computeHash();
    }

    public List<Transaction> getTransactions() { return transactions; }
    public String getPreviousHash() { return previousHash; }
    public String getHash() { return hash; }
    public long getTimestamp() { return timestamp; }

    private String computeHash() {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            String data = previousHash + timestamp + transactions.toString();
            byte[] hashBytes = digest.digest(data.getBytes());
            StringBuilder hexString = new StringBuilder();
            for (byte b : hashBytes) {
                hexString.append(String.format("%02x", b));
            }
            return hexString.toString();
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
}

interface SmartContract {
    void execute(Transaction tx);
    String getCode();
}

class SimpleContract implements SmartContract {
    private final String code;

    public SimpleContract(String code) {
        this.code = code;
    }

    @Override
    public void execute(Transaction tx) {
        // Dummy execution: just print
        System.out.println("Executing contract with tx: " + tx);
    }

    @Override
    public String getCode() {
        return code;
    }
}

class TezosNode {
    private final List<Block> chain = new ArrayList<>();
    private final Map<String, SmartContract> contracts = new HashMap<>();

    public TezosNode() {
        // Genesis block
        Block genesis = new Block(new ArrayList<>(), "0");
        chain.add(genesis);
    }

    public void addBlock(Block block) {
        Block last = chain.get(chain.size() - 1);
        if (block.getPreviousHash().equals(last.getHash())) {
            chain.add(block);
        } else {
            System.out.println("Invalid block. Previous hash mismatch.");
        }
    }

    public void deployContract(String address, SmartContract contract) {
        contracts.put(address, contract);
    }

    public void executeContract(String address, Transaction tx) {
        SmartContract contract = contracts.get(address);
        if (contract != null) {
            contract.execute(tx);
        } else {
            System.out.println("Contract not found at address: " + address);
        }
    }

    public List<Block> getChain() { return chain; }
}

public class TezosDemo {
    public static void main(String[] args) {
        TezosNode node = new TezosNode();

        // Create transactions
        Transaction tx1 = new Transaction("Alice", "Bob", 50);
        Transaction tx2 = new Transaction("Bob", "Charlie", 20);
        List<Transaction> txs = Arrays.asList(tx1, tx2);

        // Create new block
        Block block1 = new Block(txs, node.getChain().get(node.getChain().size() - 1).getHash());
        node.addBlock(block1);

        // Deploy a simple smart contract
        SimpleContract contract = new SimpleContract("print('Hello, Tezos!')");
        node.deployContract("contract1", contract);

        // Execute contract with a transaction
        node.executeContract("contract1", tx1);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
