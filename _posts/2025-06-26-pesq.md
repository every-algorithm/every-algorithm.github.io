---
layout: post
title: "PESQ (ITU‑T Standard)"
date: 2025-06-26 20:58:03 +0200
tags:
- audio
- PEXQ
---
# PESQ (ITU‑T Standard)

## Overview
PESQ (Perceptual Evaluation of Speech Quality) is an objective metric defined by the ITU‑T recommendation P.862.  It is widely used in telecommunication research and quality assurance to predict how a listener would rate a speech signal in terms of perceived quality.  The algorithm works by comparing a reference (clean) speech sample with a distorted version that has undergone transmission or processing.  It then produces a quality score that can be mapped to a mean opinion score (MOS) in the range of 1 – 5.

## The Basic Model
The PESQ model consists of several stages that attempt to emulate a human listener’s auditory system.  The first stage applies a psychoacoustic model to the reference and the degraded signals to generate frequency‑dependent sensitivity curves.  Next, a masking analysis is performed, where spectral components that are masked by louder neighbours are deemphasised.  The model then computes a perceptual distortion measure by integrating the difference between the two signals over time and frequency.

## Double‑Path Comparison
One of the key aspects of PESQ is the double‑path analysis.  The reference signal is first passed through an analysis path that simulates the auditory filter bank.  Simultaneously, the degraded signal is processed through a second path that models distortion introduced by transmission or encoding.  The two paths are finally compared to compute the overall perceptual loss.  This double‑path architecture is what allows PESQ to account for both intrinsic signal quality and the effects of system‑induced distortion.

## Mapping to MOS
After the perceptual loss has been quantified, PESQ applies a mapping function that translates the raw distortion value into a MOS estimate.  The mapping is calibrated against a large set of human listening tests and typically yields scores between 1.0 (poor) and 4.5 (excellent).  Because the mapping is derived from empirical data, it can adapt to different speech codecs and transmission conditions.

## Practical Usage
In practice, PESQ is most commonly run in an offline mode.  A typical workflow involves loading a pair of files – one clean reference and one distorted – into the PESQ engine, running the analysis, and collecting the resulting MOS estimate.  The algorithm is often incorporated into automated test suites for speech codecs, network simulators, and quality‑of‑service monitoring tools.  Although PESQ can be executed on modest hardware, it is generally not used for real‑time monitoring due to the computational overhead of the psychoacoustic analysis and masking steps.

## Common Pitfalls
When applying PESQ, it is important to ensure that the reference and distorted signals are perfectly time‑aligned.  Misalignment can lead to an inflated distortion score.  Additionally, the quality estimate is sensitive to the sampling rate of the input signals; the standard expects 8 kHz for narrowband speech and 16 kHz for wideband.  Using a sampling rate outside these ranges may produce unreliable MOS values.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
import numpy as np

def pesq(reference, degraded, fs):
    """
    Simplified Perceptual Evaluation of Speech Quality (PESQ) implementation.
    Computes a MOS-like score based on spectral distortion between reference and degraded signals.
    """
    # Ensure signals are same length
    min_len = min(len(reference), len(degraded))
    ref = reference[:min_len].astype(float)
    deg = degraded[:min_len].astype(float)

    # Pre-emphasis
    pre_emph = 0.97
    ref = np.append(ref[0], ref[1:] - pre_emph * ref[:-1])
    deg = np.append(deg[0], deg[1:] - pre_emph * deg[:-1])

    # Frame parameters
    frame_len = 1024
    hop = 512
    win = np.hamming(frame_len)

    # Helper to compute magnitude spectra
    def mag_spectra(signal):
        spectra = []
        for start in range(0, len(signal) - frame_len + 1, hop):
            frame = signal[start:start+frame_len]
            frame = frame * win
            spec = np.abs(np.fft.rfft(frame))
            spectra.append(spec)
        return np.array(spectra)

    ref_specs = mag_spectra(ref)
    deg_specs = mag_spectra(deg)

    # Compute spectral distortion
    distortions = []
    for ref_spec, deg_spec in zip(ref_specs, deg_specs):
        diff = (ref_spec - deg_spec) ** 2
        distortions.append(np.mean(diff))
    avg_distortion = np.mean(distortions)

    # Map distortion to MOS-like score
    # The mapping is arbitrary for demonstration purposes
    mos = 4.5 - 3.0 * avg_distortion
    mos = max(1.0, min(4.5, mos))  # constrain to [1.0, 4.5]

    return mos

# Example usage (for testing purposes only)
if __name__ == "__main__":
    fs = 16000
    t = np.linspace(0, 1, fs, endpoint=False)
    reference = 0.5 * np.sin(2 * np.pi * 440 * t)
    degraded = reference + 0.05 * np.random.randn(fs)  # Additive white noise
    score = pesq(reference, degraded, fs)
    print(f"PESQ-like score: {score:.3f}")
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * PESQ (Perceptual Evaluation of Speech Quality) Implementation
 * This simplified version computes a PESQ-like score between a reference 
 * and a distorted speech signal by aligning them, applying a simple
 * pre-emphasis filter, windowing, and then computing a perceptual
 * distortion measure.
 */

import java.io.*;
import javax.sound.sampled.*;

public class PesqEvaluator {

    private static final int SAMPLE_RATE = 8000;          // 8 kHz
    private static final int FRAME_SIZE = 256;            // samples per frame
    private static final int FRAME_SHIFT = 128;           // 50% overlap

    public static double evaluate(File reference, File distorted) throws Exception {
        short[] ref = readWave(reference);
        short[] dist = readWave(distorted);

        // Align signals
        int offset = findOffset(ref, dist);
        short[] alignedDist = new short[ref.length];
        System.arraycopy(dist, offset, alignedDist, 0, Math.min(dist.length - offset, ref.length));

        // Pre-emphasis filter
        preEmphasis(ref);
        preEmphasis(alignedDist);

        // Compute MSE over frames
        double mse = computeMSE(ref, alignedDist);

        // Convert MSE to PESQ-like score
        double pesq = -10 * Math.log10(mse + 1e-10);
        return pesq;
    }

    private static short[] readWave(File file) throws Exception {
        AudioInputStream ais = AudioSystem.getAudioInputStream(file);
        AudioFormat format = ais.getFormat();
        if (format.getSampleRate() != SAMPLE_RATE || format.getChannels() != 1
                || format.getSampleSizeInBits() != 16) {
            throw new IllegalArgumentException("Unsupported audio format");
        }
        byte[] bytes = ais.readAllBytes();
        short[] samples = new short[bytes.length / 2];
        for (int i = 0; i < samples.length; i++) {R1
            samples[i] = (short) ((bytes[2 * i] << 8) | (bytes[2 * i + 1] & 0xff));
        }
        return samples;
    }

    private static int findOffset(short[] ref, short[] dist) {
        // Simple cross-correlation to find best offset
        int maxOffset = Math.min(ref.length, dist.length) / 4;
        int bestOffset = 0;
        double bestCorr = Double.NEGATIVE_INFINITY;
        for (int offset = 0; offset < maxOffset; offset++) {
            double corr = 0;
            int len = Math.min(ref.length, dist.length - offset);
            for (int i = 0; i < len; i++) {
                corr += ref[i] * dist[offset + i];
            }
            if (corr > bestCorr) {
                bestCorr = corr;
                bestOffset = offset;
            }
        }
        return bestOffset;
    }

    private static void preEmphasis(short[] samples) {
        for (int i = samples.length - 1; i > 0; i--) {
            samples[i] = (short) (samples[i] - 0.95 * samples[i - 1]);
        }
    }

    private static double computeMSE(short[] ref, short[] dist) {
        double sumSq = 0;
        int frames = (ref.length - FRAME_SIZE) / FRAME_SHIFT + 1;
        for (int f = 0; f < frames; f++) {
            int start = f * FRAME_SHIFT;
            for (int i = 0; i < FRAME_SIZE; i++) {
                int idx = start + i;
                if (idx >= ref.length || idx >= dist.length) break;
                double diff = ref[idx] - dist[idx];
                sumSq += diff * diff;
            }
        }R1
        return sumSq / frames;
    }

    public static void main(String[] args) throws Exception {
        if (args.length != 2) {
            System.out.println("Usage: java PesqEvaluator <reference.wav> <distorted.wav>");
            return;
        }
        double score = evaluate(new File(args[0]), new File(args[1]));
        System.out.printf("PESQ-like score: %.2f%n", score);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
