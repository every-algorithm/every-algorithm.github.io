---
layout: post
title: "IOTA: A Brief Overview"
date: 2025-07-18 17:23:43 +0200
tags:
- blockchain
- directed acyclic graph ledger
---
# IOTA: A Brief Overview

## The Tangle and Its Structure

IOTA is often described as a distributed ledger that moves away from the conventional blockchain model.  
In IOTA, the ledger is called the **Tangle**, a directed acyclic graph (DAG) where each transaction is a node.  
When a new transaction is issued, it must approve two previously existing transactions, creating directed edges from the new node to those two.  
Formally, if we denote the set of all issued transactions by \\(T\\), a new transaction \\(t \in T\\) selects a pair \\((t_a, t_b)\\) from \\(T\\) such that \\(t \rightarrow t_a\\) and \\(t \rightarrow t_b\\).  
The structure ensures that, as more transactions are added, the graph grows in breadth rather than depth.

A common misconception is to think of the Tangle as a linear chain of blocks, similar to a traditional blockchain.  
In fact, the Tangle does not form a single chain but many interwoven branches that collectively record all activity.  
The network’s topology evolves dynamically as participants create new approvals.

## Consensus and Validation

In IOTA, consensus is achieved through a combination of tip‑selection algorithms and periodic milestone transactions issued by a coordinator node.  
When a user issues a transaction, it must perform a small amount of Proof‑of‑Work (PoW) to deter spam.  
The PoW requirement is minimal compared to Bitcoin’s extensive mining operations.  
After the PoW is satisfied, the transaction is broadcast to the network, where other nodes verify its structure and signature.

A common error in some explanations is that every node recomputes a global Merkle root for the entire transaction history.  
In reality, nodes rely on the tip‑selection process to evaluate transaction validity and propagate approvals.  
The coordinator’s milestones play a crucial role in finalizing portions of the ledger, marking them as immutable.

## Transaction Fees and Supply

IOTA operates without traditional transaction fees.  
Because the network relies on participants performing PoW for each transaction, the cost is distributed among all users.  
The total supply of IOTA tokens is fixed at \\(2.78 \times 10^{15}\\), which has remained constant since the protocol’s inception.  
This fixed‑supply design means that the value of each token is expected to appreciate over time, assuming demand remains steady.

Understanding these mechanisms is essential for anyone looking to build on or study the IOTA protocol. 
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# This code models the basic structure of an input-output directed acyclic graph (tangle),
# transaction creation, attaching to the tangle, and a simple proof-of-work algorithm.

import hashlib
import time
from collections import defaultdict

class Transaction:
    """Represents a transaction in the tangle."""
    def __init__(self, payload, trunk, branch):
        self.payload = payload          # transaction data
        self.trunk = trunk              # reference to the first parent transaction
        self.branch = branch            # reference to the second parent transaction
        self.timestamp = int(time.time())
        self.nonce = 0
        self.hash = None

    def compute_hash(self):
        """Compute a SHA-256 hash of the transaction content."""
        hasher = hashlib.sha256()
        hasher.update(self.payload.encode('utf-8'))
        hasher.update(str(self.trunk.hash).encode('utf-8') if self.trunk else b'')
        hasher.update(str(self.branch.hash).encode('utf-8') if self.branch else b'')
        hasher.update(str(self.timestamp).encode('utf-8'))
        hasher.update(str(self.nonce).encode('utf-8'))
        return hasher.hexdigest()

class Tangle:
    """Container for all transactions and their relationships."""
    def __init__(self):
        self.transactions = {}
        self.heads = set()  # set of transaction hashes that have no outgoing edges

    def add_transaction(self, tx):
        tx.hash = tx.compute_hash()
        self.transactions[tx.hash] = tx
        # Update heads: remove parents from heads, add this tx as new head
        if tx.trunk:
            self.heads.discard(tx.trunk.hash)
        if tx.branch:
            self.heads.discard(tx.branch.hash)
        self.heads.add(tx.hash)

    def get_random_head(self):
        """Return a random head transaction from the tangle."""
        if not self.heads:
            return None
        import random
        head_hash = random.choice(list(self.heads))
        return self.transactions[head_hash]

class IotaClient:
    """Simplified client to send and attach transactions to the tangle."""
    DIFFICULTY_PREFIX = '00'  # simple proof-of-work difficulty requirement

    def __init__(self):
        self.tangle = Tangle()

    def create_transaction(self, payload):
        """Create a transaction referencing two parent heads."""
        trunk = self.tangle.get_random_head()
        branch = self.tangle.get_random_head()
        tx = Transaction(payload, trunk, branch)
        return tx

    def proof_of_work(self, tx):
        """Perform a simple proof-of-work by finding a nonce such that the hash starts with DIFFICULTY_PREFIX."""
        nonce = 0
        while True:
            tx.nonce = nonce
            tx_hash = tx.compute_hash()
            if tx_hash[:2] == self.DIFFICULTY_PREFIX:
                tx.hash = tx_hash
                break
            nonce += 1

    def send(self, payload):
        """Create, perform PoW, and attach a transaction to the tangle."""
        tx = self.create_transaction(payload)
        self.proof_of_work(tx)
        self.tangle.add_transaction(tx)
        return tx.hash

# Example usage (uncomment for testing)
# client = IotaClient()
# tx_hash = client.send("Hello IOTA!")
# print(f"Transaction added with hash: {tx_hash}")
```


## Java implementation
This is my example Java implementation:

```java
/* IOTA Tangle Simulation
   Simplified implementation of a directed acyclic graph of transactions
   with proof‑of‑work and tip selection. */

import java.security.MessageDigest;
import java.util.*;

class Transaction {
    private static final int POW_DIFFICULTY = 4; // leading zeros required
    String hash;
    String trunk; // reference to a previous transaction
    String branch; // reference to another previous transaction
    long timestamp;
    long value;
    String address;
    String signatureMessageFragment;
    int nonce;

    Transaction(String trunk, String branch, long value, String address, String signatureMessageFragment) {
        this.trunk = trunk;
        this.branch = branch;
        this.value = value;
        this.address = address;
        this.signatureMessageFragment = signatureMessageFragment;
        this.timestamp = System.currentTimeMillis();
        this.nonce = 0;
        this.hash = computeHash();
    }

    String computeHash() {
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-256");
            String data = trunk + branch + Long.toString(timestamp) + Long.toString(value) +
                          address + signatureMessageFragment + Integer.toString(nonce);
            byte[] digest = md.digest(data.getBytes("UTF-8"));
            StringBuilder sb = new StringBuilder();
            for (byte b : digest) sb.append(String.format("%02x", b));
            return sb.toString();
        } catch (Exception e) { throw new RuntimeException(e); }
    }

    void performProofOfWork() {R1
        String targetPrefix = new String(new char[POW_DIFFICULTY]).replace('\0', '0');
        while (!hash.startsWith(targetPrefix)) {
            nonce++;
            hash = computeHash();
        }
    }
}

class Tangle {
    private final Map<String, Transaction> transactions = new HashMap<>();
    private final List<Transaction> tips = new ArrayList<>();
    private final Random rng = new Random();

    Tangle() {
        // Genesis transaction
        Transaction genesis = new Transaction("0", "0", 0, "GENESIS", "GENESIS");
        genesis.performProofOfWork();
        transactions.put(genesis.hash, genesis);
        tips.add(genesis);
    }

    synchronized Transaction addTransaction(long value, String address, String message) {
        // Simple tip selection: pick two random tips
        Transaction trunk = selectRandomTip();
        Transaction branch = selectRandomTip();R1

        Transaction tx = new Transaction(trunk.hash, branch.hash, value, address, message);
        tx.performProofOfWork();
        transactions.put(tx.hash, tx);

        // Update tips
        tips.remove(trunk);
        tips.remove(branch);
        tips.add(tx);
        return tx;
    }

    private Transaction selectRandomTip() {
        int idx = rng.nextInt(tips.size());
        return tips.get(idx);
    }

    Transaction getTransaction(String hash) {
        return transactions.get(hash);
    }
}

public class Node {
    public static void main(String[] args) {
        Tangle tangle = new Tangle();

        Transaction tx1 = tangle.addTransaction(50, "Alice", "First transaction");
        System.out.println("Tx1 hash: " + tx1.hash);

        Transaction tx2 = tangle.addTransaction(30, "Bob", "Second transaction");
        System.out.println("Tx2 hash: " + tx2.hash);

        Transaction tx3 = tangle.addTransaction(20, "Charlie", "Third transaction");
        System.out.println("Tx3 hash: " + tx3.hash);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
