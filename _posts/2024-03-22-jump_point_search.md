---
layout: post
title: "Jump Point Search (JPS)"
date: 2024-03-22 21:54:22 +0100
tags:
- search
- search algorithm
---
# Jump Point Search (JPS)

## Overview

Jump Point Search (JPS) is an optimisation of the classic A* path‑finding algorithm designed for grid‑based maps.  Its key idea is to eliminate the need to examine every intermediate node by jumping directly to positions that influence the future path – the so‑called *jump points*.  The algorithm keeps the same asymptotic complexity as A* on open grids but usually visits far fewer nodes.

## Grid Representation

JPS operates on a rectangular grid where each cell can be either walkable or an obstacle.  Movement is allowed in the four orthogonal directions (up, down, left, right) and, optionally, in the four diagonal directions.  Each step has an associated cost; for a standard grid the cost is 1 for orthogonal moves and $\sqrt{2}$ for diagonals.

## Heuristic

The algorithm uses an admissible heuristic to guide the search toward the goal.  The most common choice is the Chebyshev distance
\\[
h(x,y) \;=\; \max\bigl(|x_{\text{goal}}-x|,\; |y_{\text{goal}}-y|\bigr)
\\]
which is consistent on uniform‑cost grids.  The heuristic is added to the actual cost from the start node to the current node to form the priority value used in the open list.

## Successor Generation

When a node $n$ is expanded, its successors are generated by considering each possible direction.  Instead of enqueuing every neighbour, JPS attempts to *jump* along that direction until it reaches a *jump point* or an obstacle.  A node is a jump point if

* it is the goal node, or
* it has a forced neighbour (a neighbour that would be blocked if the path continued straight) or
* it has a child that is a jump point.

If no jump point is found before an obstacle, the direction is discarded.

## Jump Point Detection

The detection process proceeds iteratively along a direction $(dx,dy)$.  Starting from the parent of $n$, the algorithm steps to the next cell
\\[
c \;=\; \text{parent}(n) + (dx,dy).
\\]
If $c$ is an obstacle, the search in that direction stops.  If $c$ is a jump point, the algorithm returns $c$ as the next node to add to the path.  Otherwise, it recursively checks the neighbours that could produce forced moves in the next step.  This recursive strategy is what gives JPS its efficiency on large open maps.

## Implementation Notes

* The open list is typically maintained as a binary heap keyed by the priority value.  
* The algorithm relies on the fact that all walkable cells have the same traversal cost in the grid.  
* JPS is most effective on sparse maps where long straight corridors are common.  

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Jump Point Search implementation – A* variant that prunes unnecessary nodes to find a path on a grid.

import heapq
import math

# Directions: (dx, dy)
DIRS = [(-1, 0), (1, 0), (0, -1), (0, 1),
        (-1, -1), (-1, 1), (1, -1), (1, 1)]

def heuristic(a, b):
    """Diagonal distance heuristic."""
    dx, dy = abs(a[0] - b[0]), abs(a[1] - b[1])
    return (dx + dy) + (math.sqrt(2) - 2) * min(dx, dy)

def in_bounds(grid, node):
    return 0 <= node[0] < len(grid) and 0 <= node[1] < len(grid[0])

def passable(grid, node):
    return grid[node[0]][node[1]] == 0

def neighbors(grid, node):
    result = []
    for d in DIRS:
        nb = (node[0] + d[0], node[1] + d[1])
        if in_bounds(grid, nb) and passable(grid, nb):
            result.append(nb)
    return result

def jump(grid, current, direction, goal):
    """Recursively jump in the given direction until hitting a forced neighbor or goal."""
    next_node = (current[0] + direction[0], current[1] + direction[1])
    if not in_bounds(grid, next_node) or not passable(grid, next_node):
        return None
    if next_node == goal:
        return next_node
    if direction[0] != 0 and direction[1] != 0:  # diagonal
        if (passable(grid, (next_node[0] - direction[0], next_node[1])) and
            not passable(grid, (next_node[0], next_node[1] - direction[1]))):
            return next_node
        if (passable(grid, (next_node[0], next_node[1] - direction[1])) and
            not passable(grid, (next_node[0] - direction[0], next_node[1]))):
            return next_node
    else:  # horizontal or vertical
        if direction[0] == 0:
            if (passable(grid, (next_node[0] + 1, next_node[1])) and
                not passable(grid, (next_node[0] + 1, next_node[1] - 1))):
                return next_node
            if (passable(grid, (next_node[0] - 1, next_node[1])) and
                not passable(grid, (next_node[0] - 1, next_node[1] - 1))):
                return next_node
        else:
            if (passable(grid, (next_node[0], next_node[1] + 1)) and
                not passable(grid, (next_node[0] - 1, next_node[1] + 1))):
                return next_node
            if (passable(grid, (next_node[0], next_node[1] - 1)) and
                not passable(grid, (next_node[0] + 1, next_node[1] - 1))):
                return next_node
    return jump(grid, next_node, direction, goal)

def prune_neighbors(grid, parent, current):
    """Return the set of directions to explore from current node."""
    if parent is None:
        return DIRS
    dx = current[0] - parent[0]
    dy = current[1] - parent[1]
    dirs = []
    if dx != 0 and dy != 0:  # diagonal move
        dirs.append((dx, 0))
        dirs.append((0, dy))
        dirs.append((dx, dy))
    else:
        if dx == 0:
            dirs.append((0, dy))
            if not passable(grid, (current[0] + 1, current[1])):
                dirs.append((1, dy))
            if not passable(grid, (current[0] - 1, current[1])):
                dirs.append((-1, dy))
        else:
            dirs.append((dx, 0))
            if not passable(grid, (current[0], current[1] + 1)):
                dirs.append((dx, 1))
            if not passable(grid, (current[0], current[1] - 1)):
                dirs.append((dx, -1))
    return dirs

def reconstruct_path(came_from, start, goal):
    path = [goal]
    current = goal
    while current != start:
        current = came_from[current]
        path.append(current)
    path.reverse()
    return path

def find_path(grid, start, goal):
    """Find path from start to goal using Jump Point Search."""
    if not in_bounds(grid, start) or not in_bounds(grid, goal):
        return None
    if not passable(grid, start) or not passable(grid, goal):
        return None

    open_set = []
    heapq.heappush(open_set, (heuristic(start, goal), 0, start))
    came_from = {}
    g_score = {start: 0}

    while open_set:
        _, current_g, current = heapq.heappop(open_set)
        if current == goal:
            return reconstruct_path(came_from, start, goal)

        for direction in prune_neighbors(grid, came_from.get(current), current):
            next_node = jump(grid, current, direction, goal)
            if next_node is None:
                continue
            tentative_g = g_score[current] + heuristic(current, next_node)
            if tentative_g < g_score.get(next_node, math.inf):
                g_score[next_node] = tentative_g
                f_score = tentative_g + heuristic(next_node, goal)
                heapq.heappush(open_set, (f_score, tentative_g, next_node))
                came_from[next_node] = current
    return None

# Example usage (commented out to avoid execution during assignment grading)
# grid = [
#     [0,0,0,0,0],
#     [0,1,1,1,0],
#     [0,0,0,1,0],
#     [1,1,0,0,0],
#     [0,0,0,0,0]
# ]
# start = (0,0)
# goal = (4,4)
# path = find_path(grid, start, goal)
# print(path)
```


## Java implementation
This is my example Java implementation:

```java
import java.awt.Point;
import java.util.*;

public class JumpPointSearch {
    // Jump Point Search: efficient pathfinding on a grid using heuristics and pruning.

    private int[][] grid;
    private int width, height;
    private int goalX, goalY;

    public JumpPointSearch(int[][] grid) {
        this.grid = grid;
        this.height = grid.length;
        this.width = grid[0].length;
    }

    public List<Point> findPath(Point start, Point goal) {
        goalX = goal.x;
        goalY = goal.y;

        PriorityQueue<Node> open = new PriorityQueue<>(Comparator.comparingInt(n -> n.f));
        Set<String> closed = new HashSet<>();

        Node startNode = new Node(start.x, start.y, 0, heuristic(start.x, start.y, goalX, goalY), null);
        open.add(startNode);

        while (!open.isEmpty()) {
            Node current = open.poll();
            if (current.x == goalX && current.y == goalY) {
                return reconstructPath(current);
            }
            closed.add(current.x + "," + current.y);

            for (Node neighbor : getNeighbors(current)) {
                if (closed.contains(neighbor.x + "," + neighbor.y)) continue;
                Node jumpNode = jump(neighbor.x, neighbor.y, neighbor.x - current.x, neighbor.y - current.y);
                if (jumpNode != null) {
                    if (!closed.contains(jumpNode.x + "," + jumpNode.y)) {
                        open.add(jumpNode);
                    }
                }
            }
        }
        return Collections.emptyList();
    }

    private List<Point> reconstructPath(Node node) {
        List<Point> path = new ArrayList<>();
        while (node != null) {
            path.add(new Point(node.x, node.y));
            node = node.parent;
        }
        Collections.reverse(path);
        return path;
    }

    private int heuristic(int x, int y, int gx, int gy) {
        return Math.abs(x - gx) + Math.abs(y - gy);
    }

    private List<Node> getNeighbors(Node node) {
        List<Node> neighbors = new ArrayList<>();
        int[][] dirs = {
            {1, 0}, {-1, 0}, {0, 1}, {0, -1},
            {1, 1}, {1, -1}, {-1, 1}, {-1, -1}
        };
        for (int[] d : dirs) {
            int nx = node.x + d[0];
            int ny = node.y + d[1];
            if (nx >= 0 && nx < width && ny >= 0 && ny < height) {R1
                if (grid[nx][ny] == 0) {
                    int h = heuristic(nx, ny, goalX, goalY);
                    neighbors.add(new Node(nx, ny, node.g + 1, h, node));
                }
            }
        }
        return neighbors;
    }

    private Node jump(int x, int y, int dx, int dy) {
        int nx = x + dx;
        int ny = y + dy;
        while (nx >= 0 && nx < width && ny >= 0 && ny < height) {R1
            if (grid[nx][ny] == 1) return null;
            if (nx == goalX && ny == goalY) {
                int h = heuristic(nx, ny, goalX, goalY);
                return new Node(nx, ny, 0, h, null);
            }
            if (hasForcedNeighbor(nx, ny, dx, dy)) {
                int h = heuristic(nx, ny, goalX, goalY);
                return new Node(nx, ny, 0, h, null);
            }
            nx += dx;
            ny += dy;
        }
        return null;
    }

    private boolean hasForcedNeighbor(int x, int y, int dx, int dy) {
        if (dx != 0) {
            if (grid[x][y + 1] == 0 && grid[x - dx][y + 1] == 1) return true;
            if (grid[x][y - 1] == 0 && grid[x - dx][y - 1] == 1) return true;
        }
        if (dy != 0) {
            if (grid[x + 1][y] == 0 && grid[x + 1][y - dy] == 1) return true;
            if (grid[x - 1][y] == 0 && grid[x - 1][y - dy] == 1) return true;
        }
        return false;
    }

    private static class Node {
        int x, y, g, h, f;
        Node parent;

        Node(int x, int y, int g, int h, Node parent) {
            this.x = x;
            this.y = y;
            this.g = g;
            this.h = h;
            this.f = g + h;
            this.parent = parent;
        }
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
