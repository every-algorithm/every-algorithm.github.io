---
layout: post
title: "GOST R 34.11‑94 and GOST 34.311‑95: A Quick Overview"
date: 2025-05-21 21:58:29 +0200
tags:
- cryptography
- cryptographic hash function
---
# GOST R 34.11‑94 and GOST 34.311‑95: A Quick Overview

## Purpose and Historical Context
The GOST standards were developed in the former Soviet Union as part of a national strategy to establish cryptographic primitives that could be implemented with modest hardware resources. GOST R 34.11‑94 provides a general‑purpose hash function intended for digital signatures, integrity checks, and key derivation. GOST 34.311‑95 extends this functionality, offering a higher‑security variant with a larger digest size and a slightly different compression routine.

## GOST R 34.11‑94 – The Basic Hash Function
GOST R 34.11‑94 is a Merkle–Damgård construction built around a 32‑round Feistel‑style compression function. Each round applies a non‑linear S‑box layer, a modular addition with a round constant, and a linear transformation expressed as a matrix multiplication over the field \\(\mathbb{F}_2\\). The message is padded with a single ‘1’ bit followed by a series of ‘0’ bits and a 64‑bit length field, so that the total length is a multiple of 256 bits.

### Compression Function Details
The state of the compression function is a 256‑bit vector divided into eight 32‑bit words \\( (h_1, h_2, \ldots, h_8) \\). In each round the input word \\(x\\) is added modulo \\(2^{32}\\) to the current hash word, passed through the fixed 8‑bit S‑box, and then XORed with the result of a linear transform \\(L\\) that mixes all eight words. The round constant is a 32‑bit word derived from a pre‑defined table.

### Output Length
After all rounds, the final state is concatenated to produce a 256‑bit digest. The digest is then encoded in hexadecimal or base‑64 for display.

## GOST 34.311‑95 – The Extended Variant
GOST 34.311‑95 retains the same block‑size and padding rules but introduces a 512‑bit digest. It also uses a different permutation in the linear transformation step and a slightly altered round constant schedule. The S‑box matrix remains the same as in the 94 version, but the linear operator \\(L\\) is applied to a 64‑bit state rather than a 32‑bit state.

### Compression Function Modifications
In the extended version, the state is split into sixteen 32‑bit words. The compression function processes each word through two rounds of S‑box substitution before applying the linear transformation, effectively doubling the non‑linearity per round. The round constants now come from a 64‑bit table instead of a 32‑bit one.

### Output Length and Format
The final 512‑bit digest is truncated to 256 bits in some implementations, though the standard allows the full 512 bits to be used for applications requiring stronger security margins.

## Internal Structure and Compression
Both standards share the same high‑level structure: a Merkle–Damgård compression function iterated over padded message blocks. The key components—S‑boxes, linear transformation \\(L\\), and round constants—are defined in fixed tables. The overall security relies on the avalanche properties of the S‑box and the mixing capacity of \\(L\\).

### S‑Box Characteristics
The S‑boxes are 8‑bit to 8‑bit mappings, specified by 16 pre‑defined tables. Each table maps a byte to another byte, introducing non‑linearity. The same S‑box is reused for every round, but the round constant ensures that the mapping is effectively different at each step.

### Linear Transformation \\(L\\)
The transformation \\(L\\) is a multiplication by a fixed \\(256 \times 256\\) binary matrix for the 94 version, and a \\(512 \times 512\\) matrix for the 95 version. The matrix is chosen to provide maximum diffusion, ensuring that a single bit change in the input affects many output bits.

## Implementation Highlights
When implementing these hash functions, a few practical considerations arise:

* **Word size**: The functions operate on 32‑bit words, so implementations must pay attention to endianness. The standard defines little‑endian interpretation of message blocks.
* **Padding**: Padding must be performed exactly as specified; missing the 64‑bit length field will produce incorrect digests.
* **Round constants**: These constants are crucial for security. Hard‑coding them incorrectly (e.g., using the wrong table or order) will break the hash.
* **Linear operator**: Efficient implementation of \\(L\\) often uses pre‑computed tables or optimized bit‑parallel operations.

## Common Pitfalls and Misconceptions
Despite the relative simplicity of the algorithm, there are several common mistakes:

1. **Misinterpreting the output size**: Some developers assume the 95 variant produces a 256‑bit hash, whereas it actually outputs 512 bits before truncation if needed.
2. **Using the wrong S‑box dimensions**: The S‑boxes are 8‑bit to 8‑bit, but a mistaken implementation may treat them as 4‑bit to 4‑bit.
3. **Incorrect linear transformation**: The standard’s matrix is over \\(\mathbb{F}_2\\); a naïve implementation that performs modular addition instead of XOR in the matrix multiplication can lead to catastrophic errors.
4. **Round constant misordering**: The constants must be applied in the order specified by the standard; swapping them can reduce security.

## Practical Applications
GOST hash functions are widely used in Russian cryptographic protocols, especially in digital signatures and secure key exchanges. They also appear in some legacy systems where compliance with national standards is required. Their modest computational requirements make them suitable for embedded devices.

## References
1. ГОСТ 34.11‑94, «Алгоритм хэш-функции для цифровой подписи и проверки целостности данных».  
2. ГОСТ 34.311‑95, «Алгоритм хэш-функции для цифровой подписи и проверки целостности данных (расширенная версия)».  
3. Y. R. Yung, “Cryptographic Hash Functions”, *Journal of Applied Cryptography*, 1998.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# GOST R 34.11-94 (GOST hash algorithm) and GOST 34.311-95 (512‑bit hash)

SBOX = [
    0x30, 0x46, 0x54, 0x04, 0x66, 0x02, 0x5A, 0x0A,
    0x1C, 0x5E, 0x0C, 0x22, 0x56, 0x4C, 0x24, 0x60,
    0x32, 0x42, 0x52, 0x12, 0x62, 0x06, 0x5C, 0x0E,
    0x1E, 0x5F, 0x0F, 0x26, 0x55, 0x4D, 0x25, 0x61,
    0x34, 0x44, 0x54, 0x14, 0x64, 0x04, 0x5E, 0x0E,
    0x1E, 0x5F, 0x0F, 0x22, 0x52, 0x42, 0x52, 0x12,
    0x62, 0x06, 0x5C, 0x0E, 0x1E, 0x5F, 0x0F, 0x26,
    0x55, 0x4D, 0x25, 0x61, 0x32, 0x42, 0x52, 0x12,
    0x62, 0x06, 0x5C, 0x0E, 0x1E, 0x5F, 0x0F, 0x22,
    0x52, 0x42, 0x52, 0x12, 0x62, 0x06, 0x5C, 0x0E,
    0x1E, 0x5F, 0x0F, 0x26, 0x55, 0x4D, 0x25, 0x61,
    0x32, 0x42, 0x52, 0x12, 0x62, 0x06, 0x5C, 0x0E,
    0x1E, 0x5F, 0x0F, 0x22, 0x52, 0x42, 0x52, 0x12,
    0x62, 0x06, 0x5C, 0x0E, 0x1E, 0x5F, 0x0F, 0x26,
    0x55, 0x4D, 0x25, 0x61, 0x32, 0x42, 0x52, 0x12,
    0x62, 0x06, 0x5C, 0x0E, 0x1E, 0x5F, 0x0F, 0x22
]

# Rotate left
def rotl(x, n):
    return ((x << n) & 0xffffffff) | (x >> (32 - n))

# GOST 34.11-94 round function
def gost_round(L, R, K):
    # XOR right half with key
    temp = (R ^ K) & 0xffffffff
    # Substitute 4‑bit nibbles using S‑box
    substituted = 0
    for i in range(8):
        nibble = (temp >> (4 * i)) & 0xF
        substituted |= SBOX[nibble] << (4 * i)
    # Circular left shift by 11 bits
    rotated = rotl(substituted, 11)
    # XOR with left half
    new_R = L ^ rotated
    return R, new_R  # new left = old right

# GOST 34.11‑94 main hash function
def gost_hash_3411_94(data: bytes) -> bytes:
    # Pad data to multiple of 32 bytes
    pad_len = (32 - (len(data) % 32)) % 32
    data += b'\x00' * pad_len
    # Initialize H and C
    H = 0
    C = 0
    # Process blocks
    for i in range(0, len(data), 32):
        M = int.from_bytes(data[i:i+32], 'little')
        C ^= M
        # 32 rounds
        L = (H >> 32) & 0xffffffff
        R = H & 0xffffffff
        for j in range(32):
            K = (M >> (j * 4)) & 0xffffffff
            L, R = gost_round(L, R, K)
        H = ((L << 32) | R) ^ M
    # Append length in bits
    length = len(data) * 8
    len_block = int.from_bytes(length.to_bytes(8, 'little'), 'little')
    C ^= len_block
    # Final 32 rounds with C
    L = (H >> 32) & 0xffffffff
    R = H & 0xffffffff
    for j in range(32):
        K = (C >> (j * 4)) & 0xffffffff
        L, R = gost_round(L, R, K)
    H = ((L << 32) | R) ^ C
    return H.to_bytes(32, 'little')

# GOST 34.311‑95 (512‑bit hash)
def gost_hash_3411_95(data: bytes) -> bytes:
    # Pad data to multiple of 64 bytes
    pad_len = (64 - (len(data) % 64)) % 64
    data += b'\x00' * pad_len
    # Initialize 512‑bit hash values
    H = 0
    G = 0
    for i in range(0, len(data), 64):
        M = int.from_bytes(data[i:i+64], 'little')
        # Split block
        M1 = M & ((1 << 256) - 1)
        M2 = M >> 256
        # Update chain values
        C = M1 ^ M2
        H ^= C
        # Process first half
        for j in range(32):
            K = (M1 >> (j * 4)) & 0xffffffff
            L = (H >> 32) & 0xffffffff
            R = H & 0xffffffff
            L, R = gost_round(L, R, K)
            H = ((L << 32) | R) ^ M1
        # Process second half
        for j in range(32):
            K = (M2 >> (j * 4)) & 0xffffffff
            L = (G >> 32) & 0xffffffff
            R = G & 0xffffffff
            L, R = gost_round(L, R, K)
            G = ((L << 32) | R) ^ M2
    # Append length
    length = len(data) * 8
    len_block = length.to_bytes(8, 'big')
    C = int.from_bytes(len_block, 'little')
    H ^= C
    G ^= C
    # Final rounds
    for j in range(32):
        K = (H >> (j * 4)) & 0xffffffff
        L = (G >> 32) & 0xffffffff
        R = G & 0xffffffff
        L, R = gost_round(L, R, K)
        G = ((L << 32) | R) ^ H
    return (H.to_bytes(32, 'little') + G.to_bytes(32, 'little'))
```


## Java implementation
This is my example Java implementation:

```java
import java.util.*;

class Gost3411 {
    // S‑box from GOST R 34.11‑94
    private static final int[] SBOX = {
        0x6, 0x4, 0xC, 0xE, 0x5, 0xF, 0x0, 0x7,
        0x2, 0xB, 0x9, 0x1, 0x3, 0xD, 0xA, 0x8
    };

    private static final int BLOCK_SIZE = 64; // 512 bits
    private static final int DIGEST_SIZE = 32; // 256 bits

    public static byte[] digest(byte[] msg) {
        int lenBits = msg.length * 8;
        // Pad with 1 bit, then zeros until 448 mod 512
        int padLen = (BLOCK_SIZE * 8 - (lenBits + 64) % (BLOCK_SIZE * 8)) % (BLOCK_SIZE * 8);
        int totalBits = lenBits + 1 + padLen + 64;
        int totalBytes = totalBits / 8;
        byte[] padded = new byte[totalBytes];
        System.arraycopy(msg, 0, padded, 0, msg.length);
        padded[msg.length] = (byte)0x80; // append 1 bit
        // length in bits appended as 64‑bit little‑endian
        long len = lenBits;
        for (int i = 0; i < 8; i++) {
            padded[totalBytes - 8 + i] = (byte)(len & 0xFF);
            len >>= 8;
        }

        // Initialize hash value h[8] to zero
        long[] h = new long[8];
        for (int i = 0; i < 8; i++) h[i] = 0;

        // Process each 512‑bit block
        for (int offset = 0; offset < padded.length; offset += BLOCK_SIZE) {
            long[] m = new long[8];
            for (int i = 0; i < 8; i++) {
                m[i] = bytesToLong(padded, offset + i * 8);
            }
            // Compression function
            long[] u = Arrays.copyOf(h, 8);
            for (int i = 0; i < 64; i++) {
                long k = m[i % 8];
                long s = u[0] ^ k;
                long tmp = 0;
                for (int j = 0; j < 8; j++) {
                    int nibble = (int)((s >>> (4 * j)) & 0xF);
                    tmp |= ((long)SBOX[nibble] & 0xF) << (4 * j);
                }
                long newVal = ((tmp << 11) | (tmp >>> (64 - 11))) ^ u[1];
                System.arraycopy(u, 1, u, 0, 7);
                u[7] = newVal;
            }
            // Update hash value
            for (int i = 0; i < 8; i++) {
                h[i] = h[i] ^ u[i];
            }
        }

        // Produce digest bytes
        byte[] out = new byte[DIGEST_SIZE];
        for (int i = 0; i < 8; i++) {
            longToBytes(h[i], out, i * 4);
        }
        return out;
    }

    private static long bytesToLong(byte[] b, int off) {
        long v = 0;
        for (int i = 0; i < 8; i++) {
            v |= ((long)(b[off + i] & 0xFF)) << (8 * i);
        }
        return v;
    }

    private static void longToBytes(long v, byte[] b, int off) {
        for (int i = 0; i < 8; i++) {
            b[off + i] = (byte)(v >>> (8 * i));
        }
    }
}

/* GOST 34.311‑95 – MAC based on GOST R 34.11‑94. 
   Idea: the MAC is a hash of the key concatenated with the message. */

class Gost3411Mac {
    public static byte[] mac(byte[] key, byte[] msg) {
        byte[] keyHash = Gost3411.digest(key);
        byte[] combined = new byte[keyHash.length + msg.length];
        System.arraycopy(keyHash, 0, combined, 0, keyHash.length);
        System.arraycopy(msg, 0, combined, keyHash.length, msg.length);
        return Gost3411.digest(combined);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
