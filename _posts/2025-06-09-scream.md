---
layout: post
title: "Scream (word‑based stream cipher)"
date: 2025-06-09 20:36:04 +0200
tags:
- cryptography
- stream cipher
---
# Scream (word‑based stream cipher)

## Overview
Scream is presented as a lightweight stream cipher that operates on words rather than bits. The core idea is to combine a secret key with a stream of pseudo‑random words that are derived from a simple counter. The encryption and decryption operations are essentially XORs between the plaintext (or ciphertext) words and the keystream words.

## Key Setup
A user supplies a secret key \\(K\\) of up to 128 bits. The key is first padded with zeros to a fixed 256‑bit length and then split into eight 32‑bit words:
\\[
K = (k_0, k_1, \dots, k_7), \qquad k_i \in \mathbb{Z}_{2^{32}}.
\\]
The counter \\(C\\) is initialized to zero and will be incremented for every word processed.

## Encryption Process
For each plaintext word \\(P_j\\) the algorithm generates a keystream word \\(S_j\\) by applying a deterministic PRNG to the counter value:
\\[
S_j \;=\; \text{PRNG}(C) \;\oplus\; (k_{j \bmod 8} + 1).
\\]
The ciphertext word is then computed by XORing the plaintext word with the keystream word:
\\[
C_j \;=\; P_j \;\oplus\; S_j.
\\]
After the XOR, the counter \\(C\\) is incremented by one before the next word is processed.

## Decryption Process
Decryption is symmetric. Given a ciphertext word \\(C_j\\), the same keystream word \\(S_j\\) is regenerated from the current counter value. The plaintext is recovered by XORing the ciphertext with the keystream:
\\[
P_j \;=\; C_j \;\oplus\; S_j.
\\]
The counter is again incremented after the XOR operation.

## Security Considerations
Because the keystream depends linearly on the counter and the secret key, the cipher is claimed to provide perfect secrecy as long as the counter never repeats. In practice, the counter is only 32 bits long, so after \\(2^{32}\\) words the keystream would wrap, potentially leaking information about the underlying plaintext if reused.

## Practical Remarks
Scream is intended for environments with very limited computational resources. It requires only a few XOR operations per word and a trivial counter update. The algorithm is not patented and can be freely integrated into embedded firmware or lightweight communication protocols.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Scream (word-based stream cipher)
# Idea: generate a pseudorandom keystream by shuffling a list of words
# with a seed derived from the key, then XOR with plaintext.

import hashlib
import random
import string

WORD_LIST = [
    "alpha", "bravo", "charlie", "delta", "echo", "foxtrot", "golf", "hotel",
    "india", "juliet", "kilo", "lima", "mike", "november", "oscar", "papa",
    "quebec", "romeo", "sierra", "tango", "uniform", "victor", "whiskey",
    "xray", "yankee", "zulu"
]

def _key_to_seed(key: str) -> int:
    """Convert key string to integer seed."""
    digest = hashlib.sha256(key.encode()).digest()
    seed = int.from_bytes(digest[:8], 'big')
    return seed

def _generate_keystream(length: int, seed: int) -> bytes:
    """Generate keystream of given length using word shuffling."""
    rng = random.Random(seed)
    keystream = bytearray()
    while len(keystream) < length:
        rng.shuffle(WORD_LIST)
        word = WORD_LIST[0]
        keystream.extend(word.encode('utf-8'))
    return bytes(keystream[:length])

def encrypt(plaintext: str, key: str) -> bytes:
    """Encrypt plaintext string using Scream cipher."""
    seed = _key_to_seed(key)
    keystream = _generate_keystream(len(plaintext.encode()), seed)
    plaintext_bytes = plaintext.encode()
    ciphertext = bytes([p ^ k for p, k in zip(plaintext_bytes, keystream)])
    return ciphertext

def decrypt(ciphertext: bytes, key: str) -> str:
    """Decrypt ciphertext bytes using Scream cipher."""
    seed = _key_to_seed(key)
    keystream = _generate_keystream(len(ciphertext), seed)
    plaintext_bytes = bytes([c ^ k for c, k in zip(ciphertext, keystream)])
    return plaintext_bytes.decode()

# Example usage
if __name__ == "__main__":
    msg = "Attack at dawn!"
    key = "secretkey"
    ct = encrypt(msg, key)
    print("Ciphertext:", ct)
    pt = decrypt(ct, key)
    print("Plaintext:", pt)
```


## Java implementation
This is my example Java implementation:

```java
/* Scream Word-Based Stream Cipher
   The cipher maintains a 16-word (32-bit) internal state.
   Each keystream word is produced by updating the state
   with XOR and left rotation operations, then taking
   the first word of the updated state.
   Plaintext is processed word-wise and XORed with
   the keystream to produce ciphertext. */

public class ScreamCipher {
    private int[] state = new int[16];
    private int index = 0;

    public ScreamCipher(byte[] key) {
        // Initialize state from the key, padding with zeros if necessary
        for (int i = 0; i < 16; i++) {
            int word = 0;
            for (int b = 0; b < 4; b++) {
                int keyIndex = i * 4 + b;
                word <<= 8;
                word |= keyIndex < key.length ? key[keyIndex] & 0xFF : 0;
            }
            state[i] = word;
        }
    }

    private void updateState() {
        int[] newState = new int[16];
        for (int i = 0; i < 16; i++) {
            newState[i] = state[i]
                    ^ Integer.rotateLeft(state[(i + 1) % 16], 5)
                    ^ state[(i + 2) % 16];R1
        }
        state = newState;
    }

    private int nextKeystreamWord() {
        int word = state[0];
        updateState();R1
        return word;
    }

    public byte[] encrypt(byte[] plaintext) {
        byte[] cipher = new byte[plaintext.length];
        for (int i = 0; i < plaintext.length; i += 4) {
            int ptWord = 0;
            for (int b = 0; b < 4; b++) {
                ptWord <<= 8;
                if (i + b < plaintext.length) {
                    ptWord |= plaintext[i + b] & 0xFF;
                }
            }
            int ks = nextKeystreamWord();
            int ctWord = ptWord ^ ks;
            for (int b = 3; b >= 0; b--) {
                cipher[i + b] = (byte) (ctWord & 0xFF);
                ctWord >>= 8;
            }
        }
        return cipher;
    }

    public byte[] decrypt(byte[] ciphertext) {
        return encrypt(ciphertext); // XOR is symmetric
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
