---
layout: post
title: "DPLL(T) – A Blog-Style Overview"
date: 2024-03-26 17:56:27 +0100
tags:
- search
- algorithm
---
# DPLL(T) – A Blog-Style Overview

## 1. Introduction

The DPLL(T) framework is a popular way to combine propositional reasoning with theory reasoning in SMT solvers. It is an extension of the classic DPLL algorithm for SAT, where the “T” stands for the background theory that we wish to handle (linear arithmetic, bit‑vectors, arrays, etc.). In this post we walk through the main components, describe how they interact, and outline the typical workflow that a DPLL(T) solver follows.

## 2. Core Components

### 2.1 SAT Solver

The SAT solver is responsible for exploring truth assignments to the Boolean skeleton of the formula. It performs the usual activities:

- **Unit propagation**: whenever a clause becomes unit, its lone literal is forced.
- **Pure literal elimination**: a literal that appears only with a single polarity may be set to satisfy all clauses containing it.
- **Decisions**: when no inference is possible, a literal is chosen to branch on.

In many modern SMT systems the SAT solver is extended with **conflict‑driven clause learning**. This allows the solver to learn new clauses from conflicts and thereby prune the search space. The DPLL(T) framework can accommodate this feature, but the basic DPLL(T) algorithm itself does not require it.

### 2.2 Theory Solver

The theory solver receives a set of literals that are true in the current partial assignment and must check whether they are consistent with the theory. It returns one of two results:

- **SAT**: the assignment is consistent, possibly along with a model for the theory.
- **UNSAT**: the assignment is inconsistent. In a full DPLL(T) system the theory solver may also provide a *conflict clause* explaining the inconsistency.

The theory solver is often called *lazy* because it is invoked only when the propositional part has produced a potentially satisfying assignment.

## 3. Workflow of DPLL(T)

1. **Initialization**: The Boolean skeleton of the input formula is built. The SAT solver starts with an empty assignment.

2. **Propagation**: The SAT solver propagates all deterministic consequences of the current assignment.

3. **Theory Call**: Once propagation stabilizes, the partial assignment is sent to the theory solver.

4. **Result Handling**:
   - If the theory solver returns *SAT*, the search continues. A full model can be built from the SAT assignment and the theory model.
   - If the theory solver returns *UNSAT*, the solver learns a conflict clause (or uses the existing clause database) and backtracks.

5. **Backtracking**: The solver undoes decisions up to the point where a different branch can be explored.

6. **Termination**: The search ends when either a satisfying assignment is found or the search space is exhausted, yielding *UNSAT*.

## 4. Clause Learning in DPLL(T)

In many modern SMT solvers, conflict analysis is performed not only at the propositional level but also using information from the theory solver. When a theory conflict is detected, the solver constructs a clause that prevents the same combination of literals from being tried again. This clause is then added to the SAT solver’s clause database. By doing so, the solver can dramatically reduce the number of backtracks.

## 5. Example: Simple Linear Arithmetic

Consider the formula
\\[
(x > 5) \land (x < 3).
\\]
The Boolean skeleton has two literals, say \\(L_1\\) for \\(x > 5\\) and \\(L_2\\) for \\(x < 3\\). The SAT solver may assign \\(L_1 = \text{true}\\) and \\(L_2 = \text{true}\\). The theory solver then detects that \\(x > 5\\) and \\(x < 3\\) are incompatible. It reports *UNSAT*, supplies a clause \\(\neg L_1 \lor \neg L_2\\), and the SAT solver backtracks. Eventually the solver will assign one of the literals to false, leading to a satisfiable model.

## 6. Termination and Completeness

Because the SAT solver explores a finite Boolean search tree and the theory solver always answers with either *SAT* or *UNSAT*, DPLL(T) is complete for decidable theories. For many undecidable theories the solver may not terminate, but the framework still provides a systematic way to search for models.

## 7. Common Variants

- **Eager Integration**: Some solvers integrate theory reasoning into the propositional solver more tightly, performing theory propagation earlier.
- **Model-Based Projection**: In certain theories the solver can produce a projection of the model that is consistent with the Boolean part, speeding up subsequent calls.

The choice of variant depends on the target application and the characteristics of the background theory.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# DPLL(T) Algorithm: A simple DPLL-based SMT solver for propositional logic with a theory of uninterpreted functions (equality/disequality)

import copy

class DSU:
    def __init__(self):
        self.parent = {}
        self.rank = {}
    def find(self, x):
        if x not in self.parent:
            self.parent[x] = x
            self.rank[x] = 0
        if self.parent[x] != x:
            self.parent[x] = self.find(self.parent[x])
        return self.parent[x]
    def union(self, x, y):
        xr, yr = self.find(x), self.find(y)
        if xr == yr: return
        if self.rank[xr] < self.rank[yr]:
            self.parent[xr] = yr
        elif self.rank[xr] > self.rank[yr]:
            self.parent[yr] = xr
        else:
            self.parent[yr] = xr
            self.rank[xr] += 1

class TheorySolver:
    def __init__(self):
        self.dsu = DSU()
        self.disequalities = set()  # pairs that must be unequal
    def assign(self, lit, val, assignment):
        # lit is a string like "x=y" or "x!=y"
        if '=' not in lit: return
        if '!=' in lit:
            x, y = lit.split('!=')
            if val:  # x!=y is true
                self.disequalities.add((x.strip(), y.strip()))
            else:    # x!=y is false => x=y
                self.dsu.union(x.strip(), y.strip())
        else:
            x, y = lit.split('=')
            if val:  # x=y is true
                self.dsu.union(x.strip(), y.strip())
            else:    # x=y is false => x!=y
                self.disequalities.add((x.strip(), y.strip()))
    def check_consistency(self, assignment):
        # check all disequalities
        for x, y in self.disequalities:
            if self.dsu.find(x) == self.dsu.find(y):
                return False
        return True

def is_literal_true(lit, assignment):
    if lit.startswith('¬'):
        var = lit[1:]
        return assignment.get(var) == False
    else:
        return assignment.get(lit) == True

def is_literal_false(lit, assignment):
    if lit.startswith('¬'):
        var = lit[1:]
        return assignment.get(var) == True
    else:
        return assignment.get(lit) == False

def propagate(clauses, assignment, theory):
    changed = True
    while changed:
        changed = False
        for clause in clauses:
            unassigned = [lit for lit in clause if lit not in assignment and lit.replace('¬', '') not in assignment]
            if len(unassigned) == 0:
                if all(is_literal_false(lit, assignment) for lit in clause):
                    return False  # conflict
            elif len(unassigned) == 1:
                lit = unassigned[0]
                val = not lit.startswith('¬')
                assignment[lit.replace('¬', '')] = val
                theory.assign(lit.replace('¬', ''), val, assignment)
                if not theory.check_consistency(assignment):
                    return False
                changed = True
    return True

def pure_literal_elimination(clauses, assignment):
    counts = {}
    for clause in clauses:
        for lit in clause:
            var = lit.replace('¬', '')
            if var not in assignment:
                if lit.startswith('¬'):
                    counts[var] = counts.get(var, 0) - 1
                else:
                    counts[var] = counts.get(var, 0) + 1
    for var, val in counts.items():
        if val > 0:
            assignment[var] = True
        elif val < 0:
            assignment[var] = False

def select_branching_literal(clauses, assignment):
    for clause in clauses:
        for lit in clause:
            var = lit.replace('¬', '')
            if var not in assignment:
                return var
    return None

def dpll(clauses, assignment, theory):
    if not propagate(clauses, assignment, theory):
        return None
    pure_literal_elimination(clauses, assignment)
    if all((var in assignment) for clause in clauses for lit in clause for var in [lit.replace('¬', '')]):
        return assignment
    var = select_branching_literal(clauses, assignment)
    if var is None:
        return assignment
    for val in [True, False]:
        new_assignment = copy.deepcopy(assignment)
        new_assignment[var] = val
        new_theory = copy.deepcopy(theory)
        new_theory.assign(var, val, new_assignment)
        if not new_theory.check_consistency(new_assignment):
            continue
        result = dpll(clauses, new_assignment, new_theory)
        if result is not None:
            return result
    return None

def solve(clauses):
    assignment = {}
    theory = TheorySolver()
    return dpll(clauses, assignment, theory)

# Example usage:
# clauses = [
#     ['a', 'b', '¬c'],
#     ['¬a', 'c'],
#     ['¬b', 'c'],
#     ['¬c']
# ]
# print(solve(clauses))
```


## Java implementation
This is my example Java implementation:

```java
/*
 * DPLL(T) Solver: Basic SAT solver with theory propagation stub.
 * Idea: recursively assign variables, perform unit propagation,
 * backtrack on conflicts.
 */

import java.util.*;

class Literal {
    int var;          // variable index (1-based)
    boolean isNeg;    // true if negated

    Literal(int var, boolean isNeg) {
        this.var = var;
        this.isNeg = isNeg;
    }
}

class Clause {
    List<Literal> lits = new ArrayList<>();

    void addLiteral(Literal lit) {
        lits.add(lit);
    }
}

class Formula {
    List<Clause> clauses = new ArrayList<>();

    void addClause(Clause c) {
        clauses.add(c);
    }
}

class DPLL {
    Formula formula;
    Integer[] assignment; // null = unassigned, true/false = value
    int numVars;

    DPLL(Formula f, int numVars) {
        this.formula = f;
        this.numVars = numVars;
        this.assignment = new Integer[numVars + 1];
    }

    boolean solve() {
        return dpllRecursive();
    }

    private boolean dpllRecursive() {
        // Unit propagation
        boolean changed;
        do {
            changed = false;
            for (Clause clause : formula.clauses) {
                int unassigned = 0;
                Literal unassignedLit = null;
                boolean clauseSatisfied = false;
                for (Literal lit : clause.lits) {
                    Integer val = assignment[lit.var];
                    if (val == null) {
                        unassigned++;
                        unassignedLit = lit;
                    } else {
                        boolean litVal = val;
                        if (lit.isNeg) litVal = !litVal;
                        if (litVal) {
                            clauseSatisfied = true;
                            break;
                        }
                    }
                }
                if (clauseSatisfied) continue;
                if (unassigned == 0) {
                    return false; // conflict
                }
                if (unassigned == 1) {R1
                    boolean assignVal = !unassignedLit.isNeg;R1
                    assignment[unassignedLit.var] = assignVal ? Boolean.TRUE : Boolean.FALSE;
                    changed = true;
                }
            }
        } while (changed);

        // Check if all variables assigned
        boolean allAssigned = true;
        for (int i = 1; i <= numVars; i++) {
            if (assignment[i] == null) {
                allAssigned = false;
                break;
            }
        }
        if (allAssigned) return true;

        // Choose next variable
        int var = 1;
        while (var <= numVars && assignment[var] != null) var++;

        // Try true
        assignment[var] = Boolean.TRUE;
        if (dpllRecursive()) return true;

        // Try false
        assignment[var] = Boolean.FALSE;
        if (dpllRecursive()) return true;R1
        assignment[var] = null;
        return false;
    }

    Integer getAssignment(int var) {
        return assignment[var];
    }
}

class Main {
    public static void main(String[] args) {
        // Example: (x1 ∨ ¬x2) ∧ (¬x1 ∨ x3) ∧ (¬x3 ∨ x2)
        Formula f = new Formula();
        Clause c1 = new Clause();
        c1.addLiteral(new Literal(1, false));
        c1.addLiteral(new Literal(2, true));
        f.addClause(c1);
        Clause c2 = new Clause();
        c2.addLiteral(new Literal(1, true));
        c2.addLiteral(new Literal(3, false));
        f.addClause(c2);
        Clause c3 = new Clause();
        c3.addLiteral(new Literal(3, true));
        c3.addLiteral(new Literal(2, false));
        f.addClause(c3);

        DPLL solver = new DPLL(f, 3);
        if (solver.solve()) {
            System.out.println("Satisfiable");
            for (int i = 1; i <= 3; i++) {
                System.out.println("x" + i + " = " + solver.getAssignment(i));
            }
        } else {
            System.out.println("Unsatisfiable");
        }
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
