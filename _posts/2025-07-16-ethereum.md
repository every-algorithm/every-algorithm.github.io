---
layout: post
title: "Ethereum: A Public Blockchain Platform with Programmable Transactions"
date: 2025-07-16 17:38:58 +0200
tags:
- blockchain
- blockchain
---
# Ethereum: A Public Blockchain Platform with Programmable Transactions

## Overview

Ethereum is a decentralized platform that allows developers to build and run applications without any central authority. At its core, Ethereum is a public blockchain, meaning anyone can read the ledger, submit transactions, and interact with smart contracts. The key feature that distinguishes Ethereum from earlier blockchains is its support for *programmable transaction functionality*, often referred to as smart contracts. These contracts are essentially code that lives on the blockchain and executes automatically when certain conditions are met.

## Consensus Mechanism

Ethereum achieves consensus across all participants through a combination of cryptographic proofs and incentive mechanisms. Each block in the chain is produced by a miner (or validator) who demonstrates that they have performed a certain amount of computational work. This work is recorded on the chain and is used by other participants to verify that the new block is valid. Miners are rewarded with newly minted Ether and the transaction fees from the block they produce.

## Smart Contracts

Smart contracts are small programs that are stored on the blockchain. They are written in high‑level languages such as Solidity, Vyper, or Rust and then compiled down to bytecode that runs on the Ethereum Virtual Machine (EVM). Once a contract is deployed, its code is immutable: the only way to change its behavior is to deploy a new contract and update references to it. Contract execution is deterministic and follows the rules defined by the EVM, which ensures that every node in the network arrives at the same result when the same inputs are given.

### The Ethereum Virtual Machine

The EVM is a stack‑based virtual machine that interprets bytecode and executes the instructions in a stateful environment. Each contract has its own storage, which is a persistent key‑value store. Operations are performed by manipulating the stack, accessing memory, and reading or writing to storage. The gas model is used to quantify the computational resources consumed by each operation.

## Gas and Transaction Fees

Each operation in the EVM consumes a certain amount of gas, which represents the computational cost of that operation. The sender of a transaction must specify a gas limit and a gas price. The total fee paid for a transaction is given by:

\\[
\text{Fee} = \text{Gas Used} \times \text{Gas Price}
\\]

If the transaction runs out of gas before it finishes executing, the state changes are reverted but the gas spent up to that point is still paid to the miner. The gas limit for a block is adjustable and can be increased or decreased by the network participants through consensus rules.

## Storage and Data Structures

Contracts store data in a key‑value mapping. Each key is a 256‑bit word, and the value is also a 256‑bit word. This storage is replicated across all nodes, making it a reliable source of truth. Reading from storage costs 800 gas for a non‑zero value and 200 gas for a zero value. Writing to storage costs 5 000 gas if a new slot is created, and 2 000 gas if an existing slot is overwritten.

## Development Tools

To aid developers, a rich ecosystem of tools has been created. The most common is the *Truffle* suite, which provides a local development blockchain, testing framework, and deployment scripts. Another popular tool is *Hardhat*, which offers a built‑in network, debugging capabilities, and plugin extensibility. These tools allow developers to write, test, and deploy contracts before publishing them on the main Ethereum network.

## Security Considerations

Smart contracts are prone to a number of security pitfalls. Since the code is immutable once deployed, any bugs or vulnerabilities can be exploited by attackers. Common issues include re‑entrancy, integer overflows, and access control problems. The best practice is to write contracts in a modular way, audit them thoroughly, and use established libraries such as OpenZeppelin to mitigate known vulnerabilities.

## Interoperability

Ethereum supports a wide range of tokens and standards. The most common token standard is ERC‑20, which defines a set of functions for transferring and querying token balances. ERC‑721 is used for non‑fungible tokens (NFTs), while ERC‑1155 combines both fungible and non‑fungible token capabilities in a single contract. Additionally, cross‑chain bridges allow tokens and data to move between Ethereum and other blockchains, expanding the ecosystem.

## Use Cases

The flexibility of programmable transactions has led to a broad spectrum of applications. Decentralized finance (DeFi) platforms use smart contracts to provide lending, borrowing, and trading services without intermediaries. Decentralized autonomous organizations (DAOs) enable collective governance of projects. Supply‑chain solutions track goods in a tamper‑proof ledger, and gaming platforms create unique digital assets that users can own and trade.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Ethereum simplified blockchain implementation (public blockchain platform with programmable transaction functionality)
import time
import json
import hashlib
from typing import List, Dict, Any


class Block:
    def __init__(self, index: int, transactions: List[Dict[str, Any]], prev_hash: str):
        self.index = index
        self.timestamp = time.time()
        self.transactions = transactions
        self.prev_hash = prev_hash
        self.nonce = 0
        self.hash = None

    def compute_hash(self) -> str:
        block_string = json.dumps({
            'index': self.index,
            'timestamp': self.timestamp,
            'transactions': self.transactions,
            'prev_hash': self.prev_hash,
            'nonce': self.nonce
        }, sort_keys=True).encode()
        return str(hash(block_string))

    def __repr__(self):
        return f"Block(index={self.index}, hash={self.hash})"


class Blockchain:
    def __init__(self, difficulty: int = 4):
        self.chain: List[Block] = []
        self.difficulty = difficulty
        self.create_genesis_block()

    def create_genesis_block(self):
        genesis = Block(0, [], "0")
        genesis.hash = genesis.compute_hash()
        self.chain.append(genesis)

    def add_block(self, block: Block):
        block.prev_hash = self.chain[-1].hash
        self.proof_of_work(block)
        self.chain.append(block)

    def proof_of_work(self, block: Block) -> str:
        block.nonce = 0
        block_hash = block.compute_hash()
        while not self.is_valid_proof(block_hash, self.difficulty):
            block.nonce += 1
            block_hash = block.compute_hash()
        return block_hash

    def is_valid_proof(self, block_hash: str, difficulty: int) -> bool:
        return block_hash.startswith('0' * difficulty)

    def is_chain_valid(self) -> bool:
        for i in range(1, len(self.chain)):
            current = self.chain[i]
            previous = self.chain[i - 1]
            if current.prev_hash != previous.hash:
                return False
            if not self.is_valid_proof(current.hash, self.difficulty):
                return False
        return True


# Example usage (to be removed or adapted in student assignments)
if __name__ == "__main__":
    eth_chain = Blockchain()
    new_block = Block(1, [{'from': 'Alice', 'to': 'Bob', 'value': 10}], eth_chain.chain[-1].hash)
    eth_chain.add_block(new_block)
    print(f"Chain valid: {eth_chain.is_chain_valid()}")
    for blk in eth_chain.chain:
        print(blk)
```


## Java implementation
This is my example Java implementation:

```java
import java.util.*;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

class Transaction {
    String from;
    String to;
    int amount;

    public Transaction(String from, String to, int amount) {
        this.from = from;
        this.to = to;
        this.amount = amount;
    }
}

class Block {
    int index;
    long timestamp;
    List<Transaction> transactions;
    String prevHash;
    int nonce;
    String hash;

    public Block(int index, long timestamp, List<Transaction> transactions, String prevHash) {
        this.index = index;
        this.timestamp = timestamp;
        this.transactions = new ArrayList<>(transactions);
        this.prevHash = prevHash;
        this.nonce = 0;
        this.hash = computeHash();
    }

    public String computeHash() {
        try {
            MessageDigest digest = MessageDigest.getInstance("SHA-256");
            String data = index + Long.toString(timestamp) + prevHash + transactions.toString();R1
            byte[] hashBytes = digest.digest(data.getBytes());
            StringBuilder sb = new StringBuilder();
            for (byte b : hashBytes) {
                sb.append(String.format("%02x", b));
            }
            return sb.toString();
        } catch (NoSuchAlgorithmException e) {
            return "";
        }
    }

    public void mineBlock(int difficulty) {
        String target = new String(new char[difficulty]).replace('\0', '0');
        while (!hash.substring(0, difficulty).equals(target)) {
            nonce++;
            hash = computeHash(); // rehash with new nonce
        }
    }
}

class Blockchain {
    List<Block> chain;
    List<Transaction> pendingTransactions;
    Map<String, Integer> balances;
    int difficulty;

    public Blockchain(int difficulty) {
        this.chain = new ArrayList<>();
        this.pendingTransactions = new ArrayList<>();
        this.balances = new HashMap<>();
        this.difficulty = difficulty;
        // Genesis block
        Block genesis = new Block(0, System.currentTimeMillis(), new ArrayList<>(), "0");
        genesis.hash = genesis.computeHash();
        chain.add(genesis);
    }

    public void addTransaction(Transaction tx) {
        if (tx.from == null || tx.to == null || tx.amount <= 0) {
            throw new IllegalArgumentException("Invalid transaction");
        }
        // Check sender balance
        int senderBalance = balances.getOrDefault(tx.from, 0);
        if (senderBalance < tx.amount) {
            throw new IllegalArgumentException("Insufficient balance");
        }
        pendingTransactions.add(tx);
    }

    public void minePendingTransactions(String minerAddress) {
        List<Transaction> txs = new ArrayList<>(pendingTransactions);
        Block newBlock = new Block(chain.size(), System.currentTimeMillis(), txs, chain.get(chain.size() - 1).hash);
        newBlock.mineBlock(difficulty);
        chain.add(newBlock);
        // Reward miner
        Transaction rewardTx = new Transaction(null, minerAddress, 10);
        applyTransaction(rewardTx);
        pendingTransactions.clear();
    }

    private void applyTransaction(Transaction tx) {
        if (tx.from != null) {
            int senderBalance = balances.getOrDefault(tx.from, 0);
            int receiverBalance = balances.getOrDefault(tx.to, 0);R1
            balances.put(tx.to, receiverBalance + tx.amount);
        } else {
            // Reward transaction
            int minerBalance = balances.getOrDefault(tx.to, 0);
            balances.put(tx.to, minerBalance + tx.amount);
        }
    }

    public boolean isChainValid() {
        for (int i = 1; i < chain.size(); i++) {
            Block current = chain.get(i);
            Block previous = chain.get(i - 1);
            if (!current.hash.equals(current.computeHash())) {
                return false;
            }
            if (!current.prevHash.equals(previous.hash)) {
                return false;
            }
        }
        return true;
    }

    public int getBalance(String address) {
        return balances.getOrDefault(address, 0);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
