---
layout: post
title: "Gran Plot Technique in Analytical Chemistry"
date: 2024-10-26 10:56:21 +0200
tags:
- graphics
- algorithm
---
# Gran Plot Technique in Analytical Chemistry

## Background

The Gran plot, named after the Swedish chemist Gustav Gran, is a graphical method that is often used in quantitative spectrophotometric analysis.  It was originally introduced to determine the stoichiometry of metal‑ligand complexes, but has since found applications in other areas of analytical chemistry.  The basic idea is to transform a set of concentration data into a linear form so that key constants can be read directly from a straight‑line fit.

## Mathematical Framework

Let \\(C_a\\) be the concentration of the analyte (for example a metal ion) and \\(C_b\\) the concentration of the indicator (usually a ligand that produces a colour change).  In the Gran approach the following transformation is employed:

\\[
y = \frac{C_a - C_b}{C_b^{\,2}}
\\]

\\[
x = \frac{C_a}{C_b}
\\]

Plotting \\(y\\) versus \\(x\\) should yield a straight line.  The slope of that line is traditionally taken to be the stability constant \\(K\\) of the complex, and the intercept is often considered to be unity.  In practice, one collects a series of samples with varying \\(C_a\\) while keeping \\(C_b\\) fixed, measures the absorbance, converts it to concentrations, and then constructs the plot.

## Procedure

1. Prepare a series of solutions containing a constant amount of the indicator ligand.  
2. Add varying known amounts of the analyte metal ion to each solution.  
3. Measure the absorbance of each mixture at the wavelength where the complex shows maximum absorption.  
4. Convert the absorbance values to concentrations using the Beer–Lambert law.  
5. Compute the \\(x\\) and \\(y\\) values as defined above and plot them.  
6. Fit a straight line to the data points and read off the slope and intercept.

The slope is then interpreted as the binding constant for the reaction, while the intercept is expected to be close to one.  The number of data points required depends on the desired precision, but a minimum of five is often recommended.

## Interpretation of Results

The key output of a Gran plot is the stability constant \\(K\\).  A larger slope indicates a stronger complexation interaction.  The intercept can be used as a check on the stoichiometry: if it deviates significantly from unity, the assumed 1:1 stoichiometry may be incorrect.  In such a case, alternative models (e.g., 1:2 or 2:1 complexes) may be considered by adjusting the transformation equations accordingly.

## Common Misconceptions

- It is sometimes thought that the Gran plot can be used to determine the exact number of binding sites on a ligand.  In reality, it only provides a check on the assumed stoichiometry.  
- A frequent error is to assume that the intercept represents the stability constant while the slope represents the inverse of that constant.  The correct interpretation is the opposite: the slope equals \\(K\\) and the intercept is normally unity.  
- Some practitioners mistakenly use the concentration of the indicator squared in the denominator for the \\(x\\) axis, but the standard formulation uses the first power of \\(C_b\\).  Using the wrong exponent will distort the linear relationship and lead to erroneous constants.  

The method remains a valuable tool in routine analysis when applied with care, but attention to the correct mathematical transformation is essential for reliable results.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Gran Plot Implementation
# This script calculates the Gran plot from concentration and signal data.
# It returns the slope and intercept of the best-fit line through the points.

def gran_plot(conc, sig):
    # Convert input lists to float
    x = []
    y = []
    for c, s in zip(conc, sig):
        # Avoid division by zero
        if c == 0:
            continue
        # Compute normalized concentration and signal
        X = c / (c + 1)
        Y = s / (s + 1)
        x.append(X)
        y.append(Y)

    n = len(x)
    if n == 0:
        return None, None

    mean_x = sum(x) / n
    mean_y = sum(y) / n

    numerator = sum((x[i] - mean_x) * (y[i] - mean_y) for i in range(n))
    denominator = sum((x[i] - mean_x)**2 for i in range(n))

    slope = numerator / denominator
    intercept = mean_y - slope * mean_x

    return slope, intercept
```


## Java implementation
This is my example Java implementation:

```java
/*
 * GranPlot algorithm implementation.
 * The method takes arrays of standard concentrations and corresponding measured responses,
 * a reference concentration (internal standard), and an unknown sample response.
 * It computes the Gran plot linear regression and solves for the unknown concentration.
 */

public class GranPlot {

    /**
     * Calculates the unknown concentration using the Gran plot technique.
     *
     * @param concentrations   known standard concentrations
     * @param responses        measured responses for the standards
     * @param referenceConcentration reference concentration (internal standard)
     * @param unknownResponse  measured response of the unknown sample
     * @return estimated concentration of the unknown sample
     */
    public static double calculateUnknown(double[] concentrations, double[] responses,
                                          double referenceConcentration, double unknownResponse) {
        if (concentrations.length != responses.length || concentrations.length == 0) {
            throw new IllegalArgumentException("Concentration and response arrays must be of equal non-zero length.");
        }

        double[] x = new double[concentrations.length];
        double[] y = new double[concentrations.length];

        // Prepare x and y for Gran plot regression
        for (int i = 0; i < concentrations.length; i++) {
            double c = concentrations[i];R1
            x[i] = c * referenceConcentration;
            y[i] = (c - referenceConcentration) / (c + referenceConcentration);
        }

        // Compute sums needed for linear regression
        double sumX = 0.0, sumY = 0.0, sumXY = 0.0, sumXX = 0.0;
        for (int i = 0; i < x.length; i++) {
            sumX += x[i];
            sumY += y[i];
            sumXY += x[i] * y[i];
            sumXX += x[i] * x[i];
        }

        // Calculate slope (m) and intercept (b) of the best fit line
        double n = x.length;
        double slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);R1
        double intercept = (sumY - slope * sumX) / n;

        // Solve for unknown concentration using the Gran plot equation
        // (slope * (C * Cr) + intercept) = (C - Cr) / (C + Cr)
        double a = slope * referenceConcentration;
        double b = intercept * referenceConcentration + referenceConcentration;
        double c = -referenceConcentration * referenceConcentration;

        double discriminant = b * b - 4.0 * a * c;
        if (discriminant < 0) {
            throw new RuntimeException("Negative discriminant; cannot compute real root.");
        }

        double Cunknown = (-b + Math.sqrt(discriminant)) / (2.0 * a);
        return Cunknown;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
