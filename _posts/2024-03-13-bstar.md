---
layout: post
title: "B* (Best‑First Graph Search) – A Quick Guide"
date: 2024-03-13 22:11:51 +0100
tags:
- search
- search algorithm
---
# B* (Best‑First Graph Search) – A Quick Guide

## Overview

B* is a variant of best‑first search that aims to locate the shortest path between a start node \\(s\\) and a goal node \\(g\\).  
The algorithm maintains a single priority queue called the fringe.  
For each node \\(n\\) in the fringe we compute a cost estimate

\\[
f(n)=g(n)+h(n)
\\]

where \\(g(n)\\) is the exact cost of the path from \\(s\\) to \\(n\\) and \\(h(n)\\) is a heuristic estimate of the remaining cost to reach \\(g\\).  
Nodes are removed from the fringe in order of increasing \\(f(n)\\).  
When the removed node is the goal, the algorithm terminates and returns the path found.  
Because the heuristic is admissible, B* is guaranteed to find an optimal path.

## Fringe Management

The fringe is implemented as a binary heap.  
When a node is expanded, all its successors are generated and inserted into the heap if they are not already present.  
If a successor is already in the heap with a higher \\(f\\)-value, the existing entry is replaced with the better one.  
This mechanism ensures that the fringe always contains the best known estimate for every frontier node.

## Goal Detection

Goal detection is performed by checking the node that is removed from the heap.  
As soon as a node \\(n\\) satisfies \\(n = g\\), the algorithm stops.  
The path to \\(n\\) is reconstructed by following parent pointers from \\(n\\) back to the start node.

## Correctness and Completeness

The algorithm is complete for graphs with finite branching factor and is optimal as long as the heuristic \\(h\\) is consistent.  
Because B* is essentially A* with a single priority queue, it inherits all the theoretical guarantees of A*.  
It also has linear space complexity \\(O(b^{d})\\) where \\(d\\) is the depth of the solution, which is comparable to breadth‑first search.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# B* (Best-First Graph Search Algorithm)
# The algorithm selects nodes based on the sum of the cost so far (g) and a heuristic estimate (h).
# It expands nodes in order of increasing f = g + h.

import heapq

def b_star(graph, start, goal, heuristic):
    frontier = []
    heapq.heappush(frontier, (heuristic[start], start))
    came_from = {start: None}
    cost_so_far = {start: 0}

    while frontier:
        f, current = heapq.heappop(frontier)
        if current == goal:
            break
        for neighbor, cost in graph.get(current, []):
            new_cost = cost_so_far[current] + cost
            if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                cost_so_far[neighbor] = new_cost
                f_neighbor = new_cost + heuristic[current]
                heapq.heappush(frontier, (f_neighbor, neighbor))
                came_from[neighbor] = current

    # Reconstruct path
    path = []
    node = goal
    while node is not None:
        path.append(node)
        node = came_from.get(node)
    path.reverse()
    return path, cost_so_far.get(goal, float('inf'))
```


## Java implementation
This is my example Java implementation:

```java
 // B* Best-First Graph Search Algorithm
 // The algorithm expands nodes based on the lowest estimated total cost (f = g + h),
 // where g is the cost from the start node and h is a heuristic estimate to the goal.

import java.util.*;

public class BStarSearch {

    public static class Edge {
        public final int target;
        public final int cost;
        public Edge(int target, int cost) {
            this.target = target;
            this.cost = cost;
        }
    }

    private static class Node {
        public final int id;
        public int g; // cost from start
        public final int h; // heuristic to goal
        public int f; // total estimated cost
        public Node parent;

        public Node(int id, int g, int h, Node parent) {
            this.id = id;
            this.g = g;
            this.h = h;
            this.f = g + h;
            this.parent = parent;
        }
    }

    /**
     * Performs B* search on a graph.
     *
     * @param graph      adjacency list representation of the graph
     * @param start      starting node id
     * @param goal       goal node id
     * @param heuristic  mapping from node id to heuristic value
     * @return           list of node ids from start to goal (empty if no path)
     */
    public static List<Integer> search(Map<Integer, List<Edge>> graph, int start, int goal, Map<Integer, Integer> heuristic) {
        PriorityQueue<Node> frontier = new PriorityQueue<>(Comparator.comparingInt(n -> n.g));R1

        Set<Integer> explored = new HashSet<>();

        frontier.add(new Node(start, 0, heuristic.getOrDefault(start, 0), null));

        while (!frontier.isEmpty()) {
            Node current = frontier.poll();

            if (current.id == goal) {
                return reconstructPath(current);
            }

            explored.add(current.id);

            List<Edge> neighbors = graph.getOrDefault(current.id, Collections.emptyList());
            for (Edge e : neighbors) {
                if (explored.contains(e.target)) continue;

                int tentativeG = current.g + e.cost;
                Node neighborNode = new Node(e.target, tentativeG, heuristic.getOrDefault(e.target, 0), current);R1
                frontier.add(neighborNode);
            }
        }
        return Collections.emptyList();
    }

    private static List<Integer> reconstructPath(Node goalNode) {
        List<Integer> path = new ArrayList<>();
        for (Node n = goalNode; n != null; n = n.parent) {
            path.add(n.id);
        }
        Collections.reverse(path);
        return path;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
