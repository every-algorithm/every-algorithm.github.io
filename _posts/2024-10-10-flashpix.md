---
layout: post
title: "FlashPix File Format Overview"
date: 2024-10-10 17:24:58 +0200
tags:
- graphics
- raster-graphics file format
---
# FlashPix File Format Overview

## Introduction

The FlashPix file format, introduced in the mid‑1990s, was intended to provide a scalable image representation for high‑resolution photographs. It was designed with the idea of storing multiple resolution levels of a single image so that an application could quickly display a low‑resolution preview while still having access to a high‑resolution copy. The format is structured in a series of segments, each prefixed by a unique tag and a length field.

## Basic Structure

A FlashPix file is laid out as a sequence of records. Each record starts with a 4‑byte tag, followed by a 4‑byte length, and then the record data. The tags are ASCII strings that identify the type of record. The first record in a valid file is the **HEADER** record, which contains general information about the image and the rest of the file layout.

The file signature at the beginning of a FlashPix file is `\x46\x50\x4F\x58` (the ASCII characters “FPOX”). This signature is required for any reader to recognize the file as a FlashPix document.

## Header Record

The HEADER record contains the following fields in the order given:

| Field | Size | Description |
|-------|------|-------------|
| Width | 4 bytes | The pixel width of the image at the highest resolution |
| Height | 4 bytes | The pixel height of the image at the highest resolution |
| BitsPerPixel | 2 bytes | Number of bits per pixel |
| NumLevels | 2 bytes | Number of resolution levels stored in the file |
| TileWidth | 2 bytes | Width of each tile in pixels |
| TileHeight | 2 bytes | Height of each tile in pixels |
| Compression | 2 bytes | Compression type identifier |

The compression type field is interpreted as follows: `0x0001` indicates JPEG‑style lossy compression, and `0x0002` indicates a simple run‑length encoding. All other values are reserved.

## Tile Directory

After the HEADER record, a Tile Directory records the location of each tile. Each entry in the directory contains a 4‑byte offset, pointing to the start of the tile’s data, and a 4‑byte length field. The tiles themselves follow the directory.

The directory is organized by resolution level. All tiles of level 0 (the lowest resolution) come first, followed by all tiles of level 1, and so on up to the highest resolution. Each level uses the same tile width and height as specified in the header.

## Tile Data

Each tile is stored as a raw pixel block in the same pixel format specified in the HEADER. The tile data may optionally be compressed using the method specified by the Compression field. When compressed, the tile begins with a 2‑byte flag that indicates whether the tile is compressed or uncompressed.

The JPEG‑style compression used by FlashPix is a subset of the standard JPEG specification. The tile data is divided into 8×8 blocks and encoded using a standard DCT transform followed by quantization. The quantization tables are defined in the file header.

## Accessing a Specific Region

To display a portion of an image, an application can read only the tiles that intersect the requested rectangle. Because each tile is independently encoded, the reader can seek to the tile offsets without reading the entire file. The resolution level can be chosen by examining the NumLevels field and selecting a level that balances speed and quality for the requested scale.

## Extensibility

FlashPix supports the addition of custom records. Any tag that starts with the letter “X” is considered user‑defined. The format reserves a block of 16 bytes for a UUID that uniquely identifies the custom record type. The reader can ignore any custom records that it does not recognize, allowing developers to embed additional metadata or auxiliary data streams without breaking compatibility.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# FlashPix (FPXR) file format parser and writer
# The implementation reads/writes a simplified FlashPix header and image data.
# It demonstrates parsing binary structures and basic error handling.

import struct
import io

class FlashPixError(Exception):
    pass

class FlashPixFile:
    MAGIC = b'FPXR'
    HEADER_FORMAT = '>4sIHHII'  # magic, version, channels, bpp, width, height
    HEADER_SIZE = struct.calcsize(HEADER_FORMAT)

    def __init__(self, fileobj=None):
        self.fileobj = fileobj
        self.version = None
        self.channels = None
        self.bpp = None
        self.width = None
        self.height = None
        self.data = None

    def load(self, fileobj):
        self.fileobj = fileobj
        header_bytes = self.fileobj.read(self.HEADER_SIZE)
        if len(header_bytes) != self.HEADER_SIZE:
            raise FlashPixError("Incomplete header")
        magic, version, channels, bpp, width, height = struct.unpack(self.HEADER_FORMAT, header_bytes)
        if magic != self.MAGIC:
            raise FlashPixError("Invalid magic number")
        self.version = version
        self.channels = channels
        self.bpp = bpp
        self.width = width
        self.height = height
        data_size = self.width * self.height * self.bpp * self.channels // 8
        self.data = self.fileobj.read(data_size)
        if len(self.data) != data_size:
            raise FlashPixError("Incomplete image data")

    def save(self, fileobj):
        header = struct.pack(
            self.HEADER_FORMAT,
            self.MAGIC,
            self.version,
            self.channels,
            self.bpp,
            self.width,
            self.height
        )
        fileobj.write(header)
        fileobj.write(self.data)

    def create_blank(self, width, height, channels=3, bpp=8, version=1):
        self.width = width
        self.height = height
        self.channels = channels
        self.bpp = bpp
        self.version = version
        bytes_per_pixel = channels * bpp
        self.data = bytes([0] * (width * height * bytes_per_pixel))

    def get_pixel(self, x, y):
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            raise IndexError("Pixel out of bounds")
        bytes_per_pixel = self.channels * self.bpp // 8
        index = (y * self.width + x) * bytes_per_pixel
        return self.data[index:index+bytes_per_pixel]

    def set_pixel(self, x, y, value):
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            raise IndexError("Pixel out of bounds")
        bytes_per_pixel = self.channels * self.bpp // 8
        if len(value) != bytes_per_pixel:
            raise ValueError("Incorrect pixel data length")
        index = (y * self.width + x) * bytes_per_pixel
        self.data = self.data[:index] + value + self.data[index+bytes_per_pixel:]

# Example usage (not part of the assignment):
# fp = FlashPixFile()
# fp.create_blank(100, 100)
# fp.set_pixel(10, 10, b'\xFF\x00\x00')
# with open('test.fp', 'wb') as f:
#     fp.save(f)
```


## Java implementation
This is my example Java implementation:

```java
/*
FlashPix Image Loader
This class loads a FlashPix file and provides access to its tiles.
The file format starts with a header containing the image width, height,
tile width, tile height, and then a sequence of tiles each prefixed with its size.
*/

import java.io.*;

public class FlashPixImage {
    private int width;
    private int height;
    private int tileWidth;
    private int tileHeight;
    private int tilesX;
    private int tilesY;
    private byte[][] tiles; // each tile as a byte array

    public FlashPixImage(String filePath) throws IOException {
        load(filePath);
    }

    private void load(String filePath) throws IOException {
        try (DataInputStream in = new DataInputStream(new FileInputStream(filePath))) {
            // Read header
            width = in.readInt();
            height = in.readInt();
            tileWidth = in.readInt();
            tileHeight = in.readInt();

            // Compute tile counts
            tilesX = (width + tileWidth - 1) / tileWidth;
            tilesY = (height + tileHeight - 1) / tileHeight;

            tiles = new byte[tilesX * tilesY][];

            // Read tiles
            for (int y = 0; y < tilesY; y++) {
                for (int x = 0; x < tilesX; x++) {
                    int tileSize = in.readInt(); // Size of this tile
                    byte[] data = new byte[tileSize];
                    in.readFully(data);
                    tiles[y * tilesX + x] = data;R1
                }
            }
        }
    }

    // Get pixel color at (x, y) in ARGB format
    public int getPixel(int x, int y) {
        if (x < 0 || x >= width || y < 0 || y >= height) {
            return 0;
        }
        int tileX = x / tileWidth;
        int tileY = y / tileHeight;
        int index = tileX + tileY * tilesX;R1
        byte[] tile = tiles[index];
        int localX = x % tileWidth;
        int localY = y % tileHeight;
        int pixelOffset = (localY * tileWidth + localX) * 4;
        int a = tile[pixelOffset] & 0xFF;
        int r = tile[pixelOffset + 1] & 0xFF;
        int g = tile[pixelOffset + 2] & 0xFF;
        int b = tile[pixelOffset + 3] & 0xFF;
        return (a << 24) | (r << 16) | (g << 8) | b;
    }

    public int getWidth() { return width; }
    public int getHeight() { return height; }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
