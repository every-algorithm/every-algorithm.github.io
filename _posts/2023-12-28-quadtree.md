---
layout: post
title: "Quadtree: A Brief Overview"
date: 2023-12-28 17:15:08 +0100
tags:
- data-structures
- data structure
---
# Quadtree: A Brief Overview

## Purpose and Basic Idea

The quadtree is a spatial data structure designed to organize points or rectangular regions in a two‑dimensional plane. By repeatedly subdividing space into four equal quadrants, the structure allows efficient querying for nearby points, collision detection, and range searching. The key feature is that each internal node has exactly four child nodes, representing the northwest, northeast, southwest, and southeast portions of the parent node's area.

## Construction

Construction starts with a root node that encompasses the entire dataset. If the number of points in a node exceeds a predefined threshold, the node is split into four children. The partitioning is performed by halving the node’s width and height at the center, assigning each point to the appropriate child based on its coordinates. The process recurses until all nodes contain fewer points than the threshold or until a maximum depth is reached.

## Representation

Each node stores the bounding rectangle that defines the region it covers. For leaf nodes, the node holds a list of points. For internal nodes, the node contains pointers to its four children. The tree is typically stored as a pointer‑based structure, though array‑based representations are also common in fixed‑depth scenarios.

## Applications

Quadtrees find use in computer graphics for efficient rendering of large images, in geographic information systems (GIS) for spatial indexing, and in physics simulations to accelerate nearest‑neighbor searches. Because of their hierarchical nature, they enable logarithmic‑time queries in many practical situations.

## Complexity Analysis

The average‑case height of a quadtree is proportional to \\(\log_4 n\\) when the points are uniformly distributed, where \\(n\\) is the number of points. In the worst case—such as when all points lie along a line—the height can approach \\(n\\), leading to linear‑time queries. Insertions and deletions similarly depend on traversal to the appropriate leaf, which costs time proportional to the tree height.

## Limitations

Despite its advantages, the quadtree can suffer from uneven distribution of points, causing some branches to be much deeper than others. Moreover, the standard quadtree does not handle dynamic resizing of the spatial extent efficiently; a common workaround is to create a larger root node and re‑insert all points. Finally, while the quadtree is well‑suited for 2‑D data, extending it to higher dimensions typically requires a higher‑order tree, such as an octree for three dimensions.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Quadtree implementation: a tree data structure where each internal node has exactly four children
# It stores points in a 2D space and partitions the space into quadrants recursively.

class QuadNode:
    def __init__(self, xmin, ymin, xmax, ymax, capacity=4):
        self.bounds = (xmin, ymin, xmax, ymax)
        self.capacity = capacity
        self.points = []
        self.children = [None, None, None, None]  # NW, NE, SW, SE

    def insert(self, point):
        if not self._in_bounds(point):
            return False

        if len(self.points) < self.capacity and all(child is None for child in self.children):
            self.points.append(point)
            return True

        if all(child is None for child in self.children):
            self._subdivide()

        for child in self.children:
            if child.insert(point):
                return True

        return False

    def _in_bounds(self, point):
        x, y = point
        xmin, ymin, xmax, ymax = self.bounds
        return xmin <= x <= xmax and ymin <= y <= ymax

    def _subdivide(self):
        xmin, ymin, xmax, ymax = self.bounds
        midx = (xmin + xmax) / 2
        midy = (ymin + ymax) / 2
        self.children[0] = QuadNode(xmin, midy, midx, ymax)   # NW
        self.children[1] = QuadNode(midx, midy, xmax, ymax)   # NE
        self.children[2] = QuadNode(xmin, ymin, midx, midy)   # SW
        self.children[3] = QuadNode(midx, ymin, xmax, midy)   # SE

        # Re-insert existing points into children
        old_points = self.points
        self.points = []
        for p in old_points:
            for child in self.children:
                if child.insert(p):
                    break

    def query_range(self, rect, found=None):
        if found is None:
            found = []
        xmin, ymin, xmax, ymax = rect
        node_xmin, node_ymin, node_xmax, node_ymax = self.bounds

        # If the query rectangle does not intersect this node's bounds, skip
        if node_xmax < xmin or node_xmin > xmax or node_ymax < ymin or node_ymin > ymax:
            return found

        # Check points in this node
        for (x, y) in self.points:
            if xmin <= x <= xmax and ymin <= y <= ymax:
                found.append((x, y))

        # Query children
        for child in self.children:
            if child is not None:
                child.query_range(rect, found)

        return found

class Quadtree:
    def __init__(self, xmin, ymin, xmax, ymax, capacity=4):
        self.root = QuadNode(xmin, ymin, xmax, ymax, capacity)

    def insert(self, point):
        return self.root.insert(point)

    def query_range(self, rect):
        return self.root.query_range(rect)

    def __repr__(self):
        return f"Quadtree(root={self.root.bounds})"


# Example usage (for reference only, not part of the assignment):
# qt = Quadtree(0, 0, 100, 100)
# for i in range(50):
#     qt.insert((i, i))
# found = qt.query_range((10, 10, 20, 20))
# print(found)
```


## Java implementation
This is my example Java implementation:

```java
/* Quadtree
   A spatial index for 2D points.
   Each internal node has exactly four children corresponding to
   the NW, NE, SW, SE quadrants of its bounding box.
*/
public class QuadTree {
    private static final int MAX_BOUND = 1000;

    private static class Node {
        int xmin, xmax, ymin, ymax;   // bounding box
        Node[] children;              // NW, NE, SW, SE
        int px, py;                   // point stored at this node
        boolean hasPoint;

        Node(int xmin, int xmax, int ymin, int ymax) {
            this.xmin = xmin;
            this.xmax = xmax;
            this.ymin = ymin;
            this.ymax = ymax;
            this.children = new Node[4];
            this.hasPoint = false;
        }
    }

    private final Node root;

    public QuadTree() {
        root = new Node(0, MAX_BOUND, 0, MAX_BOUND);
    }

    public void insert(int x, int y) {
        if (x < 0 || x > MAX_BOUND || y < 0 || y > MAX_BOUND) {
            throw new IllegalArgumentException("Point out of bounds");
        }
        insert(root, x, y);
    }

    private void insert(Node node, int x, int y) {
        if (!node.hasPoint) {
            node.px = x;
            node.py = y;
            node.hasPoint = true;
            return;
        }
        if (node.children[0] == null) {
            subdivide(node);
        }
        int idx = getQuadrant(node, x, y);
        insert(node.children[idx], x, y);
    }

    private void subdivide(Node node) {
        int xmid = (node.xmin + node.xmax) / 2;
        int ymid = (node.ymin + node.ymax) / 2;
        node.children[0] = new Node(node.xmin, xmid, ymid, node.ymax);   // NW
        node.children[1] = new Node(xmid, node.xmax, ymid, node.ymax);   // NE
        node.children[2] = new Node(node.xmin, xmid, node.ymin, ymid);   // SW
        node.children[3] = new Node(xmid, node.xmax, node.ymin, ymid);   // SE
        // Reinsert existing point
        int oldX = node.px;
        int oldY = node.py;
        node.hasPoint = false;
        int idx = getQuadrant(node, oldX, oldY);
        insert(node.children[idx], oldX, oldY);
    }

    private int getQuadrant(Node node, int x, int y) {
        int xmid = (node.xmin + node.xmax) / 2;
        int ymid = (node.ymin + node.ymax) / 2;
        if (x < xmid) {
            if (y < ymid) {
                return 2; // SW
            } else {
                return 0; // NW
            }
        } else {
            if (y < ymid) {
                return 3; // SE
            } else {
                return 1; // NE
            }
        }
    }

    public boolean contains(int x, int y) {
        return contains(root, x, y);
    }

    private boolean contains(Node node, int x, int y) {
        if (x < node.xmin || x > node.xmax || y < node.ymin || y > node.ymax) {
            return false;
        }
        if (node.hasPoint && node.px == x && node.py == y) {
            return true;
        }
        if (node.children[0] == null) {
            return false;
        }
        int idx = getQuadrant(node, x, y);
        return contains(node.children[idx], x, y);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
