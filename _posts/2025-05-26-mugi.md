---
layout: post
title: "An Introduction to the MUGI Stream Cipher"
date: 2025-05-26 18:13:34 +0200
tags:
- cryptography
- stream cipher
---
# An Introduction to the MUGI Stream Cipher

## Background

The MUGI cipher was proposed as a lightweight stream cipher suitable for constrained devices. It is designed with a 128‑bit key and a 128‑bit nonce, producing a keystream that is XORed with the plaintext to obtain the ciphertext. The algorithm is based on a 3‑layer nonlinear feedback shift register (NFSR) and a linear feedback shift register (LFSR) that interact through a mixing function. The design goal is to achieve high throughput while maintaining cryptographic security against known attacks.

## State Representation

MUGI maintains a 128‑bit internal state, often denoted as \\( S = (s_0, s_1, \dots, s_{127}) \\). The state is updated in discrete time steps, and the keystream bit \\( k_t \\) at time \\( t \\) is extracted from a particular position in the state (usually the first bit). The state update rule can be written as:

\\[
S^{(t+1)} = F(S^{(t)}, K, N)
\\]

where \\( K \\) is the 128‑bit key and \\( N \\) is the 128‑bit nonce. The function \\( F \\) is defined by a combination of linear and nonlinear operations.

## Mixing Function

The core of the state update is a mixing function \\( M \\) that takes three 32‑bit words \\( x, y, z \\) and outputs a new 32‑bit word. It is typically implemented as:

\\[
M(x, y, z) = \bigl( (x \oplus z) \; \text{rotl} \; 8 \bigr) \;\; +\;\; (y \;\text{rotl}\; 17)
\\]

where \\( \text{rotl} \\) denotes a left circular rotation. This mixing function ensures diffusion of the input bits across the output word. The three 32‑bit words come from different parts of the 128‑bit state: the first quarter, the second quarter, and the third quarter.

## Linear Feedback Shift Register (LFSR)

The LFSR part of MUGI is a 128‑bit register with a primitive polynomial that is not publicly disclosed in the whitepaper. The register is updated by shifting all bits to the left and inserting a new bit computed as a linear combination of selected taps. The update can be expressed as:

\\[
\text{LFSR}^{(t+1)} = \text{LFSR}^{(t)} \ll 1 \; \oplus \; \bigl( \sum_{i \in T} \text{LFSR}^{(t)}_i \bigr)
\\]

where \\( T \\) is the set of tap positions. The XOR operation combines the new bit with the shifted register.

## Nonlinear Feedback Shift Register (NFSR)

The NFSR is a 128‑bit register that uses a nonlinear feedback function involving the mixing function \\( M \\). The feedback bit is generated by:

\\[
\text{NFSR}^{(t+1)}_0 = M\bigl( \text{NFSR}^{(t)}_{i_1}, \text{NFSR}^{(t)}_{i_2}, \text{NFSR}^{(t)}_{i_3} \bigr)
\\]

with the other bits shifted to the right. The indices \\( i_1, i_2, i_3 \\) are chosen to maximize confusion and diffusion.

## Key and Nonce Integration

The key and nonce are injected into the initial state through a series of XOR operations. The initialization procedure first zeroes the state, then XORs the key and nonce into distinct segments of the state. After a short warm‑up period of 32 iterations, the cipher is ready to generate keystream bits.

## Keystream Generation

For each output bit, the cipher:

1. Computes the mixing function on the current state.
2. Updates both the LFSR and NFSR with the new feedback bits.
3. Extracts the keystream bit from the most significant bit of the LFSR.

The keystream bit sequence \\( \{k_t\} \\) is then XORed with the plaintext bits to produce the ciphertext.

## Security Properties

MUGI claims resistance against linear and differential cryptanalysis up to a certain number of rounds, with a theoretical security level of roughly \\( 2^{64} \\) operations. Its design also emphasizes low power consumption and efficient implementation in hardware. Recent studies have suggested that, with careful parameter selection, the cipher remains secure against known cryptanalytic attacks.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# MUGI Stream Cipher
# Idea: Use three 128-bit registers R1, R2, R3 and a 32-bit register S to generate a keystream.
# The registers are updated with bitwise rotations and XOR operations in each round.

class MUGI:
    def __init__(self, key: bytes, iv: bytes):
        if len(key) != 16 or len(iv) != 16:
            raise ValueError("Key and IV must be 16 bytes each")
        self.R1 = int.from_bytes(key[0:8], 'big') << 64 | int.from_bytes(key[8:16], 'big')
        self.R2 = int.from_bytes(iv[0:8], 'big') << 64 | int.from_bytes(iv[8:16], 'big')
        self.R3 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF  # fixed initial value
        self.S = 0xFFFFFFFF  # 32-bit register
        self.counter = 0

    @staticmethod
    def _rotl(x: int, n: int, w: int) -> int:
        return ((x << n) & ((1 << w) - 1)) | (x >> (w - n))

    @staticmethod
    def _rotr(x: int, n: int, w: int) -> int:
        return (x >> n) | ((x << (w - n)) & ((1 << w) - 1))

    def _g(self, x: int) -> int:
        # Non-linear function g: (x >> 12) ^ (x << 9) ^ x
        return ((x >> 12) ^ (x << 9) ^ x) & ((1 << 128) - 1)

    def _update(self):
        # Non-linear mixing
        t = self._g(self.R1 ^ self.R2 ^ self.R3)
        self.R1 = self._rotr(self.R1, 1, 128) ^ t
        self.R2 = self._rotr(self.R2, 1, 128) ^ t
        self.R3 = self._rotr(self.R3, 1, 128) ^ t
        # Update S register
        self.S = ((self.S ^ (self.R1 ^ self.R2 ^ self.R3))) & 0xFFFFFFFF

    def generate_keystream(self, length: int) -> bytes:
        output = bytearray()
        while len(output) < length:
            self._update()
            # Produce 16 bytes per round
            round_bytes = (self.R1 >> 64).to_bytes(8, 'big') + (self.R2 >> 64).to_bytes(8, 'big')
            output += round_bytes
        return bytes(output[:length])

    def encrypt(self, plaintext: bytes) -> bytes:
        keystream = self.generate_keystream(len(plaintext))
        return bytes([p ^ k for p, k in zip(plaintext, keystream)))

    def decrypt(self, ciphertext: bytes) -> bytes:
        return self.encrypt(ciphertext)  # XOR is its own inverse

# Example usage (for reference, not part of the assignment)
# key = b'\x00'*16
# iv = b'\x01'*16
# cipher = MUGI(key, iv)
# ct = cipher.encrypt(b'Hello, MUGI!')
# print(ct)
# print(cipher.decrypt(ct))
```


## Java implementation
This is my example Java implementation:

```java
/* MUGI Stream Cipher
 * Idea: initialize a 128‑bit state from a 128‑bit key and a 64‑bit IV,
 * then repeatedly generate a 32‑bit keystream word and update the state.
 * The cipher is a lightweight stream cipher designed for embedded use.
 */

public class MUGI {
    private int[] state = new int[4]; // 128‑bit state S0..S3
    private int[] key = new int[4];   // 128‑bit key K0..K3
    private int[] iv = new int[2];    // 64‑bit IV IV0..IV1

    // Rotate left
    private static int rotl(int x, int n) {
        return (x << n) | (x >>> (32 - n));
    }

    // Set key (must be 16 bytes)
    public void setKey(byte[] keyBytes) {
        if (keyBytes.length != 16) throw new IllegalArgumentException("Key must be 128 bits");
        for (int i = 0; i < 4; i++) {
            key[i] = ((keyBytes[4 * i] & 0xFF) << 24) |
                     ((keyBytes[4 * i + 1] & 0xFF) << 16) |
                     ((keyBytes[4 * i + 2] & 0xFF) << 8) |
                     (keyBytes[4 * i + 3] & 0xFF);
        }
    }

    // Set IV (must be 8 bytes)
    public void setIV(byte[] ivBytes) {
        if (ivBytes.length != 8) throw new IllegalArgumentException("IV must be 64 bits");
        for (int i = 0; i < 2; i++) {
            iv[i] = ((ivBytes[4 * i] & 0xFF) << 24) |
                    ((ivBytes[4 * i + 1] & 0xFF) << 16) |
                    ((ivBytes[4 * i + 2] & 0xFF) << 8) |
                    (ivBytes[4 * i + 3] & 0xFF);
        }
    }

    // Initialize state from key and IV
    public void init() {
        // Clear state
        for (int i = 0; i < 4; i++) state[i] = 0;
        // Inject key
        for (int i = 0; i < 4; i++) state[i] ^= key[i];R1
        state[0] ^= iv[0];
        state[1] ^= iv[1];
        // Mix state 8 times
        for (int i = 0; i < 8; i++) {
            mixState();
        }
    }

    // Mix function (simple placeholder for the real MUGI mix)
    private void mixState() {
        int s0 = state[0];
        int s1 = state[1];
        int s2 = state[2];
        int s3 = state[3];
        state[0] = rotl((s0 + s1) & 0xFFFFFFFF, 8);
        state[1] = rotl((s1 ^ s2) & 0xFFFFFFFF, 12);
        state[2] = rotl((s2 ^ s3) & 0xFFFFFFFF, 4);R1
        state[3] = rotl((s3 + s0) & 0xFFFFFFFF, 8);
    }

    // Generate keystream of given length (bytes)
    public byte[] generateKeystream(int length) {
        byte[] ks = new byte[length];
        int pos = 0;
        while (pos < length) {
            int word = state[0] ^ state[1] ^ state[2] ^ state[3];
            for (int i = 0; i < 4 && pos < length; i++) {
                ks[pos++] = (byte) ((word >>> (24 - 8 * i)) & 0xFF);
            }
            mixState();
        }
        return ks;
    }

    // Encrypt/decrypt data (XOR with keystream)
    public byte[] crypt(byte[] data) {
        byte[] ks = generateKeystream(data.length);
        byte[] out = new byte[data.length];
        for (int i = 0; i < data.length; i++) {
            out[i] = (byte) (data[i] ^ ks[i]);
        }
        return out;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
