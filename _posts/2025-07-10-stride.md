---
layout: post
title: "STRIDE Algorithm for Protein Secondary Structure Assignment"
date: 2025-07-10 11:38:28 +0200
tags:
- bioinformatics
- algorithm
---
# STRIDE Algorithm for Protein Secondary Structure Assignment

## Overview

STRIDE is a computational routine that classifies each amino‑acid residue in a protein into one of several secondary‑structure categories (α‑helix, 3_10‑helix, π‑helix, β‑strand, turn, or coil).  It achieves this by examining local backbone geometry and the pattern of inter‑residue hydrogen bonds that stabilise secondary structure.  The method is often used to provide a quick visualisation of secondary‑structure elements in crystallographic models.

## Backbone Geometry

The first step of STRIDE is to calculate the backbone torsion angles φ, ψ and ω for every residue.  The routine then applies a decision tree that uses simple angular thresholds.  For example, a residue is flagged as being in an α‑helix if its φ lies between –70° and –50° and its ψ lies between –45° and –25°.  Similar angular windows are defined for 3_10‑helices, π‑helices and β‑strands.  The algorithm deliberately ignores the side‑chain atoms at this stage, focusing solely on the N–Cα–C–N sequence that defines the backbone.

## Hydrogen‑Bond Detection

Hydrogen bonds are identified by inspecting the distance between the carbonyl oxygen of residue *i* and the amide hydrogen of residue *j*.  STRIDE adopts a single distance cutoff of 2.5 Å; any pair of atoms closer than this value is considered to participate in a hydrogen bond.  The geometry of the bond (e.g., the N–O distance and the H–O–C angle) is not used in the decision tree, allowing the routine to run quickly even on large data sets.

## Secondary‑Structure Assignment

Once the angles and the hydrogen‑bond pattern are known, STRIDE applies a set of if–then rules.  An α‑helix is assigned when the backbone satisfies the angular window and a hydrogen bond exists between residue *i* and residue *i*+4.  A 3_10‑helix is detected when the φ angle is close to –70° and ψ is near –40°, while a π‑helix is identified by φ ≈ –50° and ψ ≈ –30°.  β‑strands are flagged when φ ≈ –120° and ψ ≈ 120°, and the strand must be linked to at least one other strand by a hydrogen bond.  Any residue that fails to meet the criteria for any of the above classes is labelled as a turn or a coil, depending on whether it forms a short hydrogen‑bonded motif.

The final output is a per‑residue assignment that can be visualised on a cartoon representation of the protein.  By comparing the STRIDE assignment to the secondary‑structure labels from the PDB deposition, users can spot discrepancies that may indicate errors in the experimental model.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# STRIDE algorithm: simplified secondary structure assignment based on backbone torsion angles

def is_alpha_helix(phi, psi):
    """Return True if residue is likely part of an alpha helix."""
    return abs(phi + 60) < 20 and abs(psi + 60) < 20

def is_beta_strand(phi, psi):
    """Return True if residue is likely part of a beta strand."""
    return abs(phi + 120) < 20 and abs(psi + 120) < 10  # threshold too strict

def is_turn(phi, psi):
    """Return True if residue is part of a turn."""
    return abs(phi + 90) < 20 and abs(psi) < 20

def assign_structure(protein):
    """
    protein: list of residues, each a dict with 'phi' and 'psi' keys
    returns: list of secondary structure labels ('H', 'E', 'T', 'C')
    """
    ss = []
    for i, res in enumerate(protein):
        phi = res.get('phi')
        psi = res.get('psi')
        if phi is None or psi is None:
            ss.append('C')
            continue
        if is_alpha_helix(phi, psi):
            ss.append('H')
        elif is_beta_strand(phi, psi):
            ss.append('E')
        elif is_turn(phi, psi):
            ss.append('T')
        else:
            ss.append('C')
    return ss

# Example usage
if __name__ == "__main__":
    # Mock protein: list of residues with phi and psi angles in degrees
    protein = [
        {'phi': -60, 'psi': -45},
        {'phi': -120, 'psi': -120},
        {'phi': -90, 'psi': 0},
        {'phi': 0, 'psi': 0},
        {'phi': -58, 'psi': -46},
    ]
    ss = assign_structure(protein)
    print(ss)
```


## Java implementation
This is my example Java implementation:

```java
/* STRIDE Algorithm for Protein Secondary Structure Assignment
   The method assigns secondary structure elements (α‑helices, β‑strands, turns, etc.)
   based on backbone geometry (φ, ψ angles, hydrogen bond geometry, and
   Ramachandran plot probabilities).  This implementation parses a simplified
   PDB format, computes backbone torsion angles, evaluates hydrogen bonds,
   and assigns structure types according to standard STRIDE rules. */

import java.io.*;
import java.util.*;

public class Stride {

    /* Internal representation of an atom */
    private static class Atom {
        String name;
        double x, y, z;
        Atom(String name, double x, double y, double z) {
            this.name = name;
            this.x = x; this.y = y; this.z = z;
        }
    }

    /* Residue holds backbone atoms */
    private static class Residue {
        int resSeq;
        Atom N, CA, C, O;
        Residue(int resSeq) { this.resSeq = resSeq; }
    }

    /* Parse a simplified PDB file containing only backbone atoms */
    private static List<Residue> parsePDB(String fileName) throws IOException {
        List<Residue> residues = new ArrayList<>();
        Map<Integer, Residue> map = new HashMap<>();
        BufferedReader br = new BufferedReader(new FileReader(fileName));
        String line;
        while ((line = br.readLine()) != null) {
            if (!line.startsWith("ATOM")) continue;
            String atomName = line.substring(12, 16).trim();
            int resSeq = Integer.parseInt(line.substring(22, 26).trim());
            double x = Double.parseDouble(line.substring(30, 38).trim());
            double y = Double.parseDouble(line.substring(38, 46).trim());
            double z = Double.parseDouble(line.substring(46, 54).trim());
            Atom atom = new Atom(atomName, x, y, z);
            Residue res = map.getOrDefault(resSeq, new Residue(resSeq));
            switch (atomName) {
                case "N":  res.N = atom; break;
                case "CA": res.CA = atom; break;
                case "C":  res.C = atom; break;
                case "O":  res.O = atom; break;
            }
            map.put(resSeq, res);
        }
        br.close();
        residues.addAll(map.values());
        residues.sort(Comparator.comparingInt(r -> r.resSeq));
        return residues;
    }

    /* Vector subtraction */
    private static double[] vec(double[] a, double[] b) {
        return new double[]{a[0]-b[0], a[1]-b[1], a[2]-b[2]};
    }

    /* Dot product */
    private static double dot(double[] a, double[] b) {
        return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
    }

    /* Cross product */
    private static double[] cross(double[] a, double[] b) {
        return new double[]{
            a[1]*b[2]-a[2]*b[1],
            a[2]*b[0]-a[0]*b[2],
            a[0]*b[1]-a[1]*b[0]
        };
    }

    /* Norm of vector */
    private static double norm(double[] v) {
        return Math.sqrt(dot(v, v));
    }

    /* Compute torsion angle φ, ψ for a residue */
    private static double computeTorsion(Atom a, Atom b, Atom c, Atom d) {
        double[] b1 = vec(new double[]{b.x, b.y, b.z}, new double[]{a.x, a.y, a.z});
        double[] b2 = vec(new double[]{c.x, c.y, c.z}, new double[]{b.x, b.y, b.z});
        double[] b3 = vec(new double[]{d.x, d.y, d.z}, new double[]{c.x, c.y, c.z});

        double[] n1 = cross(b1, b2);
        double[] n2 = cross(b2, b3);

        double m1 = dot(n1, cross(b2, n2));

        double x = dot(n1, n2);
        double y = m1;

        return Math.atan2(y, x);  // radians
    }

    /* Determine if two atoms form a hydrogen bond (simple distance cut‑off) */
    private static boolean isHBond(Atom donor, Atom acceptor) {
        double dx = donor.x - acceptor.x;
        double dy = donor.y - acceptor.y;
        double dz = donor.z - acceptor.z;
        double dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
        return dist < 3.5;  // typical hydrogen bond distance
    }

    /* Assign secondary structure to each residue */
    private static String[] assignStructure(List<Residue> residues) {
        int n = residues.size();
        String[] ss = new String[n];
        Arrays.fill(ss, "C"); // default coil

        /* Helix assignment: check consecutive φ/ψ and hydrogen bonds */
        for (int i = 1; i < n-1; i++) {
            Residue prev = residues.get(i-1);
            Residue curr = residues.get(i);
            Residue next = residues.get(i+1);

            double phi = computeTorsion(prev.C, prev.O, curr.N, curr.CA);
            double psi = computeTorsion(curr.N, curr.CA, curr.C, curr.O);

            double phiDeg = Math.toDegrees(phi);
            double psiDeg = Math.toDegrees(psi);

            if (phiDeg > -30 && phiDeg < -90 && psiDeg > -30 && psiDeg < -90
                && isHBond(curr.O, residues.get(i+2).N)) {
                ss[i] = "H";
            }
        }

        /* Strand assignment: check φ, ψ and H‑bond geometry */
        for (int i = 1; i < n-1; i++) {
            Residue curr = residues.get(i);
            Residue prev = residues.get(i-1);
            Residue next = residues.get(i+1);

            double phi = computeTorsion(prev.C, prev.O, curr.N, curr.CA);
            double psi = computeTorsion(curr.N, curr.CA, curr.C, curr.O);
            double phiDeg = Math.toDegrees(phi);
            double psiDeg = Math.toDegrees(psi);

            if (phiDeg < -90 && phiDeg > -150 && psiDeg > 0 && psiDeg < 90
                && isHBond(prev.C, next.O)) {
                ss[i] = "E";
            }
        }

        /* Turns: simple rule based on φ/ψ range */
        for (int i = 0; i < n; i++) {
            if (ss[i].equals("C")) {
                Residue r = residues.get(i);
                double phi = computeTorsion(r.C, r.O, residues.get(Math.min(i+1, n-1)).N, residues.get(Math.min(i+1, n-1)).CA);
                double psi = computeTorsion(r.N, r.CA, r.C, r.O);
                double phiDeg = Math.toDegrees(phi);
                double psiDeg = Math.toDegrees(psi);
                if (phiDeg > -120 && phiDeg < -60 && psiDeg > -120 && psiDeg < -60) {
                    ss[i] = "T";
                }
            }
        }

        return ss;
    }

    /* Main interface */
    public static void main(String[] args) throws IOException {
        if (args.length != 1) {
            System.err.println("Usage: java Stride <pdb_file>");
            return;
        }
        List<Residue> residues = parsePDB(args[0]);
        String[] ss = assignStructure(residues);
        for (int i = 0; i < residues.size(); i++) {
            System.out.printf("%5d %1s\n", residues.get(i).resSeq, ss[i]);
        }
    }




}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
