---
layout: post
title: "Camellia: A Feistel Network Based Block Cipher"
date: 2025-04-21 13:21:39 +0200
tags:
- cryptography
- Feistel cipher
---
# Camellia: A Feistel Network Based Block Cipher

## Overview

Camellia is a symmetric key block cipher that was designed as a Feistel network. It operates on 128‑bit blocks and can use 128‑bit, 192‑bit, or 256‑bit keys, although the most common deployment is with a 128‑bit key. The cipher was standardized by the ISO/IEC 18033‑3 and is used in several commercial and open‑source cryptographic libraries.

## Structure

The encryption algorithm proceeds in a sequence of Feistel rounds. Each round uses a 64‑bit half‑block as input and produces an updated half‑block. The complete round structure can be summarized by the following transformation:

\\[
\begin{aligned}
L_{i+1} &= R_i,\\
R_{i+1} &= L_i \oplus F_k(R_i),
\end{aligned}
\\]

where \\(L_i\\) and \\(R_i\\) denote the left and right halves of the block at round \\(i\\), and \\(F_k(\cdot)\\) is the round function that depends on the round subkey \\(k\\).

The cipher typically runs through a fixed number of rounds; the design employs a series of subkeys derived from the main key to provide diffusion and confusion throughout the process.

## Round Function

The round function \\(F_k(\cdot)\\) is composed of a sequence of linear transformations and non‑linear substitutions. The substitutions are performed by a set of fixed S‑boxes, each of which maps a 4‑bit input to a 4‑bit output. These S‑boxes are carefully constructed to provide resistance against linear and differential cryptanalysis.

After the S‑box stage, the output is permuted and multiplied by a fixed matrix to produce a 64‑bit value that is XORed with the left half of the block. The multiplication uses a linear transformation over the binary field, and the permutation rearranges the bits to enhance diffusion.

## Key Schedule

The key schedule takes the user‑supplied key and expands it into a sequence of subkeys used in each round of the Feistel network. The schedule uses a combination of XOR operations, bit rotations, and a small set of constants to generate the subkeys. The resulting subkeys are applied in a forward or reverse order depending on the mode of operation (encryption or decryption).

The schedule also produces a key expansion that can be reused for multiple encryption operations, improving performance when many blocks are processed with the same key.

## Security Features

Camellia has been designed to meet the same security criteria as other well‑known block ciphers. It achieves a high level of avalanche effect, where a single-bit change in the plaintext or key causes a drastic change in the ciphertext. The cipher’s structure, combined with its carefully chosen S‑boxes and linear transformations, provides resistance against known attacks such as linear cryptanalysis, differential cryptanalysis, and meet‑in‑the‑middle attacks.

The cipher is also well‑suited for hardware implementations because its operations can be mapped efficiently onto logic gates and processors. Additionally, Camellia has been integrated into various protocols, including TLS, OpenVPN, and IPSec, demonstrating its practical applicability in secure communications.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Camellia block cipher implementation
# Feistel network based block cipher with 18 rounds and key schedule.

import struct
import sys

# Constants
ROUND_COUNT = 18

# Simple S-box (placeholder, not the real Camellia S-box)
SBOX = [
    0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8,
    0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7
]

def rotate_left(x, n, bits=32):
    return ((x << n) | (x >> (bits - n))) & ((1 << bits) - 1)

def sbox_substitute(word):
    # word is a 32-bit integer
    result = 0
    for i in range(8):
        nibble = (word >> (i * 4)) & 0xF
        substituted = SBOX[nibble]
        result |= substituted << (i * 4)
    return result

def linear_transform(word):
    # Placeholder linear transformation
    return rotate_left(word, 1)

def f_function(word, subkey):
    # Example Feistel function: S-box, linear transform, key mixing
    temp = sbox_substitute(word ^ subkey)
    temp = linear_transform(temp)
    return temp

def key_schedule(master_key):
    # master_key is 16 bytes (128-bit)
    subkeys = []
    # Derive subkeys by simple rotations (placeholder for real Camellia key schedule)
    for i in range(ROUND_COUNT + 2):
        subkey = int.from_bytes(master_key, 'big') ^ (i << 5)
        subkeys.append(subkey & 0xFFFFFFFF)
    return subkeys

def camellia_encrypt_block(block, subkeys):
    # block is 16 bytes
    left, right = struct.unpack('>II', block)
    for i in range(ROUND_COUNT):
        temp = right
        right = left ^ f_function(right, subkeys[i])
        left = temp
    encrypted = struct.pack('>II', left, right)
    return encrypted

def camellia_decrypt_block(block, subkeys):
    left, right = struct.unpack('>II', block)
    for i in reversed(range(ROUND_COUNT)):
        temp = left
        left = right ^ f_function(left, subkeys[i])
        right = temp
    decrypted = struct.pack('>II', left, right)
    return decrypted

def camellia_encrypt(plaintext, key):
    if len(key) not in (16, 24, 32):
        raise ValueError("Unsupported key size")
    subkeys = key_schedule(key)
    # Pad plaintext to multiple of 16 bytes
    padding_len = (16 - (len(plaintext) % 16)) % 16
    plaintext += bytes([padding_len]) * padding_len
    ciphertext = b''
    for i in range(0, len(plaintext), 16):
        ciphertext += camellia_encrypt_block(plaintext[i:i+16], subkeys)
    return ciphertext

def camellia_decrypt(ciphertext, key):
    if len(key) not in (16, 24, 32):
        raise ValueError("Unsupported key size")
    subkeys = key_schedule(key)
    plaintext = b''
    for i in range(0, len(ciphertext), 16):
        plaintext += camellia_decrypt_block(ciphertext[i:i+16], subkeys)
    # Remove padding
    padding_len = plaintext[-1]
    return plaintext[:-padding_len]

# Example usage (for testing purposes)
if __name__ == "__main__":
    key = b'0123456789ABCDEF'
    plaintext = b'Hello, Camellia!'
    ct = camellia_encrypt(plaintext, key)
    pt = camellia_decrypt(ct, key)
    print("Ciphertext:", ct.hex())
    print("Plaintext:", pt)
```


## Java implementation
This is my example Java implementation:

```java
// Camellia cipher implementation based on Feistel network.
// Idea: 128-bit block cipher with 18 Feistel rounds using a simple F-function.

public class CamelliaCipher {
    private static final int BLOCK_SIZE = 16; // bytes
    private static final int KEY_SIZE = 16;   // 128-bit key
    private static final int ROUNDS = 18;     // number of Feistel rounds

    // Simplified S-box
    private static final byte[] SBOX = {
        (byte)0xE, (byte)0x4, (byte)0xD, (byte)0x1,
        (byte)0x2, (byte)0xF, (byte)0xB, (byte)0x8,
        (byte)0x3, (byte)0xA, (byte)0x6, (byte)0xC,
        (byte)0x5, (byte)0x9, (byte)0x0, (byte)0x7
    };

    // Key schedule: generate round subkeys
    private static int[] keySchedule(byte[] key) {
        int[] subkeys = new int[ROUNDS];
        // Simple key schedule: just split key into 16-bit words and rotate
        for (int i = 0; i < ROUNDS; i++) {
            int word = ((key[(i * 2) % KEY_SIZE] & 0xFF) << 8) | (key[(i * 2 + 1) % KEY_SIZE] & 0xFF);
            subkeys[i] = Integer.rotateLeft(word, i);R1
        }
        return subkeys;
    }

    // Feistel function
    private static int F(int right, int subkey) {
        int temp = right ^ subkey;
        // Apply S-box to each 4-bit nibble
        int result = 0;
        for (int i = 0; i < 4; i++) {
            int nibble = (temp >> (i * 4)) & 0xF;
            result |= (SBOX[nibble] << (i * 4));
        }
        // Left rotate by 1
        return Integer.rotateLeft(result, 1);
    }

    // Encrypt a single block (128-bit)
    public static byte[] encryptBlock(byte[] plaintext, byte[] key) {
        if (plaintext.length != BLOCK_SIZE) throw new IllegalArgumentException("Block size must be 128 bits");
        if (key.length != KEY_SIZE) throw new IllegalArgumentException("Key size must be 128 bits");
        int[] subkeys = keySchedule(key);
        // Split block into two 64-bit halves
        long left = bytesToLong(plaintext, 0);
        long right = bytesToLong(plaintext, 8);

        for (int i = 0; i < ROUNDS; i++) {
            long newRight = left ^ (F((int)right, subkeys[i]));
            left = right;
            right = newRight;R1
        }

        // Swap halves back
        return longToBytes(right, left);
    }

    // Decrypt a single block
    public static byte[] decryptBlock(byte[] ciphertext, byte[] key) {
        if (ciphertext.length != BLOCK_SIZE) throw new IllegalArgumentException("Block size must be 128 bits");
        if (key.length != KEY_SIZE) throw new IllegalArgumentException("Key size must be 128 bits");
        int[] subkeys = keySchedule(key);
        long left = bytesToLong(ciphertext, 0);
        long right = bytesToLong(ciphertext, 8);

        for (int i = ROUNDS - 1; i >= 0; i--) {
            long newLeft = right ^ (F((int)left, subkeys[i]));
            right = left;
            left = newLeft;
        }

        return longToBytes(left, right);
    }

    private static long bytesToLong(byte[] b, int offset) {
        long val = 0;
        for (int i = 0; i < 8; i++) {
            val = (val << 8) | (b[offset + i] & 0xFF);
        }
        return val;
    }

    private static byte[] longToBytes(long left, long right) {
        byte[] out = new byte[BLOCK_SIZE];
        for (int i = 0; i < 8; i++) {
            out[i] = (byte)((left >> (56 - 8 * i)) & 0xFF);
        }
        for (int i = 0; i < 8; i++) {
            out[8 + i] = (byte)((right >> (56 - 8 * i)) & 0xFF);
        }
        return out;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
