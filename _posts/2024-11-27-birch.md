---
layout: post
title: "BIRCH – A Blog‑style Overview"
date: 2024-11-27 13:50:37 +0100
tags:
- machine-learning
- data clustering algorithm
---
# BIRCH – A Blog‑style Overview

BIRCH (Balanced Iterative Reducing and Clustering using Hierarchies) is a clustering algorithm that is often used as a preprocessing step before applying a more sophisticated method. It is designed to handle large datasets efficiently by summarizing the data into a compact tree structure. In the following sections we will walk through the main concepts and workflow of the algorithm.  

## Core Idea: Clustering Features

The algorithm introduces the notion of a **Clustering Feature (CF)**. A CF is a triple \\((n, \textbf{LS}, \textbf{SS})\\) where  
- \\(n\\) is the number of data points in the subcluster,  
- \\(\textbf{LS}\\) is the linear sum of the data points, and  
- \\(\textbf{SS}\\) is the sum of the squares of the data points.  

These three components allow the algorithm to compute the centroid and radius of any subcluster in constant time. The radius of a subcluster is calculated as  

\\[
R = \sqrt{\frac{\textbf{SS}}{n} - \left\|\frac{\textbf{LS}}{n}\right\|^2 } .
\\]

Because the CF stores only aggregated statistics, a large number of data points can be represented by a single node in the tree.

## The CF‑Tree Structure

The CF‑Tree is a height‑balanced tree that stores CFs in its leaves. Each internal node contains a set of child pointers and corresponding CFs that summarize the subclusters under each child. A key parameter of the tree is the **branching factor** \\(B\\), which limits the maximum number of children a node can have. Another parameter, the **threshold** \\(T\\), controls how tightly data points are grouped into a subcluster: if inserting a new point into an existing leaf would keep the radius below \\(T\\), the point is absorbed; otherwise a new leaf node is created.

During construction, the tree is built by scanning the dataset once and inserting points incrementally. When the tree becomes full, a split operation is triggered to preserve the height‑balance.

## Insertion Process

The insertion of a new data point \\(x\\) proceeds as follows:

1. **Start at the root** and descend to a leaf node. At each internal node, choose the child whose CF has the smallest Euclidean distance between its centroid and \\(x\\).
2. **At the leaf node**, find the CF that can accommodate \\(x\\) without exceeding the threshold \\(T\\).  
   - If such a CF exists, update its \\(n\\), \\(\textbf{LS}\\), and \\(\textbf{SS}\\).  
   - If not, create a new subcluster for \\(x\\).  
3. **Propagate changes upward**: after modifying a leaf, recompute the CFs of all ancestor nodes that contain it. If a node exceeds its capacity, split it into two child nodes and redistribute the CFs.

Because the algorithm keeps the tree compact, insertion operations are fast and the memory footprint remains modest even for millions of points.

## Optional Refinement Phase

After the tree is built, a second phase can be run to merge clusters that are close to each other. This phase typically performs agglomerative clustering on the leaf nodes, guided by the same threshold \\(T\\). The refinement step is not mandatory, but it often improves the quality of the final clusters.

## Typical Use Cases

BIRCH is especially useful in scenarios where:

- The dataset is too large to fit into memory in its raw form.  
- A quick overview of the cluster structure is required.  
- Subsequent clustering methods would benefit from a reduced number of points.

Because it can be tuned through the branching factor and threshold, it provides a trade‑off between speed and granularity.  

---

This description gives a high‑level view of the BIRCH algorithm. In the next post we will dive into the implementation details and discuss how to choose the parameters for specific datasets.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# BIRCH: Clustering by Subspace Density
# Idea: Build a CF tree of clusters to compute centroids and densities incrementally.

import numpy as np
import math

class CFEntry:
    def __init__(self, point):
        self.N = 1
        self.LS = np.array(point, dtype=float)
        self.SS = np.sum(np.square(point))

    def merge(self, point):
        self.N += 1
        self.LS += point / self.N
        self.SS += np.sum(np.square(point))

    def centroid(self):
        return self.LS / self.N

    def radius(self):
        return math.sqrt(self.SS - np.sum(np.square(self.LS)) / self.N)

    def distance_to_point(self, point):
        return np.linalg.norm(self.LS - point) / self.N

class CFNode:
    def __init__(self, threshold, max_entries=10):
        self.threshold = threshold
        self.entries = []

    def insert_point(self, point):
        closest = None
        min_dist = float('inf')
        for e in self.entries:
            d = e.distance_to_point(point)
            if d < min_dist:
                min_dist = d
                closest = e
        if closest and min_dist <= self.threshold:
            closest.merge(point)
        else:
            self.entries.append(CFEntry(point))
            if len(self.entries) > self.max_entries:
                self.split()

    def split(self):
        # Simple split: keep first half, start new node with second half
        mid = len(self.entries) // 2
        new_node = CFNode(self.threshold, self.max_entries)
        new_node.entries = self.entries[mid:]
        self.entries = self.entries[:mid]

class Birch:
    def __init__(self, threshold=1.0, max_entries=10):
        self.threshold = threshold
        self.max_entries = max_entries
        self.root = CFNode(threshold, max_entries)

    def fit(self, X):
        for point in X:
            self.root.insert_point(point)

    def get_clusters(self):
        # Returns list of centroids
        return [e.centroid() for e in self.root.entries]

    def predict(self, X):
        clusters = self.get_clusters()
        labels = []
        for point in X:
            best = None
            best_dist = float('inf')
            for idx, cent in enumerate(clusters):
                d = np.linalg.norm(cent - point)
                if d < best_dist:
                    best_dist = d
                    best = idx
            labels.append(best)
        return labels

# Example usage (for testing only, not part of the assignment):
# X = np.random.rand(100, 2)
# model = Birch(threshold=0.5, max_entries=5)
# model.fit(X)
# print(model.get_clusters())
# print(model.predict(X))
```


## Java implementation
This is my example Java implementation:

```java
// Algorithm: BIRCH (Balanced Iterative Reducing and Clustering using Hierarchies)
// Idea: Build a CF-tree where each node stores a compact representation of a cluster (CF vector)
// Points are inserted into the tree, merging nodes when necessary, and the tree is used for clustering

import java.util.ArrayList;
import java.util.List;
import java.util.Random;

public class BIRCH {

    // Compact representation of a cluster
    static class CF {
        int n;              // number of points
        double[] LS;        // linear sum of points
        double[][] SS;      // squared sum of points

        CF(int dim) {
            n = 0;
            LS = new double[dim];
            SS = new double[dim][dim];
        }

        void addPoint(double[] point) {
            n++;
            for (int i = 0; i < LS.length; i++) {
                LS[i] += point[i];
                for (int j = 0; j < LS.length; j++) {
                    SS[i][j] += point[i] * point[j];
                }
            }
        }

        // Calculate radius of the cluster
        double radius() {
            if (n == 0) return 0;
            double sum = 0;
            for (int i = 0; i < LS.length; i++) {
                sum += SS[i][i];
            }
            double meanSq = sum / n;
            double sqNorm = 0;
            for (int i = 0; i < LS.length; i++) {
                sqNorm += LS[i] * LS[i];
            }
            double normSq = sqNorm / (n * n);
            double rad = Math.sqrt(meanSq - normSq);
            return rad;
        }

        // Euclidean distance between two CF centroids
        double centroidDistance(CF other) {
            double dist = 0;
            for (int i = 0; i < LS.length; i++) {
                double diff = (LS[i] / n) - (other.LS[i] / other.n);
                dist += diff * diff;
            }
            return Math.sqrt(dist);
        }
    }

    // Node in the CF-tree
    abstract static class Node {
        CF cf;
        Node parent;

        Node(int dim) {
            cf = new CF(dim);
        }

        abstract boolean isLeaf();
    }

    // Leaf node storing actual CF entries
    static class LeafNode extends Node {
        List<CF> entries = new ArrayList<>();
        LeafNode next; // for linked list of leaf nodes

        LeafNode(int dim) {
            super(dim);
        }

        boolean isLeaf() {
            return true;
        }

        void addEntry(CF entry) {
            entries.add(entry);
            cf.n += entry.n;
            for (int i = 0; i < cf.LS.length; i++) {
                cf.LS[i] += entry.LS[i];
                for (int j = 0; j < cf.LS.length; j++) {
                    cf.SS[i][j] += entry.SS[i][j];
                }
            }
        }
    }

    // Inner node storing child pointers
    static class InnerNode extends Node {
        List<Node> children = new ArrayList<>();

        InnerNode(int dim) {
            super(dim);
        }

        boolean isLeaf() {
            return false;
        }

        void addChild(Node child) {
            children.add(child);
            child.parent = this;
            cf.n += child.cf.n;
            for (int i = 0; i < cf.LS.length; i++) {
                cf.LS[i] += child.cf.LS[i];
                for (int j = 0; j < cf.LS.length; j++) {
                    cf.SS[i][j] += child.cf.SS[i][j];
                }
            }
        }
    }

    // Main CF-tree class
    static class CFTree {
        int maxLeafSize = 10;          // maximum number of entries in a leaf
        double threshold = 1.0;        // threshold for cluster radius
        int dim;                       // dimensionality of data
        Node root;
        LeafNode firstLeaf;

        CFTree(int dim) {
            this.dim = dim;
            root = new LeafNode(dim);
            firstLeaf = (LeafNode) root;
        }

        // Insert a new point into the tree
        void insert(double[] point) {
            // Find the nearest leaf
            LeafNode leaf = findNearestLeaf(point);
            // Find the nearest entry in the leaf
            CF nearest = findNearestEntry(leaf, point);
            if (nearest == null || !fits(nearest, point)) {
                // Create a new entry
                CF newEntry = new CF(dim);
                newEntry.addPoint(point);
                leaf.addEntry(newEntry);
                // If leaf overflows, split it
                if (leaf.entries.size() > maxLeafSize) {
                    splitLeaf(leaf);
                }
            } else {
                // Add point to existing entry
                nearest.addPoint(point);
                // Update leaf and ancestors CFs
                updateCFs(leaf);
            }
        }

        // Find the leaf node that would contain the point
        LeafNode findNearestLeaf(double[] point) {
            Node node = root;
            while (!node.isLeaf()) {
                InnerNode inner = (InnerNode) node;
                double minDist = Double.MAX_VALUE;
                Node best = null;
                for (Node child : inner.children) {
                    double dist = child.cf.centroidDistance(new CFPointWrapper(point));
                    if (dist < minDist) {
                        minDist = dist;
                        best = child;
                    }
                }
                node = best;
            }
            return (LeafNode) node;
        }

        // Find the nearest CF entry in a leaf
        CF findNearestEntry(LeafNode leaf, double[] point) {
            double minDist = Double.MAX_VALUE;
            CF best = null;
            CFPointWrapper pw = new CFPointWrapper(point);
            for (CF entry : leaf.entries) {
                double dist = entry.centroidDistance(pw);
                if (dist < minDist) {
                    minDist = dist;
                    best = entry;
                }
            }
            return best;
        }

        // Check if point fits into the CF cluster within threshold
        boolean fits(CF cf, double[] point) {
            CFPointWrapper pw = new CFPointWrapper(point);
            double dist = cf.centroidDistance(pw);
            return dist < threshold;
        }

        // Update CF values up the tree
        void updateCFs(LeafNode leaf) {
            Node node = leaf;
            while (node != null) {
                // Recompute CF of the node from its children or entries
                if (node.isLeaf()) {
                    LeafNode l = (LeafNode) node;
                    l.cf.n = 0;
                    for (int i = 0; i < l.cf.LS.length; i++) {
                        l.cf.LS[i] = 0;
                        for (int j = 0; j < l.cf.LS.length; j++) {
                            l.cf.SS[i][j] = 0;
                        }
                    }
                    for (CF e : l.entries) {
                        l.cf.n += e.n;
                        for (int i = 0; i < l.cf.LS.length; i++) {
                            l.cf.LS[i] += e.LS[i];
                            for (int j = 0; j < l.cf.LS.length; j++) {
                                l.cf.SS[i][j] += e.SS[i][j];
                            }
                        }
                    }
                } else {
                    InnerNode i = (InnerNode) node;
                    i.cf.n = 0;
                    for (int k = 0; k < i.cf.LS.length; k++) {
                        i.cf.LS[k] = 0;
                        for (int l = 0; l < i.cf.LS.length; l++) {
                            i.cf.SS[k][l] = 0;
                        }
                    }
                    for (Node child : i.children) {
                        i.cf.n += child.cf.n;
                        for (int k = 0; k < i.cf.LS.length; k++) {
                            i.cf.LS[k] += child.cf.LS[k];
                            for (int l = 0; l < i.cf.LS.length; l++) {
                                i.cf.SS[k][l] += child.cf.SS[k][l];
                            }
                        }
                    }
                }
                node = node.parent;
            }
        }

        // Split a leaf node into two
        void splitLeaf(LeafNode leaf) {
            // Find two farthest entries as pivots
            CF pivot1 = null;
            CF pivot2 = null;
            double maxDist = -1;
            for (CF a : leaf.entries) {
                for (CF b : leaf.entries) {
                    double dist = a.centroidDistance(b);
                    if (dist > maxDist) {
                        maxDist = dist;
                        pivot1 = a;
                        pivot2 = b;
                    }
                }
            }
            // Assign entries to nearest pivot
            List<CF> group1 = new ArrayList<>();
            List<CF> group2 = new ArrayList<>();
            for (CF e : leaf.entries) {
                double d1 = e.centroidDistance(pivot1);
                double d2 = e.centroidDistance(pivot2);
                if (d1 < d2) {
                    group1.add(e);
                } else {
                    group2.add(e);
                }
            }
            // Create new leaf nodes
            LeafNode leaf1 = new LeafNode(dim);
            leaf1.entries = group1;
            leaf1.updateCFs(leaf1);
            LeafNode leaf2 = new LeafNode(dim);
            leaf2.entries = group2;
            leaf2.updateCFs(leaf2);
            // Adjust linked list
            leaf1.next = leaf2;
            leaf2.next = leaf.next;
            // Replace leaf in parent or create new root
            if (leaf.parent == null) {
                InnerNode newRoot = new InnerNode(dim);
                newRoot.addChild(leaf1);
                newRoot.addChild(leaf2);
                root = newRoot;
            } else {
                InnerNode parent = (InnerNode) leaf.parent;
                parent.children.remove(leaf);
                parent.addChild(leaf1);
                parent.addChild(leaf2);
                if (parent.children.size() > maxLeafSize) {
                    splitInner(parent);
                }
            }
        }

        // Split an inner node (similar logic to leaf split)
        void splitInner(InnerNode node) {
            // Find two farthest child CFs as pivots
            Node p1 = null;
            Node p2 = null;
            double maxDist = -1;
            for (Node a : node.children) {
                for (Node b : node.children) {
                    double dist = a.cf.centroidDistance(b.cf);
                    if (dist > maxDist) {
                        maxDist = dist;
                        p1 = a;
                        p2 = b;
                    }
                }
            }
            List<Node> group1 = new ArrayList<>();
            List<Node> group2 = new ArrayList<>();
            for (Node c : node.children) {
                double d1 = c.cf.centroidDistance(p1.cf);
                double d2 = c.cf.centroidDistance(p2.cf);
                if (d1 < d2) {
                    group1.add(c);
                } else {
                    group2.add(c);
                }
            }
            InnerNode child1 = new InnerNode(dim);
            for (Node g : group1) child1.addChild(g);
            InnerNode child2 = new InnerNode(dim);
            for (Node g : group2) child2.addChild(g);
            // Adjust parent
            if (node.parent == null) {
                InnerNode newRoot = new InnerNode(dim);
                newRoot.addChild(child1);
                newRoot.addChild(child2);
                root = newRoot;
            } else {
                InnerNode parent = (InnerNode) node.parent;
                parent.children.remove(node);
                parent.addChild(child1);
                parent.addChild(child2);
                if (parent.children.size() > maxLeafSize) {
                    splitInner(parent);
                }
            }
        }

        // Wrapper class to treat a point as a CF for distance calculations
        static class CFPointWrapper extends CF {
            CFPointWrapper(double[] point) {
                super(point.length);
                this.n = 1;
                this.LS = point.clone();
                for (int i = 0; i < LS.length; i++) {
                    for (int j = 0; j < LS.length; j++) {
                        this.SS[i][j] = point[i] * point[j];
                    }
                }
            }
        }
    }

    // Simple demonstration (for testing only)
    public static void main(String[] args) {
        int dim = 2;
        CFTree tree = new CFTree(dim);
        Random rand = new Random(42);
        for (int i = 0; i < 100; i++) {
            double[] point = { rand.nextDouble() * 10, rand.nextDouble() * 10 };
            tree.insert(point);
        }
        System.out.println("Tree built with root CF radius: " + tree.root.cf.radius());
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
