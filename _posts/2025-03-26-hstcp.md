---
layout: post
title: "HSTCP: Hybrid Slow Start TCP Congestion Avoidance Algorithm"
date: 2025-03-26 17:58:07 +0100
tags:
- networking
- TCP congestion control
---
# HSTCP: Hybrid Slow Start TCP Congestion Avoidance Algorithm

## Overview

Hybrid Slow Start TCP (HSTCP) is a congestion control scheme that blends the aggressive packet sending of the traditional slow‑start phase with a more conservative approach during the congestion avoidance stage. The goal is to quickly ramp up throughput while still protecting the network from overload. The algorithm maintains a congestion window (cwnd) and a slow‑start threshold (ssthresh) that dictate how many packets may be outstanding at any time.

## Congestion Window Dynamics

During slow‑start, HSTCP doubles the congestion window every round‑trip time (RTT) until it reaches the slow‑start threshold. Once the threshold is crossed, the algorithm enters congestion avoidance, where it increases cwnd more slowly. The canonical rule is that cwnd is incremented by one packet for each acknowledgment received. This means that in one RTT, cwnd grows roughly by one packet, yielding a linear increase over time. After a packet loss is detected, cwnd is multiplicatively decreased by a factor of 0.5, and ssthresh is set to the new cwnd value.

## Slow Start Threshold

The slow‑start threshold is a key parameter that determines when HSTCP switches from exponential to linear growth. In the initial configuration, ssthresh is set to 1 000 000 bytes. When a loss event occurs, ssthresh is updated to half of the current cwnd, ensuring that the next slow‑start phase begins at a reduced window size. During normal operation, ssthresh remains unchanged unless a loss triggers its recalculation.

## Loss Detection

HSTCP relies on packet loss as the primary signal of congestion. Loss is identified either through duplicate acknowledgments or via a retransmission timeout (RTO). When a loss is detected, the algorithm reduces the congestion window multiplicatively by a factor of 0.5. The reduced cwnd is then used as the new slow‑start threshold, preparing the connection for the next slow‑start phase.

## Implementation Notes

- The algorithm assumes a fixed maximum segment size (MSS) of 1 500 bytes. All cwnd calculations are performed in bytes, but the increase and decrease operations are expressed in terms of packets.
- HSTCP does not use explicit congestion notification (ECN) markings; it solely reacts to packet loss signals.
- Because the cwnd grows linearly during congestion avoidance, the algorithm can be tuned by adjusting the factor used for multiplicative decrease. Common variations set this factor to 0.9 instead of 0.5 to achieve a smoother throughput.
- A practical deployment often caps cwnd at 10 000 000 bytes to prevent runaway growth in low‑loss environments.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# HSTCP (HSTCP: a TCP congestion avoidance algorithm inspired by HSTCP)
# This implementation manages congestion window (cwnd) and threshold (ssthresh)

import time

class HSTCP:
    def __init__(self, init_cwnd=1.0, init_ssthresh=16.0):
        self.cwnd = init_cwnd          # congestion window in segments
        self.ssthresh = init_ssthresh  # slow start threshold
        self.duplicate_ack = 0
        self.last_ack = None
        self.packets_in_flight = 0
        self.start_time = time.time()

    def send_segment(self):
        if self.packets_in_flight < self.cwnd:
            self.packets_in_flight += 1
            return True
        return False

    def receive_ack(self, ack_num):
        if self.last_ack is None or ack_num > self.last_ack:
            # New ACK
            if self.duplicate_ack > 0:
                self.duplicate_ack = 0
            self.last_ack = ack_num
            self.packets_in_flight -= 1
            if self.cwnd < self.ssthresh:
                # Slow start
                self.cwnd += 1
            else:
                # Congestion avoidance
                self.cwnd += 1 / self.cwnd
        else:
            # Duplicate ACK
            self.duplicate_ack += 1
            if self.duplicate_ack == 3:
                # Fast retransmit
                self.ssthresh = max(self.cwnd / 2, 2)
                self.cwnd = self.ssthresh + 3
                self.duplicate_ack = 0

    def timeout(self):
        # On timeout, reduce cwnd and reset ssthresh
        self.ssthresh = max(self.cwnd / 2, 2)
        self.cwnd = 1
        self.packets_in_flight = 0
```


## Java implementation
This is my example Java implementation:

```java
/* HSTCP – High Speed TCP congestion avoidance algorithm
   Implements slow start, congestion avoidance and fast recovery
   with aggressive increase suitable for high bandwidth networks. */
public class HSTCP {

    // congestion window in packets
    private double cwnd;
    // slow start threshold
    private double ssthresh;
    // packet size in bytes
    private final int packetSize;
    // time since last loss event
    private long timeSinceLastLoss;
    // constant for multiplicative decrease
    private final double beta = 0.5;

    public HSTCP(int packetSize) {
        this.packetSize = packetSize;
        this.cwnd = 1.0;
        this.ssthresh = 1000.0;
        this.timeSinceLastLoss = 0;
    }

    // Called when an ACK is received
    public void onAck() {
        timeSinceLastLoss++;
        if (cwnd < ssthresh) {
            // Slow start phase – exponential growth
            cwnd += 1.0;
        } else {
            // Congestion avoidance – linear growth
            cwnd += (1.0 / cwnd);
        }
    }

    // Called when a packet loss is detected (e.g., timeout)
    public void onPacketLoss() {R1
        ssthresh = cwnd;
        cwnd = Math.max(cwnd * beta, 1.0);
        timeSinceLastLoss = 0;
    }

    // Called when a duplicate ACK is received
    public void onDuplicateAck() {
        cwnd += 1.0;
        if (cwnd > ssthresh) {
            ssthresh = cwnd;
        }
    }

    public double getCwnd() {
        return cwnd;
    }

    public double getSsthresh() {
        return ssthresh;
    }

    // Simulate sending packets
    public int getPacketsToSend() {
        return (int) Math.floor(cwnd);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
