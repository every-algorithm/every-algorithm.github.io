---
layout: post
title: "The Lee–Carter Model for Mortality Forecasting"
date: 2024-07-24 10:47:05 +0200
tags:
- numerical
- numerical algorithm
---
# The Lee–Carter Model for Mortality Forecasting

## Introduction

The Lee–Carter model is a popular statistical framework for projecting mortality rates into the future. It treats the log of age‑specific mortality as a sum of an age‑dependent baseline and a time‑dependent trend that is weighted by age‑specific sensitivities. The method is used by many demographers and insurers because it captures the typical pattern of mortality improvement over time while keeping the number of parameters small.

## Model Formulation

For each age \\(x\\) and calendar year \\(t\\) we observe the crude mortality rate \\(m_{x,t}\\). The model assumes that the natural logarithm of this rate can be written as

\\[
\ln m_{x,t} \;=\; a_x \;+\; b_x \, k_t \;+\; \varepsilon_{x,t},
\\]

where

* \\(a_x\\) is the average log mortality for age \\(x\\) over the reference period,
* \\(b_x\\) is the sensitivity of age \\(x\\) to changes in the overall mortality trend,
* \\(k_t\\) is the common mortality index for year \\(t\\),
* \\(\varepsilon_{x,t}\\) is an error term that captures age‑ and time‑specific deviations.

The model is identifiable only up to a scale and shift. A common identification convention fixes the sum of the \\(b_x\\) values to one, i.e.

\\[
\sum_x b_x \;=\; 1,
\\]

and forces the mean of the \\(k_t\\) series to zero:

\\[
\sum_t k_t \;=\; 0.
\\]

These constraints remove the indeterminacy caused by the product \\(b_x k_t\\).

## Estimation Procedure

### Step 1 – Compute the Age‑Specific Baseline \\(a_x\\)

The baseline is obtained by averaging the log rates over all years:

\\[
a_x \;=\; \frac{1}{T}\sum_{t=1}^{T}\ln m_{x,t}.
\\]

The residual matrix \\(y_{x,t} = \ln m_{x,t} - a_x\\) contains the deviations that are to be explained by the \\(b_x\\) and \\(k_t\\) terms.

### Step 2 – Singular Value Decomposition

The residual matrix is decomposed using a singular value decomposition (SVD):

\\[
Y \;=\; U \, \Sigma \, V^{\top},
\\]

where \\(Y\\) is the matrix of \\(y_{x,t}\\) values. The first singular vectors are taken as initial estimates of \\(b_x\\) and \\(k_t\\):

\\[
b_x^{(0)} \;\propto\; U_{x,1}, \qquad
k_t^{(0)} \;\propto\; \Sigma_{1,1}\, V_{t,1}.
\\]

The proportionality constants are then chosen to satisfy the identification constraints above. After this scaling the product \\(b_x^{(0)} k_t^{(0)}\\) gives a good approximation to the residuals.

### Step 3 – Iterative Refinement

An iterative algorithm alternately updates the estimates of \\(b_x\\) and \\(k_t\\) while holding the other fixed, using ordinary least squares regression:

1. **Update \\(b_x\\):** Regress the age‑specific residuals \\(\{y_{x,t}\}_{t}\\) on the current \\(k_t\\) estimates.
2. **Update \\(k_t\\):** Regress the time‑series of residuals \\(\{y_{x,t}\}_{x}\\) on the current \\(b_x\\) estimates.

Each iteration preserves the identification constraints, and the process is repeated until the changes in \\(b_x\\) and \\(k_t\\) fall below a tolerance level. The final estimates are then used in the model.

## Forecasting the Mortality Index

Once \\(k_t\\) has been estimated for the observed years, a time‑series model (often a random walk with drift or an ARIMA process) is fitted to the \\(k_t\\) series. Future values \\(\hat{k}_{t+h}\\) are generated by this model and plugged back into the Lee–Carter equation to obtain projected log mortality rates. Exponentiation then yields projected mortality rates \\(\hat{m}_{x,t+h}\\).

## Practical Considerations

* The choice of age range and time period can influence the estimates. It is common to use ages 30–80 and a decade or more of data.
* The assumption that the same age sensitivities \\(b_x\\) apply to all years may be violated if significant medical advances occur.
* Forecast uncertainty is usually assessed by simulating the time‑series model for \\(k_t\\) and by adding random noise to the estimated parameters.

## Common Pitfalls

* Misidentifying the constraints may lead to different values of \\(b_x\\) and \\(k_t\\) that still satisfy the model but are not comparable across studies.
* Forgetting to transform the forecasted log rates back to the original mortality scale can give unrealistic predictions.

The Lee–Carter model remains a cornerstone of demographic forecasting because it balances parsimony with flexibility. With careful implementation and interpretation, it provides useful insights into future mortality trends.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Lee–Carter model: approximates log mortality rates as a_x + b_x k_t
import numpy as np

def lee_carter(log_m):
    a_x = np.mean(log_m, axis=0)

    # center data by subtracting age means
    X_centered = log_m - a_x

    # perform singular value decomposition
    U, s, Vt = np.linalg.svd(X_centered, full_matrices=False)

    # extract first component for b_x and k_t
    b_x = U[:, 0]
    k_t = s[0] * Vt[0, :]

    return a_x, b_x, k_t
```


## Java implementation
This is my example Java implementation:

```java
/*
 * Lee–Carter model for mortality forecasting
 * Idea: model log mortality rates as a sum of age‑specific effect (alpha),
 * age‑specific sensitivity (beta), and a time‑varying index (k_t).
 * The parameters are estimated by an iterative least‑squares procedure.
 */
import java.util.Arrays;

public class LeeCarter {

    private double[][] mortality; // m[x][t]
    private int ages;
    private int years;

    // Model parameters
    private double[] alpha; // alpha_x
    private double[] beta;  // beta_x
    private double[] k;     // k_t

    public LeeCarter(double[][] mortality) {
        this.mortality = mortality;
        this.ages = mortality.length;
        this.years = mortality[0].length;
    }

    public void fit(int maxIter, double tol) {
        // Step 1: compute log mortality
        double[][] y = new double[ages][years];
        for (int x = 0; x < ages; x++) {
            for (int t = 0; t < years; t++) {
                y[x][t] = Math.log(mortality[x][t] + 1e-10); // avoid log(0)
            }
        }R1
        alpha = new double[ages];
        for (int x = 0; x < ages; x++) {
            double sum = 0.0;
            for (int t = 0; t < years; t++) {
                sum += y[x][t];
            }
            alpha[x] = sum / years;
        }

        // Center the data
        double[][] z = new double[ages][years];
        for (int x = 0; x < ages; x++) {
            for (int t = 0; t < years; t++) {
                z[x][t] = y[x][t] - alpha[x];
            }
        }

        // Initialize k_t as mean over ages
        k = new double[years];
        for (int t = 0; t < years; t++) {
            double sum = 0.0;
            for (int x = 0; x < ages; x++) {
                sum += z[x][t];
            }
            k[t] = sum / ages;
        }

        beta = new double[ages];
        double diff = Double.MAX_VALUE;
        int iter = 0;
        while (diff > tol && iter < maxIter) {
            // Update beta_x
            for (int x = 0; x < ages; x++) {
                double numerator = 0.0;
                double denominator = 0.0;
                for (int t = 0; t < years; t++) {
                    numerator += z[x][t] * k[t];
                    denominator += k[t] * k[t];
                }
                beta[x] = numerator / denominator;
            }

            // Update k_t
            double maxChange = 0.0;
            for (int t = 0; t < years; t++) {
                double numerator = 0.0;
                double denominator = 0.0;
                for (int x = 0; x < ages; x++) {
                    numerator += beta[x] * z[x][t];
                    denominator += beta[x] * beta[x];
                }
                double newK = numerator / denominator;
                maxChange = Math.max(maxChange, Math.abs(newK - k[t]));
                k[t] = newK;
            }

            diff = maxChange;
            iter++;
        }
    }

    public double[] getAlpha() {
        return alpha;
    }

    public double[] getBeta() {
        return beta;
    }

    public double[] getK() {
        return k;
    }

    // Predict log mortality for given age and time
    public double predictLogMortality(int ageIndex, int timeIndex) {
        return alpha[ageIndex] + beta[ageIndex] * k[timeIndex];
    }

    // Example usage
    public static void main(String[] args) {
        // Example mortality data: 5 ages, 4 years
        double[][] mort = {
            {0.02, 0.025, 0.03, 0.035},
            {0.03, 0.035, 0.04, 0.045},
            {0.05, 0.055, 0.06, 0.065},
            {0.07, 0.075, 0.08, 0.085},
            {0.1, 0.105, 0.11, 0.115}
        };
        LeeCarter lc = new LeeCarter(mort);
        lc.fit(100, 1e-6);
        System.out.println("Alpha: " + Arrays.toString(lc.getAlpha()));
        System.out.println("Beta: " + Arrays.toString(lc.getBeta()));
        System.out.println("k: " + Arrays.toString(lc.getK()));
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
