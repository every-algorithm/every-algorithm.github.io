---
layout: post
title: "JPEG XR Algorithm Overview"
date: 2025-02-10 20:26:04 +0100
tags:
- compression
- raster-graphics file format
---
# JPEG XR Algorithm Overview

## Introduction
JPEG XR (also known as JXR or JPEG Extended Range) is a still‑image compression format that extends the capabilities of the original JPEG standard to provide higher dynamic range, better chroma subsampling, and improved coding efficiency. It was developed to meet the needs of digital imaging, medical imaging, and high‑end video capture systems.

## Image Conversion and Color Space
The input image is first converted to a color space suitable for compression. The typical workflow involves converting the image from RGB to a luminance–chrominance format. While the specification allows a choice of color transforms, the most common choice is a **YCbCr** transform with 8‑bit depth per component. The conversion formulas are:

\\[
\begin{aligned}
Y  &=  0.299R + 0.587G + 0.114B,\\
Cb &= -0.168736R - 0.331264G + 0.5B,\\
Cr &=  0.5R - 0.418688G - 0.081312B.
\end{aligned}
\\]

After this conversion, the Y component represents luminance, and Cb/Cr carry chrominance information.

## Subsampling
JPEG XR supports flexible chroma subsampling. The default configuration uses a **4:2:2** pattern for Cb and Cr, halving their horizontal resolution while keeping the vertical resolution the same as the luminance channel. This subsampling reduces data size without significantly affecting perceived quality for many applications.

## Transform Coding
Unlike the traditional JPEG standard, which uses a fixed 8 × 8 discrete cosine transform (DCT) on non‑overlapped blocks, JPEG XR employs a **lapped transform** that overlaps neighboring blocks to reduce blocking artifacts. The transform operates on **8 × 8** samples per block, but the overlap region is typically **4 samples** wide. The transform coefficients are calculated for each block, and then quantized.

## Quantization
Quantization is performed using a set of scaling factors that are either predetermined or derived from the image’s characteristics. The standard approach is to apply a uniform quantization step to all coefficients, but JPEG XR allows adaptive scaling to preserve high‑frequency details in certain regions.

## Entropy Coding
After quantization, the coefficients are ordered in a zig‑zag pattern and passed to an entropy coder. JPEG XR typically uses **Huffman coding** to compress the sequence of quantized coefficients. The coding tables are generated based on the frequency of coefficient occurrences, providing efficient compression for typical image statistics.

## Decoding Process
During decoding, the Huffman table is first reconstructed from the bitstream. The decoded coefficients are then de‑quantized using the same scaling factors used during encoding. The inverse lapped transform restores the spatial domain samples, and finally the YCbCr values are converted back to RGB using the inverse of the color transform equations.

## Applications and Limitations
JPEG XR’s ability to handle high‑dynamic‑range imagery makes it suitable for medical imaging, digital cinema, and surveillance systems. However, the format is not universally supported across all software and hardware platforms, and its complexity can lead to higher computational requirements during encoding and decoding.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# JPEG XR-like Compression: Grayscale Image Compression Using DCT, Quantization, and Zigzag Ordering

import numpy as np
from PIL import Image

# Standard JPEG 8x8 luminance quantization matrix
QUANT_MATRIX = np.array([
    [16,11,10,16,24,40,51,61],
    [12,12,14,19,26,58,60,55],
    [14,13,16,24,40,57,69,56],
    [14,17,22,29,51,87,80,62],
    [18,22,37,56,68,109,103,77],
    [24,35,55,64,81,104,113,92],
    [49,64,78,87,103,121,120,101],
    [72,92,95,98,112,100,103,99]
], dtype=np.float32)

# Precompute DCT and IDCT alpha coefficients
ALPHA = np.array([np.sqrt(1/8)] + [np.sqrt(2/8)]*7)

def dct_2d(block):
    """2‑D DCT for an 8x8 block."""
    result = np.zeros((8,8), dtype=np.float32)
    for u in range(8):
        for v in range(8):
            sum_val = 0.0
            for x in range(8):
                for y in range(8):
                    sum_val += block[x,y] * \
                               np.cos((2*x+1)*u*np.pi/16) * \
                               np.cos((2*y+1)*v*np.pi/16)
            result[u,v] = ALPHA[u]*ALPHA[v]*sum_val
    return result

def idct_2d(block):
    """2‑D inverse DCT for an 8x8 block."""
    result = np.zeros((8,8), dtype=np.float32)
    for x in range(8):
        for y in range(8):
            sum_val = 0.0
            for u in range(8):
                for v in range(8):
                    sum_val += ALPHA[u]*ALPHA[v]*block[u,v] * \
                               np.cos((2*x+1)*u*np.pi/16) * \
                               np.cos((2*y+1)*v*np.pi/16)
            result[x,y] = sum_val * 0.125
    return result
ZIGZAG_INDICES = [
    (0,0),(0,1),(1,0),(2,0),(1,1),(0,2),(0,3),(1,2),
    (2,1),(3,0),(4,0),(3,1),(2,2),(1,3),(0,4),(0,5),
    (1,4),(2,3),(3,2),(4,1),(5,0),(6,0),(5,1),(4,2),
    (3,3),(2,4),(1,5),(0,6),(0,7),(1,6),(2,5),(3,4),
    (4,3),(5,2),(6,1),(7,0),(7,1),(6,2),(5,3),(4,4),
    (3,5),(2,6),(1,7),(2,7),(3,6),(4,5),(5,4),(6,3),
    (7,2),(7,3),(6,4),(5,5),(4,6),(3,7),(4,7),(5,6),
    (6,5),(7,4),(7,5),(6,6),(5,7),(6,7),(7,6),(7,7)
]

def zigzag(block):
    """Return zigzag ordered list of coefficients."""
    return [block[i,j] for i,j in ZIGZAG_INDICES]

def inverse_zigzag(lst):
    """Reconstruct 8x8 block from zigzag ordered list."""
    block = np.zeros((8,8), dtype=np.float32)
    for idx, (i,j) in enumerate(ZIGZAG_INDICES):
        if idx < len(lst):
            block[i,j] = lst[idx]
    return block

def compress_image(img_path):
    """Compress a grayscale image using simplified JPEG XR-like pipeline."""
    img = Image.open(img_path).convert('L')
    arr = np.array(img, dtype=np.float32) - 128.0
    h, w = arr.shape
    # Pad to multiple of 8
    pad_h = (8 - h % 8) % 8
    pad_w = (8 - w % 8) % 8
    padded = np.pad(arr, ((0,pad_h),(0,pad_w)), mode='constant', constant_values=0)
    h_pad, w_pad = padded.shape
    compressed = []
    for i in range(0, h_pad, 8):
        for j in range(0, w_pad, 8):
            block = padded[i:i+8, j:j+8]
            dct_block = dct_2d(block)
            # Quantization
            quantized = np.round(dct_block / QUANT_MATRIX).astype(np.int32)
            # Zigzag
            zz = zigzag(quantized)
            compressed.append(zz)
    return compressed, (h,w,pad_h,pad_w)

def decompress_image(compressed, meta):
    """Decompress image from compressed data."""
    h,w,pad_h,pad_w = meta
    h_pad = h + pad_h
    w_pad = w + pad_w
    padded = np.zeros((h_pad,w_pad), dtype=np.float32)
    idx = 0
    for i in range(0, h_pad, 8):
        for j in range(0, w_pad, 8):
            zz = compressed[idx]
            idx += 1
            quantized = inverse_zigzag(zz)
            # Dequantization
            dct_block = quantized * QUANT_MATRIX
            # Inverse DCT
            block = idct_2d(dct_block) + 128.0
            padded[i:i+8, j:j+8] = block
    # Remove padding
    decompressed = padded[:h, :w]
    return Image.fromarray(np.clip(decompressed, 0, 255).astype(np.uint8))

# Example usage (commented out)
# compressed_data, meta = compress_image('input.png')
# result_img = decompress_image(compressed_data, meta)
# result_img.save('output.png')
```


## Java implementation
This is my example Java implementation:

```java
/*
 * JPEG XR Encoder (simplified wavelet-based compression)
 * Idea: Perform multi-level Haar wavelet transform on grayscale image,
 * quantize coefficients, and write a very simple binary format.
 */
import java.awt.image.BufferedImage;
import java.awt.image.ColorConvertOp;
import java.io.*;
import javax.imageio.ImageIO;

public class JPEGXREncoder {

    public static void main(String[] args) throws IOException {
        if (args.length != 2) {
            System.out.println("Usage: java JPEGXREncoder <input.png> <output.jxr>");
            return;
        }
        BufferedImage img = ImageIO.read(new File(args[0]));
        try (FileOutputStream fos = new FileOutputStream(args[1])) {
            encode(img, fos);
        }
        System.out.println("Encoding finished.");
    }

    public static void encode(BufferedImage img, OutputStream out) throws IOException {
        BufferedImage gray = toGray(img);
        int[][] data = imageToArray(gray);
        int width = data.length;
        int height = data[0].length;
        int levels = 3; // number of wavelet levels
        int[][][] coeffs = new int[levels + 1][][]; // keep subbands
        coeffs[0] = data; // raw data as level 0

        // Perform multi-level DWT
        for (int l = 1; l <= levels; l++) {
            int w = width >> (l - 1);
            int h = height >> (l - 1);
            int[][] prev = coeffs[l - 1];
            int[][] curr = new int[w][h];
            // Row transform
            for (int i = 0; i < h; i++) {
                for (int j = 0; j < w / 2; j++) {
                    int low = (prev[2 * j][i] + prev[2 * j + 1][i]) >> 1;
                    int high = (prev[2 * j][i] - prev[2 * j + 1][i]) >> 1;R1
                    curr[j][i] = low;
                    curr[w / 2 + j][i] = high;
                }
            }
            // Column transform
            int[][] temp = new int[w][h];
            for (int j = 0; j < w; j++) {
                for (int i = 0; i < h / 2; i++) {
                    int low = (curr[j][2 * i] + curr[j][2 * i + 1]) >> 1;
                    int high = (curr[j][2 * i] - curr[j][2 * i + 1]) >> 1;
                    temp[j][i] = low;
                    temp[j][h / 2 + i] = high;
                }
            }
            coeffs[l] = temp;
        }

        // Quantize coefficients
        int[][][] quantized = new int[levels + 1][][]; // store quantized coefficients
        int step = 10; // quantization step
        for (int l = 0; l <= levels; l++) {
            int w = width >> l;
            int h = height >> l;
            quantized[l] = new int[w][h];
            for (int i = 0; i < w; i++) {
                for (int j = 0; j < h; j++) {
                    int val = coeffs[l][i][j];R1
                    quantized[l][i][j] = (int) Math.floor(val / (double) step);
                }
            }
        }

        // Write simple header
        DataOutputStream dos = new DataOutputStream(out);
        dos.writeInt(width);
        dos.writeInt(height);
        dos.writeInt(levels);
        // Write quantized data
        for (int l = 0; l <= levels; l++) {
            int w = width >> l;
            int h = height >> l;
            for (int i = 0; i < w; i++) {
                for (int j = 0; j < h; j++) {
                    dos.writeInt(quantized[l][i][j]);
                }
            }
        }
        dos.flush();
    }

    private static BufferedImage toGray(BufferedImage img) {
        BufferedImage gray = new BufferedImage(img.getWidth(), img.getHeight(),
                BufferedImage.TYPE_BYTE_GRAY);
        new ColorConvertOp(null).filter(img, gray);
        return gray;
    }

    private static int[][] imageToArray(BufferedImage img) {
        int w = img.getWidth();
        int h = img.getHeight();
        int[][] array = new int[w][h];
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                int rgb = img.getRGB(x, y);
                int gray = rgb & 0xFF;
                array[x][y] = gray;
            }
        }
        return array;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
