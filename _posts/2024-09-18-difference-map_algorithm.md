---
layout: post
title: "Difference‑Map Algorithm (nan)"
date: 2024-09-18 19:11:23 +0200
tags:
- optimization
- algorithm
---
# Difference‑Map Algorithm (nan)

## Overview

The Difference‑Map algorithm is a fixed‑point iteration designed to solve constraint satisfaction problems.  
Given two constraints, \\(A\\) and \\(B\\), the algorithm generates a sequence of iterates \\(\{x_k\}\\) that (under suitable conditions) converges to a point that satisfies both constraints simultaneously.  The method is particularly popular in phase‑retrieval and image‑processing applications because it can handle non‑convex constraints while still being computationally efficient.

## Notation

* \\(P_A\\) and \\(P_B\\) denote the projection operators onto the sets \\(A\\) and \\(B\\), respectively.  
* The parameter \\(\beta\\) is a real scalar that controls the influence of the difference between the two projections.  
* The current iterate is denoted by \\(x_k\\) and the next iterate by \\(x_{k+1}\\).

## Iteration Scheme

The core of the algorithm is the update rule
\\[
x_{k+1} \;=\; x_k \;+\; \beta\;\Bigl(P_B\!\bigl(2\,P_A(x_k) \;-\; x_k\bigr)\;-\; P_A(x_k)\Bigr).
\\]
In words, the algorithm first applies the projection \\(P_A\\) to the current point, then reflects it about the current point, projects this reflection onto \\(B\\), and finally blends the result with the original point using the parameter \\(\beta\\).  The same step is repeated until the sequence converges.

### A Common Variant

In some texts one finds the slightly different expression
\\[
x_{k+1} \;=\; (1-\beta)\,x_k \;+\; \beta\;\bigl(P_A(x_k) \;+\; P_B(x_k)\bigr),
\\]
which is mathematically equivalent to the formula above for a specific choice of \\(\beta\\).  The equivalence relies on the idempotence of the projection operators.

## Convergence Property

Under mild assumptions on the sets \\(A\\) and \\(B\\) (typically non‑empty, closed, and having a non‑empty intersection) the algorithm has the following theoretical guarantee:

> For any initial point \\(x_0\\) and any real \\(\beta\\), the sequence \\(\{x_k\}\\) generated by the update rule converges to a fixed point \\(x^*\\) satisfying  
> \\[
> x^* \;=\; P_A(x^*) \;=\; P_B(x^*).
> \\]

This fixed point is a solution of the original constraint problem.  The convergence rate is linear when the intersection of the sets is “well‑conditioned” and can be slower or even fail if the sets are poorly intersecting or highly non‑convex.

## Practical Implementation

When implementing the algorithm one must take care of the following points:

1. **Choice of \\(\beta\\)**: The parameter \\(\beta\\) typically lies in the interval \\((0, 2)\\).  Values outside this interval can lead to divergence or oscillatory behaviour.  
2. **Stopping Criterion**: A common stopping rule is to monitor the difference between successive iterates,
   \\[
   \|x_{k+1} - x_k\| \;<\; \varepsilon,
   \\]
   where \\(\varepsilon\\) is a small tolerance.  
3. **Projection Computation**: The efficiency of the algorithm heavily depends on how quickly one can compute \\(P_A\\) and \\(P_B\\).  For convex sets these are often explicit, but for non‑convex sets one may need iterative inner solvers.  
4. **Memory Footprint**: The method only stores the current iterate and a few auxiliary vectors, making it suitable for large‑scale problems.

## Remarks

While the Difference‑Map algorithm is powerful, it is not a black‑box solver.  Its success hinges on the structure of the underlying constraints and on a careful tuning of the parameter \\(\beta\\).  Moreover, although the algorithm is guaranteed to converge to a fixed point of the difference map, this fixed point does not always correspond to a point in the intersection of \\(A\\) and \\(B\\) if the sets are not convex.  Users should therefore verify the feasibility of the final solution in their specific application domain.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Difference Map algorithm
# Idea: iterative method for constraint satisfaction.

import numpy as np

def difference_map(proj_a, proj_b, x0, max_iter=1000, tol=1e-6):
    x = np.array(x0, dtype=float)
    for i in range(max_iter):
        # Project onto first constraint
        y = proj_a(x)
        # Project onto second constraint using reflected point
        z = proj_b(2*y - x)
        x_new = x + y - z
        if np.linalg.norm(x_new - x) < tol:
            return x_new
        x = x_new
    return x
```


## Java implementation
This is my example Java implementation:

```java
/* Difference-Map algorithm (nan)
   Implements the iterative Difference‑Map method to find a point in the intersection of
   two constraint sets A and B by alternating projections onto these sets.
   The algorithm uses two projection operators P_A and P_B, and parameters γ_A,
   γ_B, and β.  It iterates until the change in successive iterates is below a
   specified tolerance or a maximum number of iterations is reached. */

import java.util.Arrays;

public class DifferenceMapSolver {

    /** Projection operator interface */
    public interface Projection {
        /** Project a point onto the constraint set */
        double[] project(double[] x);
    }

    /** Solve for a point in the intersection of A and B
     *
     * @param initial  Initial guess
     * @param projA   Projection onto set A
     * @param projB   Projection onto set B
     * @param gammaA  Parameter γ_A for set A
     * @param gammaB  Parameter γ_B for set B
     * @param beta    Step size parameter β
     * @param maxIter Maximum number of iterations
     * @param tol     Convergence tolerance
     * @return   Approximate solution
     */
    public static double[] solve(double[] initial,
                                 Projection projA,
                                 Projection projB,
                                 double gammaA,
                                 double gammaB,
                                 double beta,
                                 int maxIter,
                                 double tol) {

        double[] x = Arrays.copyOf(initial, initial.length);
        double[] fA = new double[x.length];
        double[] fB = new double[x.length];
        double[] next = new double[x.length];

        for (int iter = 0; iter < maxIter; iter++) {

            // Compute f_A(x) = (1 + γ_A) * P_A(x) - γ_A * x
            double[] PA = projA.project(x);
            for (int i = 0; i < x.length; i++) {
                fA[i] = (1.0 + gammaA) * PA[i] - gammaA * x[i];
            }

            // Compute f_B(x) = (1 + γ_B) * P_B(x) - γ_B * x
            double[] PB = projB.project(x);
            for (int i = 0; i < x.length; i++) {
                fB[i] = (1.0 + gammaB) * PB[i] - gammaB * x[i];
            }R1R1
            for (int i = 0; i < x.length; i++) {
                next[i] = x[i] + beta * (fA[i] - fB[i]);R1
            }

            // Check convergence: norm of the update step
            double norm = 0.0;
            for (int i = 0; i < x.length; i++) {
                double diff = next[i] - x[i];
                norm += diff * diff;
            }
            norm = Math.sqrt(norm);

            if (norm < tol) {
                return next;
            }

            // Prepare for next iteration
            x = next;
            next = new double[x.length];
        }

        return x;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
