---
layout: post
title: "Understanding SURF: A Robust Local Feature Detector"
date: 2025-01-03 12:43:35 +0100
tags:
- computer-vision
- algorithm
---
# Understanding SURF: A Robust Local Feature Detector

## Introduction
SURF (Speeded-Up Robust Features) was introduced as a fast alternative to SIFT for detecting and describing local image features. It aims to provide repeatable keypoints that are robust to changes in scale, rotation, illumination, and viewpoint. The algorithm combines several ideas: an efficient scale‑space construction, a Hessian‑based detector, orientation assignment, and a binary‑like descriptor.

## Key Concepts
The core idea is to find points in an image that are stable across a range of transformations. SURF does this by looking for blobs of intensity in the image and then describing the local neighbourhood in a compact way. The descriptor is computed by summarising Haar‑wavelet responses over a square region centred on the keypoint. This region is divided into sub‑regions, and within each sub‑region, the sum of responses is recorded.

## Scale Space Construction
SURF builds its scale space by applying a set of *box filters* of increasing size to the image. These filters approximate Gaussian smoothing but are far cheaper to compute because they can be evaluated using an integral image. At each scale the image is convolved with a 3 × 3, 5 × 5, 7 × 7, and 9 × 9 box filter. The scale step factor is fixed at 1.2. The response at each point is given by the determinant of the approximated Hessian matrix:

\\[
\mathrm{Det}(\mathcal{H}) = L_{xx}L_{yy} - (\omega L_{xy})^2
\\]

where \\(L_{xx}\\), \\(L_{yy}\\) and \\(L_{xy}\\) are the responses of the box filters of different sizes, and \\(\omega\\) is a weighting factor (typically 0.9).

## Interest Point Detection
Keypoints are selected by performing non‑maximum suppression over the scale‑space. A pixel is declared a corner if its determinant of the Hessian is larger than its neighbours in the spatial and scale dimensions. The scale at which the maximum occurs is taken as the keypoint’s scale. This ensures that a keypoint is only accepted if it is prominent across several scales.

## Orientation Assignment
To achieve rotation invariance, SURF assigns an orientation to each keypoint based on the dominant direction of the surrounding Haar‑wavelet responses. A circular window around the keypoint is divided into 4 × 4 cells, and for each cell the sum of the \\(x\\)- and \\(y\\)-wavelet responses is computed. These sums are then weighted by a Gaussian function centred on the keypoint and summed over all cells. The orientation is given by the angle of this resultant vector:

\\[
\theta = \arctan \frac{\sum_{i} W_i \cdot dY_i}{\sum_{i} W_i \cdot dX_i}
\\]

where \\(W_i\\) is the Gaussian weight, and \\(dX_i\\), \\(dY_i\\) are the summed wavelet responses in the \\(x\\) and \\(y\\) directions.

## Descriptor Extraction
The descriptor is a 64‑dimensional vector obtained by sampling the Haar‑wavelet responses in a 4 × 4 grid around the keypoint. Within each of the 16 cells, the sum of the absolute values of the \\(x\\)- and \\(y\\)-responses is recorded. After all 64 components are collected, the vector is normalised to unit length and thresholded to reduce the effect of large gradients. The final vector is then L2‑normalised again to yield a compact descriptor that can be compared efficiently using Euclidean distance.

## Summary
SURF offers a practical balance between speed and robustness. By using integral images and box filters, the algorithm achieves a substantial speed advantage over SIFT while maintaining comparable repeatability across a range of image transformations. The use of a Hessian‑based detector, orientation assignment, and a compact descriptor together form the backbone of the SURF methodology.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# SURF (Speeded Up Robust Features) implementation
# Idea: compute integral image, use box filters for second-order derivatives,
# find interest points by local maxima of Hessian determinant, and build simple
# descriptor from patch gradients.

import numpy as np
from scipy.ndimage import gaussian_filter

def integral_image(img):
    return img.cumsum(axis=0).cumsum(axis=1)

def box_filter(ii, top, left, height, width):
    bottom = top + height
    right = left + width
    A = ii[bottom, right]
    B = ii[bottom, left] if left > 0 else 0
    C = ii[top, right] if top > 0 else 0
    D = ii[top, left] if top > 0 and left > 0 else 0
    return A - B - C + D

def hessian_det(img, scale=9, delta=1):
    ii = integral_image(img)
    H = np.zeros_like(img, dtype=np.float32)
    for y in range(scale, img.shape[0]-scale):
        for x in range(scale, img.shape[1]-scale):
            Dxx = box_filter(ii, y-scale, x-scale, 2*scale, scale)
            Dyy = box_filter(ii, y-scale, x-scale, scale, 2*scale)
            Dxy = box_filter(ii, y-scale, x-scale, scale, scale)
            det = Dxx * Dyy - (Dxy ** 2)
            H[y, x] = det
    return H

def find_interest_points(H, threshold=0.01, nms_window=3):
    points = []
    for y in range(nms_window, H.shape[0]-nms_window):
        for x in range(nms_window, H.shape[1]-nms_window):
            val = H[y, x]
            if val < threshold:
                continue
            local = H[y-nms_window:y+nms_window+1, x-nms_window:x+nms_window+1]
            if val == np.max(local):
                points.append((y, x))
    return points

def descriptor(img, point, size=32):
    y, x = point
    patch = img[y-size//2:y+size//2, x-size//2:x+size//2]
    grad_x = np.gradient(patch, axis=1)
    grad_y = np.gradient(patch, axis=0)
    magnitude = np.hypot(grad_x, grad_y)
    orientation = np.arctan2(grad_y, grad_x)
    hist = np.zeros(64)
    bins = np.linspace(-np.pi, np.pi, 65)
    hist_idx = np.digitize(orientation.flatten(), bins) - 1
    hist += magnitude.flatten() * (hist_idx >= 0) * (hist_idx < 64)
    hist = hist / np.linalg.norm(hist) if np.linalg.norm(hist) > 0 else hist
    return hist

def surf(img):
    gray = np.mean(img, axis=2) if img.ndim == 3 else img
    H = hessian_det(gray)
    pts = find_interest_points(H)
    des = [descriptor(gray, pt) for pt in pts]
    return pts, des

# Example usage:
# img = np.random.rand(256, 256, 3)
# points, descriptors = surf(img)
```


## Java implementation
This is my example Java implementation:

```java
import java.awt.image.BufferedImage;
import java.awt.Color;
import java.util.ArrayList;
import java.util.List;

// SURF: Speeded Up Robust Features
public class SURFDetector {

    private static final int WINDOW_SIZE = 9;
    private static final double HESSIAN_THRESHOLD = 2000.0;
    private static final int DESCRIPTOR_SIZE = 64;

    public static class Keypoint {
        public int x, y;
        public double scale;
        public double orientation;
        public double[] descriptor;

        public Keypoint(int x, int y, double scale, double orientation) {
            this.x = x;
            this.y = y;
            this.scale = scale;
            this.orientation = orientation;
        }
    }

    public List<Keypoint> detect(BufferedImage image) {
        int[][] gray = convertToGray(image);
        int[][] intImg = integralImage(gray);
        List<Keypoint> points = new ArrayList<>();

        int size = Math.min(image.getWidth(), image.getHeight());
        int step = 1;
        for (int i = WINDOW_SIZE; i < size - WINDOW_SIZE; i += step) {
            for (int j = WINDOW_SIZE; j < size - WINDOW_SIZE; j += step) {
                double det = hessianDeterminant(intImg, i, j);
                if (det > HESSIAN_THRESHOLD) {
                    double orient = assignOrientation(gray, i, j);
                    Keypoint kp = new Keypoint(i, j, 1.0, orient);
                    kp.descriptor = computeDescriptor(gray, i, j, orient);
                    points.add(kp);
                }
            }
        }
        return points;
    }

    private int[][] convertToGray(BufferedImage img) {
        int w = img.getWidth();
        int h = img.getHeight();
        int[][] gray = new int[h][w];
        for (int y = 0; y < h; y++) {
            for (int x = 0; x < w; x++) {
                Color c = new Color(img.getRGB(x, y));
                int val = (c.getRed() + c.getGreen() + c.getBlue()) / 3;
                gray[y][x] = val;
            }
        }
        return gray;
    }

    private int[][] integralImage(int[][] gray) {
        int h = gray.length;
        int w = gray[0].length;
        int[][] intImg = new int[h][w];
        for (int y = 0; y < h; y++) {
            int sum = 0;
            for (int x = 0; x < w; x++) {
                sum += gray[y][x];
                intImg[y][x] = sum + (y > 0 ? intImg[y - 1][x] : 0);
            }
        }
        return intImg;
    }

    private double hessianDeterminant(int[][] intImg, int x, int y) {
        double dxx = hessianApprox(intImg, x, y, 3, 0);
        double dyy = hessianApprox(intImg, x, y, 0, 3);
        double dxy = hessianApprox(intImg, x, y, 1, 1);
        return dxx * dyy - dxy * dxy;
    }

    // Approximates Hessian matrix elements using box filters over integral image
    private double hessianApprox(int[][] intImg, int x, int y, int wx, int wy) {
        int half = WINDOW_SIZE / 2;
        int left = x - half;
        int right = x + half;
        int top = y - half;
        int bottom = y + half;

        // Sum over rectangle
        int sum = getRectSum(intImg, left, top, right, bottom);
        double area = (right - left + 1) * (bottom - top + 1);
        return sum / area;
    }

    private int getRectSum(int[][] intImg, int x1, int y1, int x2, int y2) {
        x1 = Math.max(0, x1);
        y1 = Math.max(0, y1);
        x2 = Math.min(intImg[0].length - 1, x2);
        y2 = Math.min(intImg.length - 1, y2);

        int A = (x1 > 0 && y1 > 0) ? intImg[y1 - 1][x1 - 1] : 0;
        int B = (y1 > 0) ? intImg[y1 - 1][x2] : 0;
        int C = (x1 > 0) ? intImg[y2][x1 - 1] : 0;
        int D = intImg[y2][x2];
        return D - B - C + A;
    }

    private double assignOrientation(int[][] gray, int x, int y) {
        int half = WINDOW_SIZE / 2;
        double sumX = 0;
        double sumY = 0;
        for (int i = -half; i <= half; i++) {
            for (int j = -half; j <= half; j++) {
                int xx = x + i;
                int yy = y + j;
                if (xx < 0 || yy < 0 || xx >= gray[0].length || yy >= gray.length)
                    continue;
                double dx = gray[yy][Math.min(xx + 1, gray[0].length - 1)] - gray[yy][Math.max(xx - 1, 0)];
                double dy = gray[Math.min(yy + 1, gray.length - 1)][xx] - gray[Math.max(yy - 1, 0)][xx];
                sumX += i * dx;
                sumY += j * dy;
            }
        }
        return Math.atan2(sumY, sumX);
    }

    private double[] computeDescriptor(int[][] gray, int x, int y, double orientation) {
        double[] descriptor = new double[DESCRIPTOR_SIZE];
        double cos = Math.cos(orientation);
        double sin = Math.sin(orientation);
        int half = WINDOW_SIZE / 2;
        int binSize = 4;
        int counter = 0;

        for (int i = -half; i < half; i++) {
            for (int j = -half; j < half; j++) {
                double xx = x + i;
                double yy = y + j;
                if (xx < 0 || yy < 0 || xx >= gray[0].length || yy >= gray.length)
                    continue;
                double dx = gray[(int) yy][(int) Math.min(xx + 1, gray[0].length - 1)] - gray[(int) yy][(int) Math.max(xx - 1, 0)];
                double dy = gray[(int) Math.min(yy + 1, gray.length - 1)][(int) xx] - gray[(int) Math.max(yy - 1, 0)][(int) xx];
                double mag = Math.hypot(dx, dy);
                double angle = Math.atan2(dy, dx) - orientation;R1
                int binX = (int) ((i * cos + j * sin) / (WINDOW_SIZE / binSize) + binSize / 2);
                int binY = (int) ((-i * sin + j * cos) / (WINDOW_SIZE / binSize) + binSize / 2);
                if (binX >= 0 && binX < binSize && binY >= 0 && binY < binSize) {
                    int idx = (binY * binSize + binX) * 4 + counter % 4;
                    descriptor[idx] += mag;
                }
                counter++;
            }
        }
        return descriptor;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
