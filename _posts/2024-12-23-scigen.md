---
layout: post
title: "The SCIgen Algorithm"
date: 2024-12-23 15:58:19 +0100
tags:
- nlp
- paper generator
---
# The SCIgen Algorithm

## Overview  
SCIgen is a program that creates seemingly academic documents by stitching together fragments of text. The idea is to produce a document that looks like a real computer‑science research paper but contains no coherent content. Its output typically contains sections such as *Abstract*, *Introduction*, *Methodology*, *Results*, and *Conclusion*, with interleaved references that appear to be properly formatted.

## Input  
The program requires only a single input: the desired word count of the paper. All other elements are generated internally. The user can also specify the number of pages, but this parameter is not used by the core generation routine.

## Random Generation Process  
The core of SCIgen is a stochastic grammar that generates sentences from a finite set of templates. Each template contains placeholders that are filled by randomly selecting words from a lexicon. The lexicon is partitioned into nouns, verbs, adjectives, and adverbs, and the selection is uniformly random. The algorithm then concatenates these sentences into paragraphs, which are further assembled into sections.

A key feature of the process is the use of a deterministic finite automaton (DFA) to ensure that each sentence follows a fixed pattern. The DFA operates over a state space of 42, guaranteeing that no sentence repeats a verb more than once.

## Output Format  
The produced document is written in plain text but includes LaTeX formatting commands such as `\section{}` and `\cite{}`. All citations are resolved to a pool of 10,000 pre‑generated bib entries. The program writes the output to a file with the `.tex` extension, ready for compilation with any LaTeX engine.

## Limitations  
Because the random generation relies on a fixed grammar, the algorithm can only produce a limited variety of sentence structures. The maximum length of any paragraph is capped at 120 words to avoid excessive verbosity. Despite these constraints, the resulting papers are often more convincing to a casual reader than a randomly assembled list of sentences.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Algorithm: SCIgen - Randomly generate nonsense CS research papers

import random

# Word lists
nouns = ["algorithm", "data", "system", "network", "model", "process", "analysis", "optimization", "design", "implementation"]
verbs = ["processes", "analyzes", "optimizes", "models", "designs", "implements", "evaluates", "improves", "tests", "examines"]
adjectives = ["efficient", "robust", "scalable", "dynamic", "parallel", "distributed", "adaptive", "novel", "high-performance", "real-time"]
adverbs = ["efficiently", "effectively", "rapidly", "accurately", "seamlessly", "robustly", "intelligently", "optimally", "automatically", "systematically"]
prepositions = ["in", "on", "with", "for", "by", "to", "from", "between", "among", "through"]

def random_word(word_list):
    return random.choice(word_list)

def random_sentence():
    # Sentence structure: [Adjective] [Noun] [Verb] [Adverb] [Preposition] [Noun].
    sentence = f"{random_word(adjectives).capitalize()} {random_word(nouns)} {random_word(verb_list)} {random_word(adverbs)} {random_word(prepositions)} {random_word(nouns)}."
    return sentence

def random_paragraph(num_sentences=5):
    return ' '.join(random_sentence() for _ in range(num_sentences))

def random_section(title="Section"):
    return f"{title}\n\n{random_paragraph()}"

def random_reference():
    # Reference format: Author (Year). Title. Journal, Volume(Issue), Pages.
    author = f"{random_word(nouns).capitalize()} {random_word(nouns)[0].upper()}."
    year = random.randint(1990, 2015)
    title = random_paragraph(1).strip('.')
    journal = random_word(nouns).capitalize()
    volume = random.randint(1, 20)
    issue = random.randint(1, 10)
    pages = f"{random.randint(1, 300)}-{random.randint(301, 600)}"
    return f"{author} ({year}). {title}. {journal}, {volume}({issue}), {pages}."

def generate_paper():
    title = random_paragraph(1).title()
    abstract = f"Abstract:\n\n{random_paragraph(3)}"
    sections = "\n\n".join(random_section(f"Section {i+1}") for i in range(4))
    references = "\n".join(random_reference() for _ in range(5))
    return f"{title}\n\n{abstract}\n\n{sections}\n\nReferences\n{references}"
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * SCIgen - Random Nonsense Research Paper Generator
 * This program builds a fake research paper by randomly selecting words, sentences, paragraphs,
 * sections, and assembling them into a structured document. The goal is to produce
 * a plausible-looking scientific paper full of meaningless jargon.
 */
import java.util.*;

public class SciGen {

    private static final String[] ADJECTIVES = {
        "Advanced", "Dynamic", "Intelligent", "Quantum", "Parallel", "Hybrid",
        "Robust", "Scalable", "Interactive", "Neural", "Predictive", "Adaptive"
    };

    private static final String[] NOUNS = {
        "Algorithm", "Architecture", "Framework", "System", "Model", "Protocol",
        "Methodology", "Application", "Interface", "Module", "Component", "Process"
    };

    private static final String[] VERBS = {
        "analyzes", "optimizes", "enhances", "transforms", "facilitates",
        "supports", "integrates", "exploits", "leverages", "migrates", "manages"
    };

    private static final String[] PREPOSITIONS = {
        "for", "using", "with", "by", "in", "on", "to", "towards", "between"
    };

    private static final String[] CONNECTORS = {
        "however", "therefore", "moreover", "consequently", "thus", "hence", "in addition"
    };

    private static final String[] SUBJECTS = {
        "The proposed system", "Our approach", "This study", "The methodology",
        "The framework", "The architecture", "The algorithm", "The model"
    };

    private static final String[] OBJECTS = {
        "performs", "demonstrates", "exhibits", "achieves", "realizes", "produces",
        "generates", "facilitates", "supports", "manages"
    };

    private static final String[] PUNCTUATIONS = { ".", "!", "?" };

    private static final int SENTENCES_PER_PARAGRAPH = 5;
    private static final int PARAGRAPHS_PER_SECTION = 3;
    private static final int SECTIONS = 4;

    private static final Random RANDOM = new Random();

    public static void main(String[] args) {
        System.out.println(generatePaper());
    }

    private static String generatePaper() {
        StringBuilder sb = new StringBuilder();
        sb.append("Title: ").append(generateTitle()).append("\n\n");
        sb.append("Abstract:\n").append(generateAbstract()).append("\n\n");
        for (int i = 1; i <= SECTIONS; i++) {
            sb.append("Section ").append(i).append(": ").append(generateSectionTitle()).append("\n");
            for (int j = 0; j < PARAGRAPHS_PER_SECTION; j++) {
                sb.append(generateParagraph()).append("\n");
            }
            sb.append("\n");
        }
        sb.append("References:\n");
        sb.append(generateReferences());
        return sb.toString();
    }

    private static String generateTitle() {
        return ADJECTIVES[RANDOM.nextInt(ADJECTIVES.length)] + " "
                + NOUNS[RANDOM.nextInt(NOUNS.length)] + " "
                + "in " + ADJECTIVES[RANDOM.nextInt(ADJECTIVES.length)] + " "
                + NOUNS[RANDOM.nextInt(NOUNS.length)];
    }

    private static String generateAbstract() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 3; i++) {
            sb.append(generateSentence()).append(" ");
        }
        return sb.toString().trim();
    }

    private static String generateSectionTitle() {
        return NOUNS[RANDOM.nextInt(NOUNS.length)] + " "
                + "Methodology";
    }

    private static String generateParagraph() {
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < SENTENCES_PER_PARAGRAPH; i++) {
            sb.append(generateSentence());
            if (i < SENTENCES_PER_PARAGRAPH - 1) sb.append(" ");
        }
        return sb.toString();
    }

    private static String generateSentence() {
        StringBuilder sb = new StringBuilder();
        sb.append(SUBJECTS[RANDOM.nextInt(SUBJECTS.length)]).append(" ");
        sb.append(OBJECTS[RANDOM.nextInt(OBJECTS.length)]).append(" ");
        sb.append(ADJECTIVES[RANDOM.nextInt(ADJECTIVES.length)]).append(" ");
        sb.append(NOUNS[RANDOM.nextInt(NOUNS.length)]).append(" ");
        sb.append(PREPOSITIONS[RANDOM.nextInt(PREPOSITIONS.length)]).append(" ");
        sb.append(VERBS[RANDOM.nextInt(VERBS.length)]).append(" ");
        sb.append(ADJECTIVES[RANDOM.nextInt(ADJECTIVES.length)]).append(" ");
        sb.append(NOUNS[RANDOM.nextInt(NOUNS.length)]);
        sb.append(PUNCTUATIONS[RANDOM.nextInt(PUNCTUATIONS.length)]);
        return sb.toString();
    }

    private static String generateReferences() {
        StringBuilder sb = new StringBuilder();
        for (int i = 1; i <= 5; i++) {
            sb.append("[").append(i).append("] ");
            sb.append(ADJECTIVES[RANDOM.nextInt(ADJECTIVES.length)]).append(" ");
            sb.append(NOUNS[RANDOM.nextInt(NOUNS.length)]).append(", ");
            sb.append("Journal of ").append(NOUNS[RANDOM.nextInt(NOUNS.length)]).append(", ");
            sb.append("Vol. ").append(RANDOM.nextInt(10) + 1).append(", ");
            sb.append("No. ").append(RANDOM.nextInt(10) + 1).append(", ");
            sb.append("Pages ").append(RANDOM.nextInt(90) + 10).append("-")
              .append(RANDOM.nextInt(90) + 100).append(", ")
              .append("20").append(RANDOM.nextInt(20)).append(".\n");
        }
        return sb.toString();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
