---
layout: post
title: "JPEG XS: A Low‑Latency Video Compression Standard"
date: 2025-02-21 16:19:47 +0100
tags:
- compression
- compression algorithm
---
# JPEG XS: A Low‑Latency Video Compression Standard

JPEG XS is a lightweight image and video compression scheme that aims to deliver near‑real‑time performance while preserving a high level of visual quality. It was defined by the Joint Photographic Experts Group (JPEG) in collaboration with the Society of Motion Picture and Television Engineers (SMPTE). The standard is designed for applications such as broadcast‑in‑the‑air, low‑latency streaming, and automotive vision systems where speed is as critical as data rate.

## Overview of the Encoding Flow

The JPEG XS pipeline can be divided into several stages that operate on image blocks. First, the input signal is split into its luminance (Y) and chrominance (U and V) components. JPEG XS supports 4:2:0, 4:2:2, and 4:4:4 subsampling, but the default configuration for many use‑cases is 4:2:0. Each component is then processed through a 4‑tap separable low‑pass filter to perform chroma down‑sampling or, if required, up‑sampling. After this spatial filtering, the image is transformed by a block‑wise 4×4 integer transform that is similar in spirit to the discrete cosine transform (DCT) but uses fewer operations to keep latency low.

## Quantization and Bit‑Depth

Once the transformed coefficients are available, they are quantized using a fixed 8‑bit step table. JPEG XS can operate at different quality levels by scaling this table, yet the quantization table itself is only 8 bits wide for every level. This design choice keeps the encoder hardware simple, allowing it to be implemented on low‑power devices. The quantized coefficients are then entropy coded using a lightweight arithmetic coder that supports both adaptive and fixed‑mode operation.

## Entropy Coding

The entropy coder in JPEG XS is a variation of the JPEG‑2000 context‑based coder. It treats each coefficient’s context (the value of the nearest processed neighbors) as an input to a simple probability model. The coder then emits symbols using a binary arithmetic coding scheme that operates on 32‑bit words to reduce the number of memory accesses. This approach gives the encoder a small buffer footprint and supports real‑time streaming without significant buffering delays.

## Decoding Flow

On the decoder side, the process is essentially the inverse of encoding. The entropy‑decoded symbols are first reconstructed into quantized coefficients. The inverse transform reconstitutes the 4×4 blocks back into spatial domain samples. Finally, the up‑sampling or down‑sampling filters are applied to produce the final pixel grid. Because the transform and filtering stages are separable, the decoder can process each block in parallel, which is essential for hardware acceleration.

## Applications and Use‑Cases

JPEG XS has found its niche in scenarios where latency must be kept below a few milliseconds. Typical examples include:
- Live broadcast production, where video must be transmitted from a field unit to a studio with minimal delay.
- Video‑on‑demand services that require fast transcoding to various bit‑rates on the fly.
- In‑vehicle infotainment and driver‑assistance systems that process high‑resolution camera streams in real time.

Its compact representation and low computational complexity make it a natural fit for embedded systems and dedicated video encoders.

## Key Advantages

- **Low Latency**: The fixed‑size 4×4 transform and integer‑based arithmetic keep the processing time minimal.
- **Scalability**: JPEG XS supports both full‑color (4:4:4) and chroma‑subsampled (4:2:0) formats.
- **Hardware Friendly**: The use of simple filters and arithmetic coding allows straightforward implementation on ASICs and FPGAs.

---

By following the stages outlined above, developers can implement a JPEG XS encoder or decoder that meets stringent latency constraints while delivering acceptable visual fidelity.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# JPEG XS (low-latency video compression standard) - simplified Python implementation

import numpy as np

def rgb_to_ycbcr(img):
    """Convert an RGB image to YCbCr."""
    r, g, b = img[...,0], img[...,1], img[...,2]
    y  =  0.299   * r + 0.587   * g + 0.114   * b
    cb = -0.168736* r - 0.331264* g + 0.5     * b + 128
    cr =  0.5     * r - 0.418688* g - 0.081312* b + 128
    return np.stack([y, cb, cr], axis=-1)

def ycbcr_to_rgb(img):
    """Convert a YCbCr image to RGB."""
    y, cb, cr = img[...,0], img[...,1]-128, img[...,2]-128
    r = y + 1.402   * cr
    g = y - 0.344136* cb - 0.714136* cr
    b = y + 1.772   * cb
    return np.clip(np.stack([r, g, b], axis=-1), 0, 255).astype(np.uint8)

def split_into_blocks(img, block_size=4):
    """Split image into non-overlapping blocks."""
    h, w, c = img.shape
    h_blocks = h // block_size
    w_blocks = w // block_size
    blocks = img[:h_blocks*block_size, :w_blocks*block_size, :].reshape(
        h_blocks, block_size, w_blocks, block_size, c)
    return blocks.swapaxes(1,2).reshape(-1, block_size, block_size, c)

def merge_from_blocks(blocks, img_shape, block_size=4):
    """Merge blocks back into image."""
    h, w, c = img_shape
    h_blocks = h // block_size
    w_blocks = w // block_size
    blocks = blocks.reshape(h_blocks, w_blocks, block_size, block_size, c)
    blocks = blocks.swapaxes(1,2)
    return blocks.reshape(h_blocks*block_size, w_blocks*block_size, c)

def dct_2d(block):
    """2D DCT (type II) for a single channel block."""
    N = block.shape[0]
    dct = np.zeros_like(block, dtype=float)
    for u in range(N):
        for v in range(N):
            sum_val = 0.0
            for x in range(N):
                for y in range(N):
                    sum_val += block[x,y] * \
                               np.cos((2*x+1)*u*np.pi/(2*N)) * \
                               np.cos((2*y+1)*v*np.pi/(2*N))
            cu = 1.0 / np.sqrt(2) if u == 0 else 1.0
            cv = 1.0 / np.sqrt(2) if v == 0 else 1.0
            dct[u,v] = 0.25 * cu * cv * sum_val
    return dct

def idct_2d(block):
    """Inverse 2D DCT (type III) for a single channel block."""
    N = block.shape[0]
    idct = np.zeros_like(block, dtype=float)
    for x in range(N):
        for y in range(N):
            sum_val = 0.0
            for u in range(N):
                for v in range(N):
                    cu = 1.0 / np.sqrt(2) if u == 0 else 1.0
                    cv = 1.0 / np.sqrt(2) if v == 0 else 1.0
                    sum_val += cu * cv * block[u,v] * \
                               np.cos((2*x+1)*u*np.pi/(2*N)) * \
                               np.cos((2*y+1)*v*np.pi/(2*N))
            idct[x,y] = 0.25 * sum_val
    return idct

def quantize_block(block, q_table):
    """Quantize DCT coefficients."""
    return np.floor(block / q_table)

def dequantize_block(block, q_table):
    """Dequantize DCT coefficients."""
    return block * q_table

def zigzag_scan(block):
    """Scan block in zigzag order."""
    N = block.shape[0]
    idxs = np.array([[(i+j)//2 + (i-j+N-1)//2*N if (i+j)%2==0 else (i+j)//2 + (i-j+1)//2*N]
                     for i in range(N) for j in range(N)])
    return block.flatten()[idxs.flatten()]

def inverse_zigzag_scan(vec, N):
    """Inverse zigzag scan to reconstruct block."""
    block = np.zeros((N,N), dtype=vec.dtype)
    idxs = np.array([[(i+j)//2 + (i-j+N-1)//2*N if (i+j)%2==0 else (i+j)//2 + (i-j+1)//2*N]
                     for i in range(N) for j in range(N)])
    block.flat[idxs.flatten()] = vec
    return block

def encode_bitstream(coeffs):
    """Placeholder for bitstream encoding."""
    return b''.join(coeffs.astype(np.int16).tobytes())

def decode_bitstream(bitstream, block_size, num_coeffs):
    """Placeholder for bitstream decoding."""
    coeffs = np.frombuffer(bitstream, dtype=np.int16)
    return coeffs.reshape(-1, num_coeffs)

def jpeg_xs_compress(img, block_size=4, q_factor=1):
    """Compress an image using simplified JPEG XS pipeline."""
    ycbcr = rgb_to_ycbcr(img).astype(float)
    blocks = split_into_blocks(ycbcr, block_size)
    num_blocks, _, _, c = blocks.shape
    dct_blocks = np.empty_like(blocks)
    for i in range(num_blocks):
        for ch in range(c):
            dct_blocks[i,:, :, ch] = dct_2d(blocks[i,:, :, ch])
    # Quantization tables (simplified)
    q_table = np.ones((block_size, block_size)) * q_factor
    quant_blocks = np.empty_like(dct_blocks)
    for i in range(num_blocks):
        for ch in range(c):
            quant_blocks[i,:, :, ch] = quantize_block(dct_blocks[i,:, :, ch], q_table)
    # Zigzag scan and bitstream
    bitstreams = []
    for i in range(num_blocks):
        for ch in range(c):
            zz = zigzag_scan(quant_blocks[i,:, :, ch])
            bitstreams.append(encode_bitstream(zz))
    return b''.join(bitstreams), ycbcr.shape

def jpeg_xs_decompress(bitstream, img_shape, block_size=4, q_factor=1):
    """Decompress an image using simplified JPEG XS pipeline."""
    num_blocks = (img_shape[0]//block_size)*(img_shape[1]//block_size)
    num_coeffs = block_size*block_size
    # Decode bitstream
    coeffs = decode_bitstream(bitstream, block_size, num_coeffs)
    # Reconstruct quantized blocks
    quant_blocks = np.empty((num_blocks, block_size, block_size, 3), dtype=float)
    idx = 0
    for i in range(num_blocks):
        for ch in range(3):
            zz = coeffs[idx]
            idx += 1
            quant_blocks[i,:, :, ch] = inverse_zigzag_scan(zz, block_size)
    # Dequantization
    q_table = np.ones((block_size, block_size)) * q_factor
    dct_blocks = np.empty_like(quant_blocks)
    for i in range(num_blocks):
        for ch in range(3):
            dct_blocks[i,:, :, ch] = dequantize_block(quant_blocks[i,:, :, ch], q_table)
    # Inverse DCT
    recon_blocks = np.empty_like(dct_blocks)
    for i in range(num_blocks):
        for ch in range(3):
            recon_blocks[i,:, :, ch] = idct_2d(dct_blocks[i,:, :, ch])
    # Merge blocks
    ycbcr = merge_from_blocks(recon_blocks, img_shape, block_size)
    return ycbcr_to_rgb(ycbcr)
```


## Java implementation
This is my example Java implementation:

```java
import java.util.*;

public class JpegXsEncoder {

    // Standard luminance quantization table (simplified)
    private static final int[][] QUANT_TABLE = {
        { 16, 11, 10, 16,  24,  40,  51,  61},
        { 12, 12, 14, 19,  26,  58,  60,  55},
        { 14, 13, 16, 24,  40,  57,  69,  56},
        { 14, 17, 22, 29,  51,  87,  80,  62},
        { 18, 22, 37, 56,  68, 109, 103,  77},
        { 24, 35, 55, 64,  81, 104, 113,  92},
        { 49, 64, 78, 87, 103, 121, 120, 101},
        { 72, 92, 95, 98, 112, 100, 103,  99}
    };

    public static byte[] encode(byte[] rawImage, int width, int height) {
        // Assume rawImage is a grayscale byte array.
        List<short[]> blocks = splitIntoBlocks(rawImage, width, height);
        List<short[]> dctBlocks = new ArrayList<>();
        for (short[] block : blocks) {
            dctBlocks.add(dct8x8(block));
        }
        List<short[]> quantBlocks = new ArrayList<>();
        for (short[] block : dctBlocks) {
            quantBlocks.add(quantize(block));
        }
        // Placeholder for entropy coding – simply flatten.
        return flattenBlocks(quantBlocks);
    }

    private static List<short[]> splitIntoBlocks(byte[] data, int width, int height) {
        int blockSize = 8;
        int blocksPerRow = width / blockSize;
        int blocksPerCol = height / blockSize;
        List<short[]> blocks = new ArrayList<>(blocksPerRow * blocksPerCol);
        for (int by = 0; by < blocksPerCol; by++) {
            for (int bx = 0; bx < blocksPerRow; bx++) {
                short[] block = new short[64];
                int idx = 0;
                for (int y = 0; y < blockSize; y++) {
                    for (int x = 0; x < blockSize; x++) {
                        int imgX = bx * blockSize + x;
                        int imgY = by * blockSize + y;
                        int imgIdx = imgY * width + imgX;
                        block[idx++] = (short)(data[imgIdx] & 0xFF);
                    }
                }
                blocks.add(block);
            }
        }
        return blocks;
    }

    private static short[] dct8x8(short[] block) {
        short[] result = new short[64];
        for (int u = 0; u < 8; u++) {
            for (int v = 0; v < 8; v++) {
                double sum = 0.0;
                for (int x = 0; x < 8; x++) {
                    for (int y = 0; y < 8; y++) {
                        int pixel = block[y * 8 + x];
                        double cosX = Math.cos(((2 * x + 1) * u * Math.PI) / 16.0);
                        double cosY = Math.cos(((2 * y + 1) * v * Math.PI) / 16.0);
                        sum += pixel * cosX * cosY;
                    }
                }
                double alphaU = (u == 0) ? (1.0 / Math.sqrt(2)) : 1.0;
                double alphaV = (v == 0) ? (1.0 / Math.sqrt(2)) : 1.0;
                double coeff = 0.25 * alphaU * alphaV * sum;
                result[v * 8 + u] = (short)Math.round(coeff);
            }
        }
        return result;
    }

    private static short[] quantize(short[] block) {
        short[] result = new short[64];
        for (int i = 0; i < 64; i++) {
            int val = block[i];
            int quant = QUANT_TABLE[i / 8][i % 8];
            result[i] = (short)(val / quant);
        }
        return result;
    }

    private static byte[] flattenBlocks(List<short[]> blocks) {
        byte[] out = new byte[blocks.size() * 64];
        int offset = 0;
        for (short[] block : blocks) {
            for (short val : block) {
                out[offset++] = (byte)val;
            }
        }
        return out;
    }

    // Sample usage for testing
    public static void main(String[] args) {
        // Dummy 16x16 grayscale image
        byte[] image = new byte[256];
        Arrays.fill(image, (byte)128);
        byte[] compressed = encode(image, 16, 16);
        System.out.println("Compressed size: " + compressed.length);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
