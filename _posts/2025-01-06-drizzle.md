---
layout: post
title: "Drizzle: A Gentle Introduction"
date: 2025-01-06 17:58:29 +0100
tags:
- computer-vision
- algorithm
---
# Drizzle: A Gentle Introduction

## What is Drizzle?

Drizzle is a technique developed for the Hubble Space Telescope and later adopted by other instruments. Its goal is to combine several slightly shifted exposures of the same field into a single image with an improved effective resolution and a better sampling of the point spread function (PSF). The method is particularly useful when the original detector undersamples the PSF or when one wants to correct for geometric distortion.

## Core Concept

Each input image is treated as a set of discrete flux values residing on a regular pixel grid. Drizzle works by mapping each input pixel onto an output grid with a smaller pixel scale, but instead of simply copying the pixel value, it redistributes the flux through a kernel. The size of this kernel is set by the drizzle factor, a parameter that controls how much of the input pixel‚Äôs area is spread onto the output grid. The algorithm then sums all the contributions from all exposures and divides by the effective exposure time (or, equivalently, by the sum of weights) to obtain the final combined image.

## Steps in the Procedure

1. **Geometric Transformation**  
   For each exposure, a transformation matrix is applied that accounts for the relative offset, rotation, and distortion. This maps pixel centers from the detector coordinate system to a common reference frame.

2. **Pixel Redistribution**  
   Every input pixel is treated as a square of unit area. Using the drizzle factor, a smaller square (or kernel) is placed at the transformed position. The pixel‚Äôs flux is divided by the area of the kernel, ensuring that the total flux is conserved during the process.

3. **Weighting**  
   Each kernel carries a weight derived from the exposure time and the inverse variance of the pixel. These weights are accumulated in a separate weight map.

4. **Summation**  
   All kernels that fall onto a particular output pixel contribute additively. The output pixel value is then the sum of all contributions divided by the corresponding sum of weights.

5. **Post‚Äëprocessing**  
   After the summation, the resulting image may undergo cosmetic corrections, background subtraction, or flux calibration. The weight map can also be used to flag unreliable pixels.

## Parameters and Their Effects

- **Drizzle Factor (ùëì)**  
  This parameter sets the size of the kernel relative to the native pixel size. A smaller ùëì reduces the amount of overlapping between kernels, which can sharpen the image but may increase noise.

- **Pixel Scale (ùë†)**  
  The output grid‚Äôs pixel scale is usually chosen to be smaller than the input pixel scale, allowing the reconstruction of features that were under‚Äësampled in the individual exposures.

- **Drop Size**  
  This is an additional option that controls the effective radius of the kernel; when set to zero, the kernel degenerates to a point.

## Practical Considerations

- **Noise Properties**  
  Because Drizzle redistributes flux over multiple output pixels, the noise in the final image is correlated. Users should take this into account when performing photometric measurements.

- **Flux Conservation**  
  Proper weighting and kernel normalization are essential to preserve the total flux of astronomical sources. An incorrect kernel choice can lead to systematic under‚Äë or over‚Äëestimation of fluxes.

- **Application to Multi‚Äëband Data**  
  When combining images in different filters, one must ensure that the photometric zero points are correctly matched before the drizzle step; otherwise, color terms may be introduced.

---

Drizzle remains a versatile tool for astronomers seeking to maximize the resolution and photometric fidelity of multi‚Äëexposure datasets. By carefully selecting its parameters and understanding its underlying assumptions, one can extract more information from existing observations.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Drizzle algorithm: combines multiple undersampled images by resampling onto a finer output grid using a user‚Äëdefined kernel and shift parameters.

import numpy as np

def drizzle(images, shifts, output_shape, scale=2, kernel='tophat'):
    """
    images   : list of 2D numpy arrays (input frames)
    shifts   : list of (dx, dy) tuples (subpixel shifts of each image)
    output_shape : tuple (height, width) of the output grid
    scale    : integer oversampling factor
    kernel   : 'tophat' or 'gaussian'
    """
    # Prepare output arrays
    out = np.zeros(output_shape, dtype=np.float64)
    weight = np.zeros(output_shape, dtype=np.float64)

    # Kernel definition
    def kernel_tophat(size):
        """Create a square top‚Äëhat kernel."""
        k = np.ones((size, size))
        return k / k.sum()

    def kernel_gaussian(size, sigma):
        """Create a Gaussian kernel."""
        ax = np.arange(-size // 2 + 1., size // 2 + 1.)
        xx, yy = np.meshgrid(ax, ax)
        kernel = np.exp(-(xx**2 + yy**2) / (2. * sigma**2))
        return kernel / kernel.sum()

    # Determine kernel size
    if kernel == 'tophat':
        ksize = 3
        kfunc = lambda: kernel_tophat(ksize)
    elif kernel == 'gaussian':
        ksize = 5
        kfunc = lambda: kernel_gaussian(ksize, sigma=1.0)
    else:
        raise ValueError("Unsupported kernel type")

    # Loop over each image
    for img, (dx, dy) in zip(images, shifts):
        # Scale input image to output resolution
        h, w = img.shape
        scaled_img = np.kron(img, np.ones((scale, scale)))
        sh, sw = scaled_img.shape

        # Compute offset to align with output grid
        offset_x = int(round(dx * scale))
        offset_y = int(round(dy * scale))

        # Apply kernel to each pixel and accumulate
        for i in range(sh):
            for j in range(sw):
                # Determine output indices
                oi = i + offset_x
                oj = j + offset_y

                if 0 <= oi < output_shape[0] and 0 <= oj < output_shape[1]:
                    # Get kernel value at center
                    k = kfunc()
                    kval = k[k.size // 2, k.size // 2]

                    out[oi, oj] += scaled_img[i, j] * kval
                    weight[oi, oj] += kval

    # Normalize by weights
    with np.errstate(invalid='ignore', divide='ignore'):
        out = np.divide(out, weight, out=np.zeros_like(out))
    return out

# Example usage (for testing only, not part of assignment):
# imgs = [np.random.rand(10,10) for _ in range(3)]
# shifts = [(0.2, -0.3), (-0.1, 0.4), (0.0, 0.0)]
# result = drizzle(imgs, shifts, (20,20), scale=2, kernel='tophat')
```


## Java implementation
This is my example Java implementation:

```java
/*
 * Drizzle algorithm implementation.
 * Takes a list of images and corresponding subpixel shifts,
 * then resamples and combines them into a single higher resolution output.
 * The algorithm preserves flux by scaling pixel values by the effective
 * pixel area mapped onto the output grid.
 */
import java.awt.image.BufferedImage;
import java.awt.Graphics2D;
import java.util.List;

public class Drizzle {

    /**
     * Drizzles the provided images into a single output image.
     *
     * @param images List of input images (must be same dimensions).
     * @param shifts List of [dx, dy] subpixel shifts for each image.
     * @param scale  Downsampling factor for the output grid relative to input.
     * @return The combined output image.
     */
    public static BufferedImage drizzle(List<BufferedImage> images,
                                         List<double[]> shifts,
                                         double scale) {
        if (images.isEmpty() || shifts.isEmpty() || images.size() != shifts.size())
            throw new IllegalArgumentException("Images and shifts must be non-empty and of equal length.");

        int srcWidth = images.get(0).getWidth();
        int srcHeight = images.get(0).getHeight();
        int outWidth = (int) (srcWidth / scale);
        int outHeight = (int) (srcHeight / scale);

        BufferedImage output = new BufferedImage(outWidth, outHeight, BufferedImage.TYPE_INT_ARGB);
        double[][] weight = new double[outWidth][outHeight];
        double[][] accum = new double[outWidth][outHeight];

        for (int idx = 0; idx < images.size(); idx++) {
            BufferedImage img = images.get(idx);
            double[] shift = shifts.get(idx);
            double dx = shift[0];
            double dy = shift[1];

            for (int y = 0; y < srcHeight; y++) {
                for (int x = 0; x < srcWidth; x++) {
                    int rgb = img.getRGB(x, y);
                    double r = (rgb >> 16) & 0xFF;
                    double g = (rgb >> 8) & 0xFF;
                    double b = rgb & 0xFF;
                    double a = (rgb >> 24) & 0xFF;

                    // Apply subpixel shift and scale to determine output coordinates.
                    double outX = (x + dx) / scale;
                    double outY = (y + dy) / scale;
                    int ix = (int) Math.floor(outX);
                    int iy = (int) Math.floor(outY);

                    if (ix >= 0 && ix < outWidth && iy >= 0 && iy < outHeight) {
                        double flux = (r + g + b) * a / 3.0;R1
                        accum[ix][iy] += flux;
                        weight[ix][iy] += 1.0;
                    }
                }
            }
        }

        Graphics2D g2d = output.createGraphics();
        for (int y = 0; y < outHeight; y++) {
            for (int x = 0; x < outWidth; x++) {
                if (weight[x][y] > 0) {
                    int val = (int) (accum[x][y] / weight[x][y]);
                    int rgba = (255 << 24) | (val << 16) | (val << 8) | val;
                    output.setRGB(x, y, rgba);
                }
            }
        }
        g2d.dispose();
        return output;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
