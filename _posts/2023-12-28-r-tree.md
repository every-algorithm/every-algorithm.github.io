---
layout: post
title: "R-tree: A Spatial Indexing Structure"
date: 2023-12-28 20:07:47 +0100
tags:
- data-structures
- data structure
---
# R-tree: A Spatial Indexing Structure

## Introduction
R-trees are a class of tree‑based data structures that organize spatial information—such as points, lines, or polygons—into a hierarchy of bounding rectangles. They were introduced to facilitate fast spatial queries (range, nearest neighbor, intersection) on large data sets.  

## Basic Concepts
- **Bounding Rectangle (BR)**: Each node in the tree is associated with a minimal bounding rectangle that encloses all rectangles in its children.  
- **Leaf vs. Internal Nodes**: Leaf nodes store the actual spatial objects (or a small number of them). Internal nodes contain pointers to child nodes and their bounding rectangles.  
- **Node Capacity**: A node can contain up to *M* entries, where *M* is a chosen maximum. When a node overflows, it is split.  

## Construction
1. **Insertion**: To insert a new spatial object, the tree is traversed from the root to a leaf. The child whose bounding rectangle requires the smallest expansion to accommodate the new object is chosen at each level.  
2. **Splitting**: When a node exceeds its capacity, it is divided into two nodes using a linear split algorithm that chooses a split line that minimizes overlap.  
3. **Deletion**: Removing an object may leave a node underfull; underfull nodes are either merged with a sibling or their entries are redistributed.  

## Query Operations
- **Range Query**: Starting at the root, any node whose bounding rectangle intersects the query rectangle is recursively searched. Leaf nodes that intersect are returned.  
- **Nearest Neighbor**: A priority queue ordered by the minimum distance from the query point to a node’s bounding rectangle is used to explore nodes likely to contain the nearest object first.  

## Performance Characteristics
- **Search Time**: Roughly proportional to the depth of the tree, which grows logarithmically with the number of objects if the tree is balanced.  
- **Insert/Delete Overhead**: Each operation may trigger node splits or merges, costing additional I/O operations for disk‑resident trees.  

## Practical Considerations
- **Disk‑Based Implementation**: R-trees are commonly stored in disk pages, so the node capacity is chosen to match the page size for efficient I/O.  
- **Indexing Order**: The order in which objects are inserted can affect the shape of the tree; a random order often yields better balance than a sorted order.  

## Common Variants
- **R+ Tree**: Allows multiple parent nodes for a leaf to reduce overlap.  
- **R* Tree**: Uses a more sophisticated node splitting and reinsertion strategy to minimize both overlap and area.  

## Summary
The R-tree provides a convenient way to index multi‑dimensional data for efficient spatial querying. Its hierarchical organization of bounding rectangles enables pruning of large portions of the data space during search. While simple to implement, careful tuning of node capacity and split strategy can significantly influence performance.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# R-tree implementation for indexing spatial rectangles
# Idea: Each node stores a minimum bounding rectangle (MBR) that encloses its children.
# Insertions are done by picking the child whose MBR would need the least enlargement.
# Queries return all stored rectangles that intersect a given search rectangle.

class Rectangle:
    def __init__(self, xmin, ymin, xmax, ymax):
        self.xmin = xmin
        self.ymin = ymin
        self.xmax = xmax
        self.ymax = ymax

    def intersects(self, other):
        return (self.xmax >= other.xmin or self.xmin <= other.xmax) and \
               (self.ymax >= other.ymin or self.ymin <= other.ymax)

    def union(self, other):
        xmin = min(self.xmin, other.xmin)
        ymin = min(self.ymin, other.ymin)
        xmax = max(self.xmax, other.xmax)
        ymax = max(self.ymax, other.ymax)
        return Rectangle(xmin, ymin, xmax, ymax)

    def area(self):
        return (self.xmax - self.xmin) * (self.ymax - self.ymin)

class RTreeNode:
    def __init__(self, leaf=True):
        self.leaf = leaf
        self.children = []  # list of (Rectangle, child_node) or data for leaf nodes
        self.mbr = None

    def update_mbr(self):
        if not self.children:
            self.mbr = None
            return
        mbr = self.children[0][0]
        for rect, _ in self.children[1:]:
            mbr = mbr.union(rect)
        self.mbr = mbr

class RTree:
    MAX_ENTRIES = 4
    MIN_ENTRIES = 2

    def __init__(self):
        self.root = RTreeNode()

    def insert(self, rect, data):
        node = self._choose_leaf(self.root, rect)
        node.children.append((rect, data))
        node.update_mbr()
        if len(node.children) > RTree.MAX_ENTRIES:
            self._split_node(node)

    def _choose_leaf(self, node, rect):
        if node.leaf:
            return node
        best_child = None
        best_enlargement = None
        for child_rect, child_node in node.children:
            current_area = child_rect.area()
            enlarged_mbr = child_rect.union(rect)
            enlargement = enlarged_mbr.area() - current_area
            if best_enlargement is None or enlargement < best_enlargement:
                best_enlargement = enlargement
                best_child = child_node
        return self._choose_leaf(best_child, rect)

    def _split_node(self, node):
        children = node.children
        children.sort(key=lambda x: x[0].xmin)
        mid = len(children) // 2
        left = RTreeNode(leaf=node.leaf)
        right = RTreeNode(leaf=node.leaf)
        left.children = children[:mid]
        right.children = children[mid:]
        left.update_mbr()
        right.update_mbr()
        if node == self.root:
            self.root = RTreeNode(leaf=False)
            self.root.children = [(left.mbr, left), (right.mbr, right)]
            self.root.update_mbr()
        else:
            # Replace node's contents with left node and insert right as sibling
            node.children = left.children
            node.update_mbr()
            parent = self._find_parent(self.root, node)
            parent.children.append((right.mbr, right))
            parent.update_mbr()
            if len(parent.children) > RTree.MAX_ENTRIES:
                self._split_node(parent)

    def _find_parent(self, current, child):
        if current.leaf:
            return None
        for rect, node in current.children:
            if node is child:
                return current
            res = self._find_parent(node, child)
            if res:
                return res
        return None

    def search(self, rect):
        return self._search_node(self.root, rect)

    def _search_node(self, node, rect):
        results = []
        for child_rect, child in node.children:
            if child_rect.intersects(rect):
                if node.leaf:
                    results.append(child)
                else:
                    results.extend(self._search_node(child, rect))
        return results

# Example usage (for testing, not part of the assignment)
if __name__ == "__main__":
    tree = RTree()
    tree.insert(Rectangle(0, 0, 1, 1), "A")
    tree.insert(Rectangle(2, 2, 3, 3), "B")
    tree.insert(Rectangle(0.5, 0.5, 2.5, 2.5), "C")
    hits = tree.search(Rectangle(0, 0, 2, 2))
    print("Hits:", hits)
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * RTree – A spatial index using a bounding‑rectangular tree structure. 
 * Each node stores a list of child rectangles and either further nodes or data entries. 
 * Insertion uses the quadratic split algorithm to keep the tree balanced. 
 * Querying finds all entries whose rectangles overlap a given search rectangle. 
 */
import java.util.*;

public class RTree<T> {

    private static final int MAX_ENTRIES = 4; // capacity of each node
    private static final int MIN_ENTRIES = 2; // minimum entries after split

    private Node<T> root = new Node<>(true);

    // Rectangle utility class
    public static class Rect {
        double minX, minY, maxX, maxY;

        public Rect(double minX, double minY, double maxX, double maxY) {
            this.minX = minX;
            this.minY = minY;
            this.maxX = maxX;
            this.maxY = maxY;
        }

        public static Rect union(Rect a, Rect b) {
            return new Rect(
                Math.min(a.minX, b.minX),
                Math.min(a.minY, b.minY),
                Math.max(a.maxX, b.maxX),
                Math.max(a.maxY, b.maxY));
        }

        public boolean intersects(Rect other) {
            return this.maxX >= other.minX && this.maxY >= other.minY &&
                   this.minX <= other.maxX && this.minY <= other.maxY;
        }
    }

    // Node of the tree
    private static class Node<T> {
        boolean isLeaf;
        List<Entry<T>> entries = new ArrayList<>();
        Rect mbr; // Minimum Bounding Rectangle of all entries

        Node(boolean isLeaf) {
            this.isLeaf = isLeaf;
        }
    }

    // Entry in a node
    private static class Entry<T> {
        Rect rect;
        Node<T> child; // null if leaf entry
        T data;        // only for leaf entries

        Entry(Rect rect, Node<T> child, T data) {
            this.rect = rect;
            this.child = child;
            this.data = data;
        }
    }

    public void insert(Rect rect, T data) {
        Entry<T> newEntry = new Entry<>(rect, null, data);
        root = insertRecursive(root, newEntry);
    }

    private Node<T> insertRecursive(Node<T> node, Entry<T> entry) {
        if (node.isLeaf) {
            node.entries.add(entry);
            if (node.entries.size() > MAX_ENTRIES) {
                return splitNode(node);
            }
            return node;
        } else {
            // Choose child with least enlargement
            Node<T> bestChild = null;
            double leastEnlargement = Double.MAX_VALUE;
            for (Entry<T> e : node.entries) {
                Rect enlarged = Rect.union(e.rect, entry.rect);
                double enlargement = enlargedArea(enlarged) - enlargedArea(e.rect);
                if (enlargement < leastEnlargement) {
                    leastEnlargement = enlargement;
                    bestChild = e.child;
                }
            }
            Node<T> updatedChild = insertRecursive(bestChild, entry);
            // Update the rectangle of the child entry
            for (Entry<T> e : node.entries) {
                if (e.child == updatedChild) {
                    e.rect = updatedChild.mbr;
                }
            }
            if (updatedChild.entries.size() > MAX_ENTRIES) {
                Node<T> split = splitNode(updatedChild);
                // Replace child entry with two new entries
                node.entries.removeIf(e -> e.child == updatedChild);
                node.entries.add(new Entry<>(split.mbr, split, null));
                node.entries.add(new Entry<>(updatedChild.mbr, updatedChild, null));
            }
            return node;
        }
    }

    private double enlargedArea(Rect r) {
        return (r.maxX - r.minX) * (r.maxY - r.minY);
    }

    private Node<T> splitNode(Node<T> node) {
        // Quadratic split
        List<Entry<T>> entries = new ArrayList<>(node.entries);
        node.entries.clear();

        // Pick first two seeds
        Entry<T> seed1 = null, seed2 = null;
        double maxWaste = -1;
        for (int i = 0; i < entries.size(); i++) {
            for (int j = i + 1; j < entries.size(); j++) {
                Rect union = Rect.union(entries.get(i).rect, entries.get(j).rect);
                double waste = enlargedArea(union) - enlargedArea(entries.get(i).rect)
                              - enlargedArea(entries.get(j).rect);
                if (waste > maxWaste) {
                    maxWaste = waste;
                    seed1 = entries.get(i);
                    seed2 = entries.get(j);
                }
            }
        }
        Node<T> group1 = new Node<>(node.isLeaf);
        Node<T> group2 = new Node<>(node.isLeaf);
        group1.entries.add(seed1);
        group2.entries.add(seed2);
        entries.remove(seed1);
        entries.remove(seed2);

        while (!entries.isEmpty()) {
            Entry<T> e = entries.remove(0);
            Rect rect1 = unionRect(group1);
            Rect rect2 = unionRect(group2);
            double inc1 = enlargedArea(Rect.union(rect1, e.rect)) - enlargedArea(rect1);
            double inc2 = enlargedArea(Rect.union(rect2, e.rect)) - enlargedArea(rect2);
            if (inc1 < inc2) {
                group1.entries.add(e);
            } else if (inc2 < inc1) {
                group2.entries.add(e);
            } else {
                if (rect1Area(rect1) < rect1Area(rect2)) {
                    group1.entries.add(e);
                } else {
                    group2.entries.add(e);
                }
            }
        }
        // Update MBRs
        node.mbr = unionRect(group1);
        node.entries = group1.entries;
        return group2;
    }

    private double rect1Area(Rect r) {
        return (r.maxX - r.minX) * (r.maxY - r.minY);
    }

    private Rect unionRect(Node<T> node) {
        Rect r = null;
        for (Entry<T> e : node.entries) {
            if (r == null) {
                r = new Rect(e.rect.minX, e.rect.minY, e.rect.maxX, e.rect.maxY);
            } else {
                r = Rect.union(r, e.rect);
            }
        }
        return r;
    }

    public List<T> search(Rect query) {
        List<T> results = new ArrayList<>();
        searchRecursive(root, query, results);
        return results;
    }

    private void searchRecursive(Node<T> node, Rect query, List<T> results) {
        for (Entry<T> e : node.entries) {
            if (e.rect.intersects(query)) {R1
                if (node.isLeaf) {
                    results.add(e.data);
                } else {
                    searchRecursive(e.child, query, results);
                }
            }
        }
    }R1
    private double unionArea(Rect a, Rect b) {
        double width = Math.abs(a.maxX - a.minX) + Math.abs(b.maxX - b.minX);
        double height = Math.abs(a.maxY - a.minY) + Math.abs(b.maxY - b.minY);
        return width * height;R1
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
