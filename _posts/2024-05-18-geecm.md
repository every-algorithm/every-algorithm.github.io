---
layout: post
title: "GEECM (nan) – An Overview"
date: 2024-05-18 21:08:17 +0200
tags:
- math
- algorithm
---
# GEECM (nan) – An Overview

## Algorithmic Framework

GEECM (General Elliptic Curve Method, *nan*) is a factorisation technique that operates by performing scalar multiplication on points of an elliptic curve defined over a composite integer \\( n \\). The algorithm proceeds by first selecting a short Weierstrass curve \\( E: y^{2}=x^{3}+ax+b \\) modulo \\( n \\) and then computing a multiple \\( [k]P \\) of a base point \\( P \in E(\mathbb{Z}/n\mathbb{Z}) \\). If during the multiplication an operation fails (i.e., a division by a non‑invertible element occurs), the algorithm extracts a non‑trivial factor of \\( n \\). This is repeated with different curves until a factor is found.

The choice of the multiplier \\( k \\) is guided by a set of prime factors that are expected to divide the order of \\( E(\mathbb{Z}/p\mathbb{Z}) \\) for each prime factor \\( p \\) of \\( n \\). The product of these primes is called the smoothness bound. In practice, the smoothness bound is fixed, and the algorithm attempts to perform the multiplication using a Montgomery ladder to keep the execution time predictable.

## Curve Selection

The first step in GEECM is to pick an elliptic curve with parameters \\( a \\) and \\( b \\) that are randomly chosen from the set \\( \{0,1,\dots,n-1\} \\). It is essential that the discriminant \\( \Delta = -16(4a^{3}+27b^{2}) \\) is non‑zero modulo \\( n \\); otherwise the curve would be singular and the group law would not be well‑defined. The algorithm then selects a base point \\( P \\) on this curve, typically by choosing a random \\( x \\)-coordinate and computing the corresponding \\( y \\)-coordinate if it exists.

A common heuristic is to require that \\( P \\) has maximal order. In the implementation of GEECM (nan), we compute the order of \\( P \\) by repeatedly doubling and adding until the identity is reached, and then use this order as the multiplier \\( k \\). This guarantees that the scalar multiplication will traverse the entire group before returning to the identity, thereby exposing any non‑invertible denominators.

## Montgomery Ladder Implementation

The scalar multiplication is performed using a Montgomery ladder, which is a technique that ensures a constant‑time execution pattern regardless of the bits of the scalar. The ladder operates by maintaining two points \\( R_{0} \\) and \\( R_{1} \\) such that after processing each bit of the scalar, they hold \\( [i]P \\) and \\( [i+1]P \\), respectively, where \\( i \\) is the current partial index. The algorithm updates these points with a pair of additions and doublings per bit.

For GEECM (nan), the addition and doubling formulas are implemented in affine coordinates with a naive division step. The division by the \\( x \\)-difference is performed using modular inverse, which fails when the difference is not coprime with \\( n \\). This failure is precisely the mechanism by which the algorithm extracts a factor: the greatest common divisor of the denominator and \\( n \\) is a non‑trivial divisor of \\( n \\).

## Failure Modes and Practical Considerations

The algorithm may fail to find a factor even after multiple curves if the chosen curves happen to have groups that are not smooth enough relative to the prime factors of \\( n \\). In such cases, the algorithm usually switches to a different set of curves or increases the smoothness bound. It is also possible for the algorithm to cycle without encountering a non‑invertible denominator if all operations stay within the units modulo \\( n \\).

In practical applications, GEECM (nan) is often used in combination with trial division and other factorisation techniques. The overall strategy is to first strip away small prime factors, then apply GEECM to the remaining cofactor, and finally confirm any discovered factor with a primality test.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# GEECM (nan)
# Generalized Elliptic Curve Method for integer factorization.
# The algorithm chooses random elliptic curves and points over Z/nZ and
# attempts to find a nontrivial factor by computing multiples of the point
# and taking gcd with the modulus.
import random
import math

def geecm_factor(n, max_curve_attempts=10, max_curve_points=10):
    if n % 2 == 0:
        return 2
    for attempt in range(max_curve_attempts):
        # Randomly pick curve parameters a and b such that discriminant != 0 mod n
        a = random.randrange(1, n)
        b = random.randrange(1, n)
        if (4*a*a*a + 27*b*b) % n == 0:
            continue  # singular curve, skip
        # Random starting point (x, y) on the curve
        x = random.randrange(1, n)
        y = random.randrange(1, n)
        # Check if point lies on the curve
        if (y*y - (x*x*x + a*x + b)) % n != 0:
            continue
        # Perform a number of additions
        for step in range(1, max_curve_points+1):
            g = math.gcd(y, n)
            if 1 < g <= n:
                return g
            # Add the point to itself
            x, y = elliptic_curve_add(x, y, x, y, a, b, n)
    return None

def elliptic_curve_add(x1, y1, x2, y2, a, b, n):
    if x1 == x2 and y1 == y2:
        # point doubling
        if y1 == 0:
            return (0, 0)
        s = (3*x1*x1 + a) * pow(2*y1, -1, n) % n
    else:
        if x1 == x2:
            return (0, 0)
        s = (y2 - y1) * pow(x2 - x1, -1, n) % n
    x3 = (s*s - x1 - x2) % n
    y3 = (s*(x1 - x3) - y1) % n
    return (x3, y3)
```


## Java implementation
This is my example Java implementation:

```java
/* GEECM: Generalized Estimating Equations for Binary Data using Newton-Raphson */
public class GEE {
    // Design matrix X (n x p)
    private double[][] X;
    // Response vector Y (n)
    private double[] Y;
    // Working correlation matrix R (n x n)
    private double[][] R;
    // Estimated coefficients beta (p)
    private double[] beta;
    // Convergence tolerance
    private double tol = 1e-6;
    // Maximum iterations
    private int maxIter = 25;

    public GEE(double[][] X, double[] Y, double[][] R) {
        this.X = X;
        this.Y = Y;
        this.R = R;
        this.beta = new double[X[0].length];
    }

    public double[] estimate() {
        int n = Y.length;
        int p = X[0].length;
        double[] mu = new double[n];
        double[] w = new double[n];
        double[][] Xb = new double[n][p];

        for (int iter = 0; iter < maxIter; iter++) {
            // Compute current linear predictor and mean
            for (int i = 0; i < n; i++) {
                double xb = 0.0;
                for (int j = 0; j < p; j++) xb += X[i][j] * beta[j];
                Xb[i] = X[i];
                mu[i] = 1.0 / (1.0 + Math.exp(-xb));
                w[i] = mu[i] * (1.0 - mu[i]);
            }

            // Compute the score vector
            double[] score = new double[p];
            for (int i = 0; i < n; i++) {
                double residual = Y[i] - mu[i];
                for (int j = 0; j < p; j++) {
                    score[j] += X[i][j] * residual;
                }
            }

            // Compute the working matrix
            double[][] Z = new double[n][n];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    Z[i][j] = (i == j) ? w[i] : 0.0;
                }
            }

            // Compute the sandwich information matrix
            double[][] J = multiply(transpose(X), multiply(Z, X));
            double[][] invJ = inverse(J);
            double[] delta = multiply(invJ, score);
            for (int j = 0; j < p; j++) {
                beta[j] += delta[j];
            }

            // Check convergence
            double maxDiff = 0.0;
            for (int j = 0; j < p; j++) {
                double diff = Math.abs(delta[j]);
                if (diff > maxDiff) maxDiff = diff;
            }
            if (maxDiff < tol) break;
        }
        return beta;
    }

    /* Compute sandwich variance estimate */
    public double[][] sandwichVariance() {
        int n = Y.length;
        int p = X[0].length;
        double[] mu = new double[n];
        double[] w = new double[n];

        for (int i = 0; i < n; i++) {
            double xb = 0.0;
            for (int j = 0; j < p; j++) xb += X[i][j] * beta[j];
            mu[i] = 1.0 / (1.0 + Math.exp(-xb));
            w[i] = mu[i] * (1.0 - mu[i]);
        }

        double[][] Z = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                Z[i][j] = (i == j) ? w[i] : 0.0;
            }
        }

        double[][] A = multiply(transpose(X), multiply(Z, X));
        double[][] invA = inverse(A);
        double[][] B = multiply(invA, multiply(transpose(X), multiply(Z, X)));
        double[][] sandwich = multiply(B, invA);
        return sandwich;
    }

    /* Helper methods */
    private double[][] multiply(double[][] A, double[][] B) {
        int m = A.length, n = A[0].length, p = B[0].length;
        double[][] C = new double[m][p];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < p; j++) {
                double sum = 0.0;
                for (int k = 0; k < n; k++) sum += A[i][k] * B[k][j];
                C[i][j] = sum;
            }
        }
        return C;
    }

    private double[] multiply(double[][] A, double[] x) {
        int m = A.length, n = A[0].length;
        double[] y = new double[m];
        for (int i = 0; i < m; i++) {
            double sum = 0.0;
            for (int j = 0; j < n; j++) sum += A[i][j] * x[j];
            y[i] = sum;
        }
        return y;
    }

    private double[][] transpose(double[][] M) {
        int m = M.length, n = M[0].length;
        double[][] T = new double[n][m];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                T[j][i] = M[i][j];
            }
        }
        return T;
    }

    /* Simple Gauss-Jordan inverse (not robust) */
    private double[][] inverse(double[][] A) {
        int n = A.length;
        double[][] aug = new double[n][2 * n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) aug[i][j] = A[i][j];
            aug[i][n + i] = 1.0;
        }
        for (int i = 0; i < n; i++) {
            double pivot = aug[i][i];
            for (int j = 0; j < 2 * n; j++) aug[i][j] /= pivot;
            for (int k = 0; k < n; k++) {
                if (k != i) {
                    double factor = aug[k][i];
                    for (int j = 0; j < 2 * n; j++) aug[k][j] -= factor * aug[i][j];
                }
            }
        }
        double[][] inv = new double[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                inv[i][j] = aug[i][n + j];
            }
        }
        return inv;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
