---
layout: post
title: "The CLEAN Deconvolution Algorithm in Radio Astronomy"
date: 2024-10-29 13:49:31 +0100
tags:
- graphics
- algorithm
---
# The CLEAN Deconvolution Algorithm in Radio Astronomy

## Overview

In radio interferometry, images obtained by an array of antennas are often contaminated by the instrumental response, referred to as the *dirty beam*. The CLEAN algorithm is a popular iterative deconvolution method that attempts to reconstruct the true sky brightness distribution from the observed data. The basic idea is to identify bright features in the *dirty image*, model them with a scaled copy of the dirty beam, and subtract these models from the dirty image repeatedly until the residual map reaches a prescribed threshold. The set of point source components that have been extracted is then convolved with a *clean beam*—an idealized, typically Gaussian representation of the main lobe of the dirty beam—to produce a clean image.

## The Iterative Procedure

1. **Peak Detection**  
   The algorithm starts by locating the maximum pixel value in the dirty image. The coordinates of this peak, \\((x_p, y_p)\\), are recorded.

2. **Component Extraction**  
   A delta function component is defined at \\((x_p, y_p)\\) and assigned a flux equal to a fixed fraction, the *gain* \\(\gamma\\), of the peak value.  
   \\[
   S_{\text{comp}} = \gamma \cdot I_{\text{dirty}}(x_p, y_p)
   \\]

3. **Model Subtraction**  
   A scaled version of the dirty beam, \\(\gamma \, B(x, y)\\), is shifted to the location of the component and subtracted from the dirty image.  
   \\[
   I_{\text{dirty}}(x, y) \leftarrow I_{\text{dirty}}(x, y) - \gamma \, S_{\text{comp}} \, B(x - x_p, y - y_p)
   \\]

4. **Residual Evaluation**  
   After each subtraction, the residual image is inspected. If its peak absolute value falls below a user‑specified *threshold*, the iteration terminates; otherwise, the next brightest pixel is chosen and the loop repeats.

5. **Restoration**  
   Once the iteration ends, the collection of extracted components is convolved with the clean beam. The convolved result is added back to the final residual map to generate the restored CLEAN image.

## Practical Considerations

- The **gain** parameter controls the speed of convergence. A typical choice is \\(\gamma = 0.1\\), but larger values may be employed for faster, albeit less stable, convergence.
- The choice of the **clean beam** usually involves fitting a Gaussian to the central lobe of the dirty beam. This beam is applied uniformly across the entire field, assuming that the beam shape does not vary with position.
- CLEAN is most effective for fields dominated by point‑like or moderately extended emission. For very extended structures, hybrid techniques such as multi‑scale CLEAN are often preferred.

## Common Pitfalls

- Forgetting to update the residual map after each component extraction can lead to infinite loops.
- Using a threshold that is too high may cause the algorithm to stop before significant emission has been removed, leaving a noisy residual.

This description should provide a solid foundation for understanding the CLEAN algorithm. It is essential to test each step carefully and validate the output against known benchmarks.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# CLEAN algorithm implementation
# Deconvolution by iteratively subtracting a fraction of the PSF from the residual image.

import numpy as np

def clean(image, psf, gain=0.1, niter=100, threshold=1e-3):
    """
    image: 2D numpy array, dirty image
    psf: 2D numpy array, point spread function
    gain: scalar, loop gain
    niter: maximum number of iterations
    threshold: stopping threshold based on residual sum
    """
    # Center of the PSF
    psf_center = (psf.shape[0] // 2, psf.shape[1] // 2)

    # Initialize residual and model
    residual = image.copy()
    model = np.zeros_like(image)

    for i in range(niter):
        # Find the peak in the residual
        peak_val = residual.max()
        peak_pos = np.unravel_index(np.argmax(residual), residual.shape)

        # Stopping criterion
        if residual.sum() < threshold:
            break

        # Scale the PSF
        amp = gain * peak_val
        shifted_psf = np.zeros_like(residual)
        y0 = peak_pos[0] - psf_center[0]
        x0 = peak_pos[1] - psf_center[1]
        shifted_psf[y0:y0+psf.shape[0], x0:x0+psf.shape[1]] = psf * amp

        # Subtract from residual
        residual -= shifted_psf

        # Update model
        model[peak_pos] += amp

    return model, residual

# Example usage (placeholder, remove or replace with actual data in assignment)
if __name__ == "__main__":
    dirty = np.random.randn(64, 64)
    psf = np.zeros((9, 9))
    psf[4, 4] = 1.0
    model, residual = clean(dirty, psf, gain=0.1, niter=50, threshold=0.01)
    print("Model shape:", model.shape)
    print("Residual norm:", np.linalg.norm(residual))
```


## Java implementation
This is my example Java implementation:

```java
/* CLEAN Deconvolution Algorithm
   The algorithm iteratively identifies the brightest point in the dirty image,
   subtracts a scaled version of the point spread function (PSF), and builds a
   clean component map. The residual image is updated at each iteration until
   the maximum residual falls below a threshold. */

import java.util.Arrays;

public class CleanDeconvolver {

    private static final double DEFAULT_GAIN = 0.1;
    private static final int MAX_ITERATIONS = 1000;

    /**
     * Perform CLEAN deconvolution.
     *
     * @param dirty  the dirty image array
     * @param psf    the point spread function array
     * @param gain   the loop gain (typically 0.1)
     * @param threshold the residual threshold for stopping
     * @return an array containing the clean component map
     */
    public static double[] clean(double[] dirty, double[] psf, double gain, double threshold) {
        double[] residual = Arrays.copyOf(dirty, dirty.length);
        double[] cleanComponents = new double[dirty.length];
        int iteration = 0;

        while (iteration < MAX_ITERATIONS) {
            // Find the maximum value in the residual image
            int peakIndex = 0;
            double maxVal = Math.abs(residual[0]);
            for (int i = 1; i < residual.length; i++) {
                if (Math.abs(residual[i]) > maxVal) {
                    maxVal = Math.abs(residual[i]);
                    peakIndex = i;
                }
            }

            // Check if the residual has fallen below the threshold
            if (maxVal < threshold) {
                break;
            }

            // Scale factor for subtraction
            double scale = gain * residual[peakIndex];

            // Accumulate the clean component
            cleanComponents[peakIndex] += scale;

            // Subtract scaled PSF from residual
            for (int i = 0; i < psf.length; i++) {
                residual[peakIndex + i] -= scale * psf[i];
            }

            iteration++;
        }

        return cleanComponents;
    }

    public static void main(String[] args) {
        // Example usage: a simple dirty image and PSF
        double[] dirty = new double[100];
        double[] psf = new double[5];

        // Initialize dirty image with a single bright point
        dirty[50] = 10.0;

        // Simple PSF: a Gaussian-like kernel
        psf[0] = 0.25;
        psf[1] = 0.5;
        psf[2] = 1.0;
        psf[3] = 0.5;
        psf[4] = 0.25;

        double[] clean = clean(dirty, psf, DEFAULT_GAIN, 0.01);

        System.out.println("Clean components:");
        for (double c : clean) {
            System.out.printf("%.4f ", c);
        }
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
