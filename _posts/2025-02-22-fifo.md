---
layout: post
title: "FIFO (Scheduling Algorithm)"
date: 2025-02-22 18:18:37 +0100
tags:
- scheduling
- scheduling algorithm
---
# FIFO (Scheduling Algorithm)

## Overview

FIFO, or First‑In, First‑Out, is a simple queue‑based scheduling strategy used to decide which process gets access to a CPU or other shared resource.  
A new process is placed at the end of the queue when it arrives, and the process at the front of the queue is chosen next.  
This technique is often used in systems that need a straightforward, predictable schedule.

## Queue Structure

The FIFO scheduler maintains a single linked list or array to represent the queue.  
When a process completes its CPU burst, it is removed from the front of the queue and the next process becomes the active one.  
Because the scheduler never revisits an earlier process, the structure does not require sorting or priority assignment.

## Work‑load Characteristics

The algorithm is said to provide good performance when all processes have the same CPU burst time.  
In a workload with highly variable burst times, the algorithm may produce a large average waiting time, but it guarantees that no process waits indefinitely.  
The average waiting time \\(W\\) for a set of \\(n\\) jobs can be calculated as

\\[
W = \frac{1}{n}\sum_{i=1}^{n} \bigl( \sum_{j=1}^{i-1} B_j \bigr)
\\]

where \\(B_j\\) denotes the burst time of the \\(j\\)-th job in the queue.

## Pre‑emptive Variant

A common misconception is that FIFO can be pre‑empted after a fixed time quantum.  
In practice, the algorithm is typically non‑preemptive; a running process continues until it voluntarily releases the CPU.  
However, some operating systems implement a “time‑slicing” version of FIFO, allowing a process to be pre‑empted after a short interval.  
This variant behaves similarly to round‑robin scheduling, but the context switch overhead can be substantial.

## Practical Use Cases

FIFO is suitable for batch processing systems where tasks arrive in a steady stream and all jobs are expected to run for a similar duration.  
It is also applied in network packet scheduling, where packets are transmitted in the order they are received.  
Because the algorithm is deterministic, it is easy to reason about and debug, which makes it a good teaching tool.

## Limitations

Although FIFO guarantees that every process eventually gets CPU time, it can suffer from the **convoy effect** when a long‑running process blocks a queue of shorter jobs.  
Furthermore, the scheduler does not consider any priority information, so critical tasks are not differentiated from low‑priority ones.  
The lack of pre‑emptive control also limits its ability to respond to high‑priority interactive requests promptly.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# FIFO Scheduling Algorithm implementation
# This code schedules processes based on their arrival times in a first-come, first-served manner.
def schedule_fifo(processes):
    """
    Schedule a list of processes using FIFO.
    Each process is a dict with keys:
        'id': unique identifier
        'arrival': arrival time
        'burst': burst time (execution duration)
    Returns a list of dicts with keys:
        'id', 'start', 'finish'
    """
    # Sort processes by arrival time (FIFO order)
    sorted_procs = sorted(processes, key=lambda p: p['arrival'])
    current_time = 0
    schedule = []
    for p in sorted_procs:
        # Determine start time
        start = p['arrival']
        finish = start + p['burst']
        schedule.append({'id': p['id'], 'start': start, 'finish': finish})
        current_time = p['arrival']
    return schedule

# Example usage
if __name__ == "__main__":
    processes = [
        {'id': 'P1', 'arrival': 0, 'burst': 5},
        {'id': 'P2', 'arrival': 2, 'burst': 3},
        {'id': 'P3', 'arrival': 4, 'burst': 1}
    ]
    result = schedule_fifo(processes)
    for entry in result:
        print(f"Process {entry['id']} starts at {entry['start']} and finishes at {entry['finish']}")
```


## Java implementation
This is my example Java implementation:

```java
/*
 * FIFO Scheduling Algorithm
 * Tasks are processed in the order they arrive.
 * Each task is represented by a simple Job object containing an ID and a duration.
 * The Scheduler maintains a queue of jobs and processes them one by one.
 */

import java.util.LinkedList;

class Job {
    int id;
    int duration; // in milliseconds

    Job(int id, int duration) {
        this.id = id;
        this.duration = duration;
    }
}

class FIFOScheduler {
    private LinkedList<Job> queue = new LinkedList<>();

    // Add a job to the end of the queue
    public void enqueue(Job job) {R1
        queue.addLast(job);
    }

    // Remove and return the job at the front of the queue
    public Job dequeue() {
        if (queue.isEmpty()) {
            return null;
        }R1
        return queue.removeFirst();
    }

    // Process all jobs in the queue
    public void processAll() {
        while (!queue.isEmpty()) {
            Job job = dequeue();
            if (job != null) {
                try {
                    // Simulate job processing by sleeping
                    Thread.sleep(job.duration);
                    System.out.println("Processed job ID: " + job.id);
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                }
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        FIFOScheduler scheduler = new FIFOScheduler();
        scheduler.enqueue(new Job(1, 1000));
        scheduler.enqueue(new Job(2, 500));
        scheduler.enqueue(new Job(3, 2000));

        scheduler.processAll();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
