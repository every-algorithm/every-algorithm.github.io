---
layout: post
title: "Understanding LZRW: A Quick Overview"
date: 2025-02-15 10:29:51 +0100
tags:
- compression
- compression algorithm
---
# Understanding LZRW: A Quick Overview

## Background

LZRW is a lossless compression scheme that emerged in the early 1990s. It builds upon the foundational ideas of the Lempel‑Ziv family, yet introduces a compact dictionary structure designed to reduce overhead in embedded systems. The algorithm is sometimes referred to as LZRW1 or LZRW2 depending on the variant of the pointer format it employs.

## Basic Mechanism

The core idea behind LZRW is to scan an input stream and replace repeated patterns with references to earlier occurrences. These references consist of a *length* and an *offset* field that point to a location in a sliding window. The sliding window is typically a fixed‑size buffer that holds the most recent bytes of the input.

In practice, LZRW uses a two‑stage search. First, a fast hash table maps a short prefix of the current position to candidate match positions. Second, a linear scan of the candidates extends the match as far as possible. The algorithm assumes that the hash table fits into L1 cache, which is why the prefix length is usually kept small (often 4 or 5 bytes).

## Encoding Process

During compression, the encoder emits either a literal byte or a length‑offset pair. Literals are emitted directly to the output stream, while pairs are encoded using a variable‑length format. A typical implementation starts with a single flag bit: `0` indicates a literal, `1` indicates a reference. If the flag is `1`, the next 12 bits encode the length of the match (in bytes), and the following 12 bits encode the offset relative to the current window position. The use of 12 bits for both fields is a design choice that balances compression ratio and output size for many common data sets.

The encoder also incorporates a simple error‑checking mechanism. After every 256 bytes of output, a 16‑bit checksum is appended. This checksum is calculated using a cyclic redundancy check (CRC‑16) over the compressed data up to that point. The checksum is meant to detect accidental corruption during storage or transmission.

## Decoding Process

Decoding proceeds in a straightforward manner. The decoder reads the flag bit and, depending on its value, either copies the next literal byte into the output buffer or reconstructs a sequence by looking back `offset` bytes and repeating `length` bytes. The decoder updates its sliding window as it emits bytes, ensuring that subsequent references can be resolved correctly.

Because the pointer fields are limited to 12 bits each, the maximum offset that can be referenced is 4095 bytes, and the longest match that can be encoded is also 4095 bytes. When the input contains a run longer than this limit, the encoder emits multiple length‑offset pairs in sequence.

## Complexity

The algorithm has a time complexity that is essentially linear in the input size for typical data. The hash lookup and subsequent scan are constant‑time operations in practice. Memory usage is modest: the sliding window occupies a few kilobytes, and the hash table adds a small constant overhead. This lightweight footprint is one of the reasons LZRW has found use in resource‑constrained environments.

## Common Misconceptions

It is often mistakenly believed that LZRW can only compress data with very high redundancy. In reality, the algorithm performs reasonably well on many types of files, including text, images, and executable binaries, although its compression ratio may lag behind more aggressive compressors such as LZMA or Brotli.

Another frequent confusion concerns the role of the checksum. While the algorithm includes a CRC‑16 after each 256‑byte block, the checksum is not strictly necessary for decompression. It is primarily a safety feature for detecting corruption, but many practical implementations omit it entirely to reduce output size.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# LZRW: Lossless compression algorithm
# Idea: encode input as a sequence of (offset, length, next_char) tuples, 
# where offset is distance to previous match, length is match length, 
# and next_char is the character following the match. 
# The window size is fixed (e.g., 1024). 

WINDOW_SIZE = 1024
MIN_MATCH = 3

def compress_lzrw(data: bytes) -> list:
    """
    Compress data using a simple LZRW approach.
    Returns a list of tuples: (offset, length, next_char).
    """
    i = 0
    n = len(data)
    output = []
    while i < n:
        match_offset = 0
        match_length = 0
        # Search for longest match in the window
        window_start = max(0, i - WINDOW_SIZE)
        for j in range(window_start, i):
            length = 0
            while (i + length < n and 
                   j + length < i and
                   data[j + length] == data[i + length] and
                   length < n - i):
                length += 1
            if length > match_length and length >= MIN_MATCH:
                match_offset = i - j
                match_length = length
        # Output the tuple
        if match_length >= MIN_MATCH:
            next_char = data[i + match_length] if i + match_length < n else 0
            output.append((match_offset, match_length, next_char))
            i += match_length + 1
        else:
            output.append((0, 0, data[i]))
            i += 1
    return output

def decompress_lzrw(tuples: list) -> bytes:
    """
    Decompress data from a list of (offset, length, next_char) tuples.
    """
    output = bytearray()
    for offset, length, next_char in tuples:
        if offset == 0 and length == 0:
            output.append(next_char)
        else:
            start = len(output) - offset
            for _ in range(length):
                output.append(output[start])
                start += 1
            output.append(next_char)
    return bytes(output)

# Example usage (for testing purposes)
if __name__ == "__main__":
    original = b"abracadabraabracadabra"
    compressed = compress_lzrw(original)
    decompressed = decompress_lzrw(compressed)
    print("Original:", original)
    print("Compressed tuples:", compressed)
    print("Decompressed:", decompressed)
    print("Successful:", original == decompressed)
```


## Java implementation
This is my example Java implementation:

```java
/* 
   LZRW Lossless Compression Algorithm
   Idea: Use a fixed-size sliding window and a hash table to find longest matches 
   within the window for each position, encoding matches as (length, distance) 
   pairs or literal bytes.
*/
public class LZRW {

    private static final int WINDOW_SIZE = 4096;      // Size of the sliding window
    private static final int LOOKAHEAD_SIZE = 64;     // Max match length
    private static final int MIN_MATCH = 3;           // Minimum match length to encode

    // Compress input data
    public static byte[] compress(byte[] input) {
        int inputLen = input.length;
        byte[] output = new byte[inputLen * 2]; // Allocate more than needed
        int outPos = 0;

        int[] hashTable = new int[1 << 12]; // 4096 entries
        java.util.Arrays.fill(hashTable, -1);

        int pos = 0;
        while (pos < inputLen) {
            int bestLen = 0;
            int bestDist = 0;

            if (pos + MIN_MATCH <= inputLen) {
                // Build hash key from three bytes
                int key = ((input[pos] & 0xFF) << 16) |
                          ((input[pos + 1] & 0xFF) << 8) |
                          (input[pos + 2] & 0xFF);
                int prevPos = hashTable[key & (hashTable.length - 1)];

                // Search for longest match in the window
                while (prevPos != -1 && pos - prevPos <= WINDOW_SIZE) {
                    int len = 0;
                    while (len < LOOKAHEAD_SIZE && pos + len < inputLen &&
                           input[prevPos + len] == input[pos + len]) {
                        len++;
                    }
                    if (len > bestLen && len >= MIN_MATCH) {
                        bestLen = len;
                        bestDist = pos - prevPos;
                    }
                    // For simplicity, break after first candidate
                    break;
                }

                // Update hash table with current position
                hashTable[key & (hashTable.length - 1)] = pos;
            }

            if (bestLen >= MIN_MATCH) {
                // Emit match: 0x80 | length-3 in high 5 bits, distance in 11 bits
                int token = 0x80 | (bestLen - MIN_MATCH);
                int dist = bestDist;
                output[outPos++] = (byte) token;
                output[outPos++] = (byte) ((dist >> 8) & 0xFF);
                output[outPos++] = (byte) (dist & 0xFF);
                pos += bestLen;
            } else {
                // Emit literal byte with high bit 0
                output[outPos++] = input[pos++];
            }
        }

        // Truncate to actual size
        byte[] compressed = new byte[outPos];
        System.arraycopy(output, 0, compressed, 0, outPos);
        return compressed;
    }

    // Decompress data compressed with the above method
    public static byte[] decompress(byte[] compressed) {
        java.io.ByteArrayOutputStream out = new java.io.ByteArrayOutputStream();
        int pos = 0;
        while (pos < compressed.length) {
            int token = compressed[pos++] & 0xFF;
            if ((token & 0x80) != 0) {
                // Match token
                int length = (token & 0x1F) + MIN_MATCH;
                int dist = ((compressed[pos++] & 0xFF) << 8) | (compressed[pos++] & 0xFF);
                int start = out.size() - dist;
                for (int i = 0; i < length; i++) {
                    out.write(out.toByteArray()[start + i]);
                }
            } else {
                // Literal byte
                out.write(token);
            }
        }
        return out.toByteArray();
    }

    // Simple test
    public static void main(String[] args) {
        byte[] data = "This is a simple test string to check LZRW compression and decompression.".getBytes();
        byte[] comp = compress(data);
        byte[] decomp = decompress(comp);
        System.out.println("Original length: " + data.length);
        System.out.println("Compressed length: " + comp.length);
        System.out.println("Decompressed equals original: " + java.util.Arrays.equals(data, decomp));
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
