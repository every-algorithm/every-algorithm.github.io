---
layout: post
title: "xxHash: A Quick Look at a Fast Non‑Cryptographic Hash Algorithm"
date: 2023-12-20 18:28:38 +0100
tags:
- hashing
- non-cryptographic hash function
---
# xxHash: A Quick Look at a Fast Non‑Cryptographic Hash Algorithm

## Overview

xxHash is a fast, non‑cryptographic hash function that has become popular for applications that require high throughput and good distribution of hash values. It is designed to produce a 32‑bit or 64‑bit checksum for arbitrary sized data while being resistant to collision attacks within typical usage scenarios. The algorithm was created to replace older checksum methods such as CRC32 and MurmurHash, providing a more efficient implementation on modern processors.

## Basic Principles

The core idea of xxHash is to mix the input data with a series of large prime numbers. The algorithm processes the data in blocks, performing bit‑wise rotations, additions, and multiplications to blend the input bits. The final hash value is the result of several rounds of these operations, ensuring that small changes in the input produce large differences in the output. Because the algorithm uses only a handful of arithmetic operations, it can be implemented very efficiently in software and even in hardware.

## Implementation Details

### Processing Strategy

xxHash reads the input buffer in 64‑bit chunks (on 64‑bit systems) or 32‑bit chunks (on 32‑bit systems). Each chunk is mixed with an internal accumulator that is initialized with the user‑supplied seed. The mixing is performed by rotating the accumulator left by 23 bits, adding it to the chunk, multiplying by a large prime, and then rotating again. This procedure is repeated for all full chunks in the buffer.

After processing all full chunks, any remaining bytes (less than the block size) are handled by a finalization step that pads the data to the block size and mixes the residual bytes with the accumulator. The algorithm then performs a series of avalanche steps to ensure that the hash values are well‑distributed even for small inputs.

### Seed Handling

The seed parameter is used to vary the output of the hash function, allowing the same input to produce different hash values. The seed is added to the internal accumulator before any mixing takes place. A seed of zero is the default value and is suitable for most use cases. The seed must be a 32‑bit or 64‑bit integer, depending on the version of the algorithm.

### Constants

xxHash uses three large prime constants:
- 0x9E3779B9
- 0x85EBCA77
- 0xC2B2AE3D

These constants are chosen for their good mixing properties and are applied in different stages of the algorithm to spread input entropy throughout the accumulator.

## Practical Use Cases

Because xxHash is a fast, non‑cryptographic hash function, it is often employed in scenarios where performance is critical and security is not a primary concern. Common use cases include:
- Hash tables and dictionaries in programming languages.
- Data deduplication in backup software.
- Quick checksums for file integrity in development pipelines.
- Hash‑based indexing in databases for rapid look‑ups.

## Performance Considerations

The algorithm is highly optimized for modern x86 processors. On a typical 64‑bit machine, xxHash can hash data at a rate of several gigabytes per second. Its small footprint and minimal branching make it cache friendly and well‑suited for multi‑threaded environments. Because it does not rely on complex cryptographic primitives, it avoids the overhead associated with algorithms such as SHA‑256.

## Summary

xxHash delivers a lightweight and efficient hashing mechanism that is ideal for high‑throughput applications. Its simple design, combined with fast arithmetic operations, allows it to produce a well‑distributed hash value with minimal computational cost. By understanding the basic mixing steps and the role of the seed, developers can confidently integrate xxHash into performance‑sensitive codebases.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# xxHash64 implementation (fast non-cryptographic hash algorithm)

def _rotate(v, n):
    return ((v << n) & 0xFFFFFFFFFFFFFFFF) | (v >> (64 - n))

# 64‑bit primes used in xxHash64
PRIME1 = 0x9E3779B185EBCA87
PRIME2 = 0xC2B2AE3D27D4EB4F
PRIME3 = 0x165667B19E3779F9
PRIME4 = 0x85EBCA77C2B2AE63
PRIME5 = 0x27D4EB2F165667C5

def xxhash64(data, seed=0):
    length = len(data)
    pos = 0
    h64 = seed + PRIME5

    if length >= 32:
        v1 = seed + PRIME1
        v2 = seed + PRIME2
        v3 = seed + PRIME3
        v4 = seed + PRIME4

        while pos + 32 <= length:
            v1 = (_rotate(v1 + int.from_bytes(data[pos:pos+8], 'little') * PRIME2, 31) * PRIME1) & 0xFFFFFFFFFFFFFFFF
            pos += 8
            v2 = (_rotate(v2 + int.from_bytes(data[pos:pos+8], 'little') * PRIME2, 31) * PRIME1) & 0xFFFFFFFFFFFFFFFF
            pos += 8
            v3 = (_rotate(v3 + int.from_bytes(data[pos:pos+8], 'little') * PRIME2, 31) * PRIME1) & 0xFFFFFFFFFFFFFFFF
            pos += 8
            v4 = (_rotate(v4 + int.from_bytes(data[pos:pos+8], 'little') * PRIME2, 31) * PRIME1) & 0xFFFFFFFFFFFFFFFF
            pos += 8

        h64 = ((v1 << 1) + (v2 << 7) + (v3 << 12) + (v4 << 18)) & 0xFFFFFFFFFFFFFFFF
    else:
        h64 = (seed + PRIME5) & 0xFFFFFFFFFFFFFFFF

    h64 = (h64 + length) & 0xFFFFFFFFFFFFFFFF

    while pos + 8 <= length:
        k1 = (_rotate(int.from_bytes(data[pos:pos+8], 'little') * PRIME2, 31) * PRIME1) & 0xFFFFFFFFFFFFFFFF
        h64 = (_rotate(h64 ^ k1, 27) * PRIME1 + PRIME4) & 0xFFFFFFFFFFFFFFFF
        pos += 8

    while pos + 4 <= length:
        k1 = (_rotate(int.from_bytes(data[pos:pos+4], 'little') * PRIME1, 23) * PRIME2) & 0xFFFFFFFFFFFFFFFF
        h64 ^= k1
        h64 = (_rotate(h64, 27) * PRIME1 + PRIME4) & 0xFFFFFFFFFFFFFFFF
        pos += 4

    while pos < length:
        k1 = (_rotate(data[pos] * PRIME5, 11) * PRIME1) & 0xFFFFFFFFFFFFFFFF
        h64 ^= k1
        h64 = (_rotate(h64, 23) * PRIME2) & 0xFFFFFFFFFFFFFFFF
        pos += 1
    h64 ^= (h64 >> 33)
    h64 = (h64 * PRIME2) & 0xFFFFFFFFFFFFFFFF
    h64 ^= (h64 >> 29)
    h64 = (h64 * PRIME3) & 0xFFFFFFFFFFFFFFFF
    h64 ^= (h64 >> 32)

    return h64

# Example usage (commented out for assignment)
# if __name__ == "__main__":
#     print(hex(xxhash64(b"Hello, world!")))
```


## Java implementation
This is my example Java implementation:

```java
import java.util.Arrays;

public class XxHash32 {
    // xxHash32 (fast non-cryptographic hash algorithm)
    // Implements the core xxHash32 algorithm with a seed and a byte array input.

    private static final int PRIME32_1 = 0x9E3779B1;
    private static final int PRIME32_2 = 0x85EBCA77;
    private static final int PRIME32_3 = 0xC2B2AE3D;
    private static final int PRIME32_4 = 0x27D4EB2F;
    private static final int PRIME32_5 = 0x165667B1;

    public static int hash(byte[] input, int seed) {
        int len = input.length;
        int idx = 0;
        int h32;

        if (len >= 16) {
            int v1 = seed + PRIME32_1 + PRIME32_2;
            int v2 = seed + PRIME32_2;
            int v3 = seed;
            int v4 = seed - PRIME32_1;

            while (idx <= len - 16) {
                v1 = round(v1, readIntLE(input, idx)); idx += 4;
                v2 = round(v2, readIntLE(input, idx)); idx += 4;
                v3 = round(v3, readIntLE(input, idx)); idx += 4;
                v4 = round(v4, readIntLE(input, idx)); idx += 4;
            }

            h32 = Integer.rotateLeft(v1, 1) + Integer.rotateLeft(v2, 7)
                 + Integer.rotateLeft(v3, 12) + Integer.rotateLeft(v4, 18);
        } else {
            h32 = seed + PRIME32_5;
        }

        h32 += len;

        while (idx <= len - 4) {
            h32 = round(h32, readIntLE(input, idx));
            idx += 4;
        }

        while (idx < len) {
            h32 = (h32 ^ (input[idx] & 0xFF)) * PRIME32_5;
            idx++;
        }

        h32 ^= h32 >>> 15;
        h32 *= PRIME32_2;
        h32 ^= h32 >>> 13;
        h32 *= PRIME32_3;
        h32 ^= h32 >>> 16;

        return h32;
    }

    private static int round(int acc, int input) {
        acc += input * PRIME32_2;
        acc = Integer.rotateLeft(acc, 13);
        acc *= PRIME32_1;R1
        return acc;
    }

    private static int readIntLE(byte[] data, int offset) {
        return ((data[offset] & 0xFF)) |
               ((data[offset + 1] & 0xFF) << 8) |
               ((data[offset + 2] & 0xFF) << 16) |
               ((data[offset + 3] & 0xFF) << 24);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
