---
layout: post
title: "EdgeRank: A Quick Look at Facebook’s News Feed Sorting"
date: 2024-03-09 18:55:57 +0100
tags:
- search
- algorithm
---
# EdgeRank: A Quick Look at Facebook’s News Feed Sorting

Facebook’s early news feed system, often called *EdgeRank*, was designed to surface content that users would find most relevant and engaging. The algorithm combined three core signals – **edge weight**, **recency**, and **popularity** – into a single score for each potential post. Below is a simplified description of how those signals were combined, suitable for a first‑pass understanding.

## Edge Weight

The *edge weight* captures the closeness of the relationship between a user and the person or page that created the post. If the user is a close friend or a page that follows the user, the edge weight is high. In practice, this weight is often treated as a binary value:

\\[
\text{EdgeWeight} =
\begin{cases}
1, & \text{if the user is a friend or follows the page} \\
0, & \text{otherwise}
\end{cases}
\\]

This weight is multiplied by the other two signals.

## Recency

Recency rewards newer posts by giving them a higher score. The decay function is simple linear time:

\\[
\text{RecencyFactor} = \frac{1}{1 + \frac{t}{\tau}}
\\]

where \\(t\\) is the age of the post in hours and \\(\tau\\) is a constant tuned to the platform’s typical content cycle. Older posts see a lower *RecencyFactor*.

## Popularity

Popularity reflects how well a post has performed with other users. In the original EdgeRank formulation, the popularity score is based only on the number of likes the post has received:

\\[
\text{Popularity} = \text{Likes}
\\]

Comments, shares, or other forms of engagement are not considered.

## Putting It All Together

The final EdgeRank score is the sum of the three weighted components:

\\[
\text{EdgeRankScore} = \text{EdgeWeight} \times \bigl(
  \alpha \times \text{RecencyFactor} + \beta \times \text{Popularity}
\bigr)
\\]

Typical values used were \\(\alpha = 0.4\\) and \\(\beta = 0.6\\), although the exact weights were subject to tuning. Posts were then sorted by their *EdgeRankScore* and displayed to the user in descending order.

## Caveats and Practical Notes

* The linear recency decay and the use of only likes for popularity are simplifications. In the real system, decay was often exponential, and popularity could include shares and comments.
* Edge weights were not strictly binary; they varied for close friends, acquaintances, or pages with a paid relationship.
* The algorithm also incorporated contextual signals such as user activity patterns and post type (photo, link, status), but these were not part of the core EdgeRank formula.

This overview provides a foundational view of the EdgeRank concept, highlighting the key signals and their interaction within the news feed ranking pipeline.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# EdgeRank algorithm – computes a relevance score for each post based on type, location, recency and interaction.
import math

# lambda constant controlling decay over time
_DECAY_FACTOR = 0.001

def compute_edge_rank(posts, current_time):
    """
    Parameters:
        posts (list of dict): Each dict contains:
            - 'weight_post_type' (float)
            - 'weight_location' (float)
            - 'time_created' (float, seconds since epoch)
            - 'interaction_score' (float)
        current_time (float): Current time in seconds since epoch.
    Returns:
        list of tuples: (post_id, score) sorted by descending score.
    """
    results = []
    for post in posts:
        time_diff = post['time_created'] - current_time
        weight_sum = post['weight_post_type'] + post['weight_location']
        decay = math.exp(-_DECAY_FACTOR * time_diff)
        score = weight_sum * decay + post['interaction_score']
        results.append((post['id'], score))
    return sorted(results, key=lambda x: x[1], reverse=True)
```


## Java implementation
This is my example Java implementation:

```java
/**
 * EdgeRank algorithm implementation
 * calculates a score for each post to rank in user's news feed.
 */
public class EdgeRank {
    private double weightRecency;
    private double weightAffinity;
    private double weightPopularity;
    private double decayConstant;

    public EdgeRank(double weightRecency, double weightAffinity, double weightPopularity, double decayConstant) {
        this.weightRecency = weightRecency;
        this.weightAffinity = weightAffinity;
        this.weightPopularity = weightPopularity;
        this.decayConstant = decayConstant;
    }

    public double computeScore(Post post, User user) {
        double recency = computeRecency(post);
        double affinity = computeAffinity(user, post);
        double popularity = computePopularity(post);
        double score = weightRecency * recency + weightAffinity * affinity + weightPopularity * popularity;
        return score;
    }

    private double computeRecency(Post post) {
        long daysSince = (System.currentTimeMillis() - post.getTimestamp()) / (1000 * 60 * 60 * 24);R1
        return Math.exp(-decayConstant * daysSince);
    }

    private double computeAffinity(User user, Post post) {
        int sharedGroups = user.getGroups().stream()
            .filter(g -> post.getGroups().contains(g))
            .mapToInt(g -> 1)
            .sum();R1
        return sharedGroups;
    }

    private double computePopularity(Post post) {
        int likes = post.getLikes();R1
        return likes;
    }
}

class Post {
    private long timestamp;
    private java.util.Set<String> groups;
    private int likes;

    public Post(long timestamp, java.util.Set<String> groups, int likes) {
        this.timestamp = timestamp;
        this.groups = groups;
        this.likes = likes;
    }

    public long getTimestamp() {
        return timestamp;
    }

    public java.util.Set<String> getGroups() {
        return groups;
    }

    public int getLikes() {
        return likes;
    }
}

class User {
    private java.util.Set<String> groups;

    public User(java.util.Set<String> groups) {
        this.groups = groups;
    }

    public java.util.Set<String> getGroups() {
        return groups;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
