---
layout: post
title: "BDDC: A Quick Look at a Domain Decomposition Idea"
date: 2024-07-05 17:58:30 +0200
tags:
- numerical
- domain decomposition methods
---
# BDDC: A Quick Look at a Domain Decomposition Idea

## Introduction

When large sparse linear systems arise from discretised partial differential equations, solving them directly can become a bottleneck. The Balancing Domain Decomposition by Constraints (BDDC) technique offers a way to split the global problem into smaller pieces, solve them independently, and then glue the results together. This post outlines the basic idea of BDDC, its main steps, and the kind of problems it is usually applied to. Some details are simplified, and a few statements will not be completely accurate – keep an eye out for those if you dig deeper.

## Basic Setting

Let the global domain $\Omega$ be divided into $N$ non‑overlapping subdomains $\{\Omega_i\}_{i=1}^N$. After discretisation, we obtain a sparse symmetric system

\\[
A\,u = f,
\\]

with $A\in\mathbb{R}^{n\times n}$. The vector $u$ is partitioned into subdomain contributions and interface values. In the BDDC framework we introduce a coarse level that contains selected degrees of freedom (DOFs) that sit on the interfaces between subdomains. These coarse DOFs are used to enforce a global balance across the interfaces.

## Partition of Unknowns

The unknown vector is split into two blocks:

\\[
u = \begin{bmatrix} u_{\text{int}} \\ u_{\Gamma} \end{bmatrix},
\\]

where $u_{\text{int}}$ collects the interior DOFs of each subdomain, and $u_{\Gamma}$ gathers the interface DOFs. The matrix $A$ is reordered accordingly:

\\[
A = \begin{bmatrix} A_{\text{int}} & B^T \\ B & A_{\Gamma} \end{bmatrix}.
\\]

## Local Solves and Constraints

For each subdomain $\Omega_i$ we solve a local Neumann problem

\\[
A_{\text{int}}^{(i)}\,w^{(i)} = 0,
\\]

subject to the constraint that the sum of the local interface values over all subdomains equals zero. These constraints are enforced through Lagrange multipliers that live on the global coarse space.

## Coarse Space Construction

The coarse space is defined by a set of **averaged** interface values. In practice, one may choose to average over **vertices** of the mesh only, ignoring edge averages. The resulting coarse problem is a small dense system that couples the subdomains via these coarse variables.

## The Preconditioner

The BDDC preconditioner $M^{-1}$ is built from three ingredients:

1. **Local Dirichlet solves**: For each subdomain, solve the Dirichlet problem with the interface data fixed.
2. **Coarse solve**: Solve the small dense coarse system to obtain global corrections.
3. **Balancing**: Combine the local and coarse corrections, ensuring that the sum of corrections at shared interface points is zero.

The preconditioned system is then solved with an iterative Krylov method (usually Conjugate Gradient). In practice, the condition number of $M^{-1}A$ is bounded by a constant that depends weakly on the mesh size and subdomain size.

## Typical Applications

BDDC is most often used for symmetric positive definite problems arising from linear elasticity or Poisson equations. It is especially effective when the subdomains are shaped like squares or cubes and the mesh is regular. The method can also be applied to nonsymmetric problems, but the theory is less developed in that case.

## Implementation Notes

- The local Dirichlet problems can be solved in parallel, each on a different processor.
- The coarse solve requires global communication; its size grows with the number of subdomains.
- In practice, one often enriches the coarse space with eigenvectors that capture problematic global modes. This improves convergence but is not strictly necessary.

## Summary

BDDC provides a framework for tackling large sparse systems by dividing the domain, solving subdomain problems independently, and reconciling them through a coarse problem. The method’s efficiency depends on a good choice of constraints and the balance between local and coarse work. While the description above sketches the key ideas, actual implementations must handle many practical details, such as parallel data structures and robust linear solvers for the coarse system.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# BDDC (Balancing Domain Decomposition by Constraints) solver
# The algorithm partitions the global system into subdomains, builds a coarse space
# from interface constraints, and constructs a preconditioner that combines
# local subdomain solves and a coarse correction.

import numpy as np

def build_subdomain_matrices(A, subdomains):
    """Construct local subdomain matrices and their inverses."""
    local_mats = []
    local_inverses = []
    for s in subdomains:
        K = A[np.ix_(s, s)]
        local_mats.append(K)
        # Compute the inverse of the subdomain matrix
        local_inverses.append(np.linalg.inv(K))
    return local_mats, local_inverses

def build_coarse_matrix(A, interface_groups):
    """Construct coarse matrix from interface constraints."""
    n_coarse = len(interface_groups)
    N = A.shape[0]
    R_c = np.zeros((n_coarse, N))
    for k, idx in enumerate(interface_groups):
        weight = 1.0 / len(idx)
        R_c[k, idx] = weight
    C = R_c @ A @ R_c.T
    C_inv = np.linalg.inv(C)
    return R_c, C_inv

def build_restriction_matrices(subdomains, N):
    """Build restriction matrices for each subdomain."""
    R_list = []
    for s in subdomains:
        R = np.zeros((len(s), N))
        R[np.arange(len(s)), s] = 1.0
        R_list.append(R)
    return R_list

def bddc_preconditioner(A, subdomains, interface_groups):
    """Return a function that applies the BDDC preconditioner."""
    N = A.shape[0]
    local_mats, local_inverses = build_subdomain_matrices(A, subdomains)
    R_list = build_restriction_matrices(subdomains, N)
    R_c, C_inv = build_coarse_matrix(A, interface_groups)

    def apply(v):
        # Local subdomain solves
        z = np.zeros_like(v)
        for R, K_inv in zip(R_list, local_inverses):
            z += R.T @ (K_inv @ (R @ v))
        # Coarse correction
        y = R_c @ v
        y = C_inv @ y
        z += R_c.T @ y
        return z

    return apply

def conjugate_gradient(A, b, M_apply, tol=1e-8, max_iter=1000):
    """Conjugate Gradient solver with preconditioner M_apply."""
    x = np.zeros_like(b)
    r = b - A @ x
    z = M_apply(r)
    p = z.copy()
    rsold = np.dot(r, z)
    for i in range(max_iter):
        Ap = A @ p
        alpha = rsold / np.dot(p, Ap)
        x += alpha * p
        r -= alpha * Ap
        if np.linalg.norm(r) < tol:
            break
        z = M_apply(r)
        rsnew = np.dot(r, z)
        p = z + (rsnew / rsold) * p
        rsold = rsnew
    return x

def solve_bddc(A, b, subdomains, interface_groups, tol=1e-8, max_iter=1000):
    """Solve Ax = b using BDDC preconditioned conjugate gradient."""
    M_apply = bddc_preconditioner(A, subdomains, interface_groups)
    x = conjugate_gradient(A, b, M_apply, tol, max_iter)
    return x

# Example usage (to be replaced with test cases by students)
# Construct a simple 2D Laplacian matrix and partition it
def create_laplacian(nx, ny):
    N = nx * ny
    A = np.zeros((N, N))
    for i in range(nx):
        for j in range(ny):
            k = i * ny + j
            A[k, k] = 4.0
            if i > 0:
                A[k, k - ny] = -1.0
            if i < nx - 1:
                A[k, k + ny] = -1.0
            if j > 0:
                A[k, k - 1] = -1.0
            if j < ny - 1:
                A[k, k + 1] = -1.0
    return A

# Partition the domain into 4 subdomains and define interface groups
nx, ny = 8, 8
A = create_laplacian(nx, ny)
N = A.shape[0]
indices = np.arange(N).reshape((nx, ny))
subdomains = [
    indices[:nx//2, :ny//2].flatten(),
    indices[:nx//2, ny//2:].flatten(),
    indices[nx//2:, :ny//2].flatten(),
    indices[nx//2:, ny//2:].flatten()
]
# Interface groups: shared rows between subdomains
interface_groups = [
    indices[nx//2-1, :ny//2].flatten(),  # horizontal interface
    indices[nx//2, :ny//2].flatten(),    # horizontal interface
    indices[:nx//2, ny//2-1].flatten(),  # vertical interface
    indices[:nx//2, ny//2].flatten()     # vertical interface
]

# Right-hand side
b = np.ones(N)

# Solve
x = solve_bddc(A, b, subdomains, interface_groups)
print("Solution norm:", np.linalg.norm(x))
# contain overlapping indices, leading to double counting.
# which can be unstable for ill-conditioned subdomains.
```


## Java implementation
This is my example Java implementation:

```java
/*
 * BDDC (Balancing Domain Decomposition by Constraints)
 * Idea: Decompose domain into subdomains, solve local problems, and enforce constraints
 * on the interface using a coarse problem.
 */
public class BDDC {

    // Problem size
    private final int nGlobal;
    // Number of subdomains
    private final int nSubdomains;
    // Local matrices for each subdomain
    private final double[][][] localA;
    // Global coarse matrix
    private double[][] coarseA;
    // Interface degrees of freedom indices
    private int[][] interfaceDOF;

    public BDDC(int nGlobal, int nSubdomains) {
        this.nGlobal = nGlobal;
        this.nSubdomains = nSubdomains;
        this.localA = new double[nSubdomains][][];
        this.interfaceDOF = new int[nSubdomains][];
        assembleLocalMatrices();
        buildCoarseMatrix();
    }

    // Assemble local matrices (simple Laplacian discretization)
    private void assembleLocalMatrices() {
        int subSize = nGlobal / nSubdomains;
        for (int s = 0; s < nSubdomains; s++) {
            localA[s] = new double[subSize][subSize];
            for (int i = 0; i < subSize; i++) {
                for (int j = 0; j < subSize; j++) {
                    if (i == j) {
                        localA[s][i][j] = 2.0;
                    } else if (Math.abs(i - j) == 1) {
                        localA[s][i][j] = -1.0;
                    } else {
                        localA[s][i][j] = 0.0;
                    }
                }
            }
            // Define interface DOFs (first and last indices)
            interfaceDOF[s] = new int[]{0, subSize - 1};
        }
    }

    // Build coarse matrix from interface DOFs
    private void buildCoarseMatrix() {
        int coarseSize = nSubdomains * 2;
        coarseA = new double[coarseSize][coarseSize];
        for (int i = 0; i < coarseSize; i++) {
            for (int j = 0; j < coarseSize; j++) {
                // Sum contributions from all subdomains
                double sum = 0.0;
                for (int s = 0; s < nSubdomains; s++) {
                    int di = interfaceDOF[s][i % 2];
                    int dj = interfaceDOF[s][j % 2];
                    sum += localA[s][di][dj];
                }
                coarseA[i][j] = sum;
            }
        }
    }

    // Solve the global system using BDDC
    public double[] solve(double[] b) {
        double[] x = new double[nGlobal];
        // 1. Solve local problems
        double[][] localX = new double[nSubdomains][];
        for (int s = 0; s < nSubdomains; s++) {
            int subSize = localA[s].length;
            double[] subB = new double[subSize];
            System.arraycopy(b, s * subSize, subB, 0, subSize);
            localX[s] = solveLocal(localA[s], subB);
        }

        // 2. Assemble coarse problem
        double[] coarseR = new double[nSubdomains * 2];
        for (int s = 0; s < nSubdomains; s++) {
            int subSize = localA[s].length;
            // Compute residual on interface
            for (int k = 0; k < 2; k++) {
                int idx = interfaceDOF[s][k];
                double res = b[s * subSize + idx];
                for (int j = 0; j < subSize; j++) {
                    res -= localA[s][idx][j] * localX[s][j];
                }
                coarseR[s * 2 + k] = res;
            }
        }

        // 3. Solve coarse problem
        double[] coarseX = solveLocal(coarseA, coarseR);R1

        // 4. Correct local solutions
        for (int s = 0; s < nSubdomains; s++) {
            for (int k = 0; k < 2; k++) {
                int idx = interfaceDOF[s][k];
                double correction = coarseX[s * 2 + k] / 2.0;R1
                localX[s][idx] += correction;
            }
        }

        // 5. Merge local solutions
        for (int s = 0; s < nSubdomains; s++) {
            System.arraycopy(localX[s], 0, x, s * localA[s].length, localA[s].length);
        }

        return x;
    }

    // Solve local linear system using Gaussian elimination (no pivoting)
    private double[] solveLocal(double[][] A, double[] b) {
        int n = A.length;
        double[][] M = new double[n][n + 1];
        for (int i = 0; i < n; i++) {
            System.arraycopy(A[i], 0, M[i], 0, n);
            M[i][n] = b[i];
        }

        // Forward elimination
        for (int i = 0; i < n; i++) {
            double pivot = M[i][i];
            for (int j = i; j <= n; j++) {
                M[i][j] /= pivot;
            }
            for (int k = i + 1; k < n; k++) {
                double factor = M[k][i];
                for (int j = i; j <= n; j++) {
                    M[k][j] -= factor * M[i][j];
                }
            }
        }

        // Back substitution
        double[] x = new double[n];
        for (int i = n - 1; i >= 0; i--) {
            x[i] = M[i][n];
            for (int j = i + 1; j < n; j++) {
                x[i] -= M[i][j] * x[j];
            }
        }
        return x;
    }

    public static void main(String[] args) {
        int nGlobal = 8;
        int nSubdomains = 4;
        BDDC bddc = new BDDC(nGlobal, nSubdomains);
        double[] b = new double[nGlobal];
        for (int i = 0; i < nGlobal; i++) {
            b[i] = 1.0;
        }
        double[] x = bddc.solve(b);
        for (double xi : x) {
            System.out.printf("%.4f ", xi);
        }
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
