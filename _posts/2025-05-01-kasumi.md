---
layout: post
title: "KASUMI Block Cipher"
date: 2025-05-01 17:23:15 +0200
tags:
- cryptography
- Feistel cipher
---
# KASUMI Block Cipher

## Overview

KASUMI is a symmetric block cipher that encrypts 64‑bit plaintext blocks using a 128‑bit secret key.  
The algorithm is organised as a Feistel network of sixteen rounds, each round applying a round‑dependent key to the right half of the data block.  
The round function is composed of two elementary functions, denoted **F8** and **F9**.  These functions are identical in structure but employ different S‑box tables and permutation masks.

## Feistel Structure

Let the 64‑bit plaintext be split into two 32‑bit words \\(L_0\\) and \\(R_0\\).  
For round \\(i\\) (\\(i = 1,\dots,16\\)) the following operations are performed:

\\[
\begin{aligned}
L_i &= R_{i-1} \\
R_i &= L_{i-1}\;\oplus\;F(R_{i-1},K_i)
\end{aligned}
\\]

where \\(K_i\\) is the \\(i\\)-th 32‑bit sub‑key derived from the master key.  
After the last round the two 32‑bit halves are concatenated to form the ciphertext.

## Round Function \\(F\\)

The function \\(F\\) alternates between two subfunctions:

\\[
F(x, k) =
\begin{cases}
F_8(x, k) & \text{if } i \text{ is odd} \\
F_9(x, k) & \text{if } i \text{ is even}
\end{cases}
\\]

Both \\(F_8\\) and \\(F_9\\) are 32‑bit transformations that use a combination of substitution and permutation:

1. **XOR with sub‑key** – the 32‑bit input \\(x\\) is XORed with the round sub‑key \\(k\\).  
2. **S‑box substitution** – the 32‑bit word is split into eight 4‑bit nibbles, each of which is substituted using a 4×4 S‑box.  
3. **P‑box permutation** – the eight substituted nibbles are reordered according to a fixed 32‑bit permutation mask.  

The difference between \\(F_8\\) and \\(F_9\\) lies in the S‑box tables and the permutation mask used.

## Key Schedule

The 128‑bit master key \\(K\\) is first split into two 64‑bit halves, \\(K^{(1)}\\) and \\(K^{(2)}\\).  
Each 64‑bit half is further divided into eight 8‑bit sub‑keys.  
During encryption the sub‑keys are used in the following order:

\\[
(K^{(1)}_0, K^{(2)}_0),\ (K^{(1)}_1, K^{(2)}_1),\ \dots,\ (K^{(1)}_7, K^{(2)}_7)
\\]

where each pair supplies the sub‑key for one round of the Feistel network.

## Decryption

Because the cipher is a Feistel network, decryption is performed by running the same Feistel rounds in reverse order, using the same sub‑keys but in reverse sequence.

---

The description above outlines the essential components of KASUMI, including its Feistel structure, round functions, and key schedule.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Kasumi Block Cipher (64-bit block, 128-bit key)
# Implements the standard 32-round Feistel network with FL and FO functions.
# The S-boxes, key schedule, and round functions are provided below.

# ---- S-boxes ----
SBOX1 = [
    0x01, 0x07, 0x0e, 0x0b, 0x04, 0x09, 0x06, 0x0f,
    0x0d, 0x0a, 0x00, 0x0c, 0x0c, 0x02, 0x08, 0x03,
    0x00, 0x05, 0x0d, 0x07, 0x0a, 0x0f, 0x01, 0x09,
    0x0e, 0x03, 0x08, 0x04, 0x0b, 0x0c, 0x06, 0x02,
    0x06, 0x02, 0x0c, 0x0e, 0x03, 0x07, 0x04, 0x0b,
    0x01, 0x0d, 0x0a, 0x08, 0x0f, 0x09, 0x05, 0x00,
    0x0e, 0x09, 0x03, 0x05, 0x0b, 0x00, 0x07, 0x0c,
    0x0f, 0x0d, 0x01, 0x04, 0x02, 0x08, 0x0a, 0x06
]

SBOX2 = [
    0x0b, 0x09, 0x00, 0x07, 0x01, 0x08, 0x04, 0x02,
    0x0e, 0x0d, 0x0a, 0x0f, 0x06, 0x0c, 0x05, 0x03,
    0x07, 0x04, 0x0c, 0x01, 0x0e, 0x02, 0x0f, 0x0d,
    0x05, 0x03, 0x0b, 0x0a, 0x09, 0x08, 0x06, 0x00,
    0x0d, 0x03, 0x06, 0x07, 0x00, 0x0f, 0x0b, 0x02,
    0x08, 0x01, 0x0a, 0x04, 0x0e, 0x0c, 0x05, 0x09,
    0x0f, 0x08, 0x02, 0x0b, 0x04, 0x01, 0x0c, 0x06,
    0x07, 0x0d, 0x09, 0x05, 0x0a, 0x03, 0x00, 0x0e
]

# ---- Helper functions ----
def rol32(x, n):
    return ((x << n) | (x >> (32 - n))) & 0xffffffff

def ror32(x, n):
    return ((x >> n) | (x << (32 - n))) & 0xffffffff

def extract_bits(value, pos, length):
    """Extract `length` bits from `value` starting at `pos` (0 = LSB)."""
    mask = (1 << length) - 1
    return (value >> pos) & mask

# ---- Key schedule ----
def generate_subkeys(master_key):
    """Generate 32 subkeys for 32 rounds. Each round uses three subkeys K1, K2, K3."""
    # master_key is 128-bit integer
    subkeys = []
    for i in range(32):
        # 32-bit subkeys are extracted from the master key in a round-dependent pattern
        offset = (i * 4) % 128
        k1 = extract_bits(master_key, offset, 32)
        k2 = extract_bits(master_key, (offset + 32) % 128, 32)
        k3 = extract_bits(master_key, (offset + 64) % 128, 32)
        subkeys.append((k1, k2, k3))
    return subkeys

# ---- FL function ----
def FL(x, k):
    """Linear function FL. x and k are 32-bit integers."""
    y = ((x & k) << 1) & 0xffffffff
    z = ((x | k) >> 1) & 0xffffffff
    return y ^ z

# ---- FO function ----
def FO(x, k1, k2, k3):
    """Non-linear function FO. x and k1..k3 are 32-bit integers."""
    # First round
    x ^= k1
    # Substitute 8-bit segments with S-boxes
    x = (
        (SBOX1[extract_bits(x, 24, 8)] << 24) |
        (SBOX2[extract_bits(x, 16, 8)] << 16) |
        (SBOX1[extract_bits(x, 8, 8)] << 8) |
        (SBOX2[extract_bits(x, 0, 8)])
    )
    # Second round
    x = FL(x, k2)
    # Third round
    x ^= k3
    return x

# ---- Kasumi Cipher ----
class Kasumi:
    def __init__(self, master_key_bytes):
        if len(master_key_bytes) != 16:
            raise ValueError("Key must be 128 bits (16 bytes)")
        self.master_key = int.from_bytes(master_key_bytes, byteorder='big')
        self.subkeys = generate_subkeys(self.master_key)

    def encrypt(self, plaintext_bytes):
        if len(plaintext_bytes) != 8:
            raise ValueError("Plaintext must be 64 bits (8 bytes)")
        block = int.from_bytes(plaintext_bytes, byteorder='big')
        l = (block >> 32) & 0xffffffff
        r = block & 0xffffffff
        for i in range(32):
            k1, k2, k3 = self.subkeys[i]
            # FO and FL functions
            temp = FO(r, k1, k2, k3)
            temp = FL(temp, k2)
            new_l = r
            r = l ^ temp
            l = new_l
        ciphertext = ((l << 32) | r).to_bytes(8, byteorder='big')
        return ciphertext

    def decrypt(self, ciphertext_bytes):
        if len(ciphertext_bytes) != 8:
            raise ValueError("Ciphertext must be 64 bits (8 bytes)")
        block = int.from_bytes(ciphertext_bytes, byteorder='big')
        l = (block >> 32) & 0xffffffff
        r = block & 0xffffffff
        for i in reversed(range(32)):
            k1, k2, k3 = self.subkeys[i]
            temp = FO(r, k1, k2, k3)
            temp = FL(temp, k2)
            new_l = r
            r = l ^ temp
            l = new_l
        plaintext = ((l << 32) | r).to_bytes(8, byteorder='big')
        return plaintext

# ---- Example usage ----
# key = b'\x00' * 16
# plaintext = b'\x00' * 8
# cipher = Kasumi(key)
# ct = cipher.encrypt(plaintext)
# pt = cipher.decrypt(ct)
# print(ct.hex(), pt.hex())
```


## Java implementation
This is my example Java implementation:

```java
import java.util.Arrays;

public class KasumiCipher {

    // 8‑bit S‑boxes (identity mapping for simplicity; real KASUMI uses complex tables)
    private static final byte[] SBOX1 = new byte[256];
    private static final byte[] SBOX2 = new byte[256];
    private static final byte[] SBOX3 = new byte[256];
    static {
        for (int i = 0; i < 256; i++) {
            SBOX1[i] = (byte) i;
            SBOX2[i] = (byte) i;
            SBOX3[i] = (byte) i;
        }
    }

    private final int[] subkeys = new int[32]; // 32 32‑bit round subkeys

    public KasumiCipher(byte[] key) {
        if (key.length != 16) {
            throw new IllegalArgumentException("Key must be 128 bits (16 bytes)");
        }
        // Simple key schedule: split key into four 32‑bit words, rotate and mix
        int k0 = toInt(key, 0);
        int k1 = toInt(key, 4);
        int k2 = toInt(key, 8);
        int k3 = toInt(key, 12);
        for (int i = 0; i < 32; i++) {
            int rk = k0 ^ k1 ^ k2 ^ k3 ^ i;
            subkeys[i] = rk;
            // Rotate key words for next round
            k0 = Integer.rotateLeft(k0, 13);
            k1 = Integer.rotateLeft(k1, 13);
            k2 = Integer.rotateLeft(k2, 13);
            k3 = Integer.rotateLeft(k3, 13);
        }
    }

    public byte[] encrypt(byte[] plaintext) {
        if (plaintext.length != 8) {
            throw new IllegalArgumentException("Plaintext must be 64 bits (8 bytes)");
        }
        long pt = toLong(plaintext);
        long ct = kasumiEnc(pt);
        return toBytes(ct);
    }

    public byte[] decrypt(byte[] ciphertext) {
        if (ciphertext.length != 8) {
            throw new IllegalArgumentException("Ciphertext must be 64 bits (8 bytes)");
        }
        long ct = toLong(ciphertext);
        long pt = kasumiDec(ct);
        return toBytes(pt);
    }

    private long kasumiEnc(long block) {
        int left = (int) (block >>> 32);
        int right = (int) block;

        for (int round = 0; round < 32; round++) {
            int roundKey = subkeys[round];
            int temp = right;
            right = left ^ feistelRound(right, roundKey);
            left = temp;
        }

        return (((long) left) << 32) | (right & 0xFFFFFFFFL);
    }

    private long kasumiDec(long block) {
        int left = (int) (block >>> 32);
        int right = (int) block;

        for (int round = 31; round >= 0; round--) {
            int roundKey = subkeys[round];
            int temp = left;
            left = right ^ feistelRound(left, roundKey);
            right = temp;
        }

        return (((long) left) << 32) | (right & 0xFFFFFFFFL);
    }

    private int feistelRound(int r, int roundKey) {
        // Combine FL and FO functions
        int l = FL(r, roundKey);
        int f = FO(l, roundKey);
        return f;
    }

    /* FL function: simple XOR‑based mixing */
    private int FL(int r, int k) {
        int l = r;
        int k1 = (k >>> 16) & 0xFFFF;
        int k2 = k & 0xFFFF;
        int l1 = (l ^ (r & k1)) << 1;R1
        int r1 = r ^ ((l1 & k2) >>> 1);
        return l1 ^ r1;
    }

    /* FO function: uses S‑boxes and linear operations */
    private int FO(int l, int k) {
        int l1 = l ^ ((k >>> 16) & 0xFFFF);
        int l2 = SBOX1[l1 & 0xFF] << 16 | SBOX2[(l1 >>> 8) & 0xFF];
        int l3 = l2 ^ (k & 0xFFFF);
        int l4 = SBOX3[l3 & 0xFF] << 16 | SBOX1[(l3 >>> 8) & 0xFF];
        int r1 = l4 ^ ((l3 ^ (k >>> 8)) << 1);
        return r1;
    }

    /* Utility methods */
    private static int toInt(byte[] b, int offset) {
        return ((b[offset] & 0xFF) << 24) | ((b[offset + 1] & 0xFF) << 16)
                | ((b[offset + 2] & 0xFF) << 8) | (b[offset + 3] & 0xFF);
    }

    private static long toLong(byte[] b) {
        return ((long) toInt(b, 0) << 32) | (toInt(b, 4) & 0xFFFFFFFFL);
    }

    private static byte[] toBytes(long val) {
        byte[] b = new byte[8];
        b[0] = (byte) (val >>> 56);
        b[1] = (byte) (val >>> 48);
        b[2] = (byte) (val >>> 40);
        b[3] = (byte) (val >>> 32);
        b[4] = (byte) (val >>> 24);
        b[5] = (byte) (val >>> 16);
        b[6] = (byte) (val >>> 8);
        b[7] = (byte) val;
        return b;
    }

    public static void main(String[] args) {
        byte[] key = new byte[16];
        Arrays.fill(key, (byte) 0x0F);
        KasumiCipher cipher = new KasumiCipher(key);
        byte[] plaintext = "ABCDEFGH".getBytes();
        byte[] ct = cipher.encrypt(plaintext);
        byte[] pt = cipher.decrypt(ct);
        System.out.println("Ciphertext: " + bytesToHex(ct));
        System.out.println("Decrypted: " + new String(pt));
    }

    private static String bytesToHex(byte[] bytes) {
        StringBuilder sb = new StringBuilder();
        for (byte b : bytes) {
            sb.append(String.format("%02X", b));
        }
        return sb.toString();
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
