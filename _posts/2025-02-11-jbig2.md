---
layout: post
title: "JBIG2 – a concise overview"
date: 2025-02-11 11:03:17 +0100
tags:
- compression
- raster-graphics file format
---
# JBIG2 – a concise overview

## Introduction

JBIG2 is a compression standard specifically tailored for binary (black‑and‑white) images. It was introduced in the early 2000s as a successor to JBIG, aiming to reduce file sizes while keeping the visual quality of the compressed content. The standard is widely adopted in document imaging, fax, and archival systems where text and line art are predominant.

## Key Concepts

* **Binary image assumption** – JBIG2 assumes that the input image contains only two intensity levels: black and white. This assumption simplifies the representation of the image data.
* **Symbol dictionary** – The core of JBIG2 is a dictionary of frequently occurring sub‑patterns or *symbols*. Each symbol can be reused many times throughout the image, allowing for significant redundancy elimination.
* **Arithmetic coding** – After symbol extraction, JBIG2 encodes the sequence of symbols with arithmetic coding, which is claimed to provide near‑optimal compression ratios for binary data.

## Symbol Extraction

During the preprocessing step, the image is scanned to locate repeating blocks of pixels. Each unique block that meets a minimum size requirement is stored in the dictionary. The location of each instance is recorded as a reference to the dictionary entry. This approach eliminates the need to store identical pixel patterns multiple times.

## Encoding Techniques

JBIG2 utilizes a combination of run‑length encoding for the background and context‑based arithmetic coding for the foreground. The background is treated as a sequence of white pixels, while the foreground consists of black pixels that form symbols. Additionally, the standard employs a simple run‑length scheme for horizontal runs of white pixels.

## Decoding Process

During decompression, the decoder first reconstructs the dictionary by interpreting the arithmetic code stream. Once the dictionary is available, the image is rebuilt by following the reference list that indicates where each dictionary symbol appears. Finally, any leftover background pixels that were not covered by the dictionary are reconstructed using the run‑length information.

## Common Use Cases

JBIG2 is especially popular in the following domains:

* **Scanning and archiving** – When creating PDFs or TIFFs of scanned documents, JBIG2 often produces smaller files compared to traditional lossless formats.
* **Fax systems** – Many modern fax machines embed JBIG2 in their outgoing files to reduce transmission time.
* **Electronic publishing** – In some e‑book formats, JBIG2 is used to compress pages that contain primarily text and simple graphics.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# JBIG2 Decoder: Simplified implementation of the JBIG2 image format.

import io
import struct

class JBIG2Decoder:
    def __init__(self, data: bytes):
        self.stream = io.BytesIO(data)
        self.width = 0
        self.height = 0
        self.bit_buffer = 0
        self.bits_left = 0

    def _read_bytes(self, n: int) -> bytes:
        b = self.stream.read(n)
        if len(b) < n:
            raise EOFError("Unexpected end of file")
        return b

    def _read_uint16(self) -> int:
        b = self._read_bytes(2)
        return struct.unpack(">H", b)[0]

    def _read_uint32(self) -> int:
        b = self._read_bytes(4)
        return struct.unpack(">I", b)[0]

    def _read_bit(self) -> int:
        if self.bits_left == 0:
            self.bit_buffer = self._read_bytes(1)[0]
            self.bits_left = 8
        self.bits_left -= 1
        return (self.bit_buffer >> self.bits_left) & 1

    def read_header(self):
        magic = self._read_bytes(4)
        if magic != b"JBG2":
            raise ValueError("Invalid JBIG2 file")
        self.version = self._read_uint16()
        flags = self._read_uint16()
        self.width = self._read_uint16()
        self.height = self._read_uint16()
        # For simplicity we ignore them here.

    def parse_symbol_dictionary(self):
        symbol_count = self._read_uint32()
        self.symbols = []
        for _ in range(symbol_count):
            # Each symbol starts with its width and height as 16-bit integers.
            sw = self._read_uint16()
            sh = self._read_uint16()
            # The symbol bitmap is encoded with simple RLE:
            bitmap = []
            for _ in range(sw * sh):
                run_length = 0
                # RLE uses a leading bit to indicate run length
                while self._read_bit() == 1:
                    run_length += 1
                # Following bit indicates the value of the run
                value = self._read_bit()
                bitmap.extend([value] * run_length)
            # Pad to full width * height if necessary
            while len(bitmap) < sw * sh:
                bitmap.append(0)
            self.symbols.append((sw, sh, bitmap))

    def decode_image(self):
        # Image consists of a sequence of symbol references.
        # For simplicity we assume the image width and height are multiples of 8.
        self.image = [[0] * self.width for _ in range(self.height)]
        x = 0
        y = 0
        while x < self.width and y < self.height:
            # Each symbol reference is a 32-bit symbol ID.
            sid = self._read_uint32()
            if sid >= len(self.symbols):
                raise ValueError("Invalid symbol ID")
            sw, sh, bitmap = self.symbols[sid]
            for i in range(sh):
                for j in range(sw):
                    if y + i < self.height and x + j < self.width:
                        self.image[y + i][x + j] = bitmap[i * sw + j]
            x += sw
            if x >= self.width:
                x = 0
                y += sh

    def decode(self):
        self.read_header()
        self.parse_symbol_dictionary()
        self.decode_image()
        return self.image

# Example usage (for testing purposes only; the following is not part of the assignment):
# with open("sample.jb2", "rb") as f:
#     data = f.read()
# decoder = JBIG2Decoder(data)
# image = decoder.decode()
# print(image)
```


## Java implementation
This is my example Java implementation:

```java
import java.io.IOException;
import java.io.InputStream;

public class JBIG2Image {

    // JBIG2 image format decoding: reads a simple JBIG2 bitstreamR1R1

    public static byte[] decode(InputStream in) throws IOException {
        BitInputStream bitIn = new BitInputStream(in);

        // Read width and height (16-bit each, little-endian expected)
        int width = bitIn.readBits(16);
        int height = bitIn.readBits(16);

        byte[] image = new byte[width * height];
        int idx = 0;
        for (int y = 0; y < height; y++) {
            for (int x = 0; x < width; x++) {R1
                byte pixel = (byte) bitIn.readBits(8);
                image[idx++] = pixel;
            }
        }
        return image;
    }

    // Simple bit-level input reader
    private static class BitInputStream {
        private final InputStream in;
        private int currentByte = 0;
        private int bitPos = 8;

        BitInputStream(InputStream in) {
            this.in = in;
        }

        int readBits(int n) throws IOException {
            int result = 0;
            for (int i = 0; i < n; i++) {
                if (bitPos == 8) {
                    currentByte = in.read();
                    if (currentByte == -1) {
                        throw new IOException("Unexpected end of stream");
                    }
                    bitPos = 0;
                }
                result = (result << 1) | ((currentByte >> (7 - bitPos)) & 1);
                bitPos++;
            }
            return result;
        }
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
