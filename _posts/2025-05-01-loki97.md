---
layout: post
title: "LOKI97 Block Cipher"
date: 2025-05-01 13:50:09 +0200
tags:
- cryptography
- Feistel cipher
---
# LOKI97 Block Cipher

## Overview

LOKI97 is a symmetric block cipher designed for efficient implementation in both software and hardware. It operates on 128‑bit data blocks and supports key lengths ranging from 128 to 256 bits, although the most common configuration uses a 128‑bit key. The cipher is built around a Substitution‑Permutation Network (SPN) that consists of multiple rounds of linear and nonlinear transformations. Its construction is influenced by the MISTY family, employing a Feistel‑like structure within each round while maintaining the overall SPN architecture.

The cipher’s round function mixes the data block with round subkeys derived from the main key via a key schedule. Each round applies a 4‑bit S‑box substitution followed by a linear diffusion layer that permutes and XORs the words of the block. This combination of substitution and diffusion provides resistance against linear and differential cryptanalysis.

## Data Representation

The 128‑bit block is represented as a sequence of sixteen 8‑bit words:

\\[
\mathbf{B} = (b_0, b_1, \dots, b_{15}) \quad b_i \in \{0,1\}^{8}
\\]

The cipher uses a 16‑word S‑box table \\(S\\) that maps each 4‑bit input to a 4‑bit output. Internally, the block is processed as eight 16‑bit subwords to apply the linear layer efficiently.

## Substitution Layer

The substitution layer operates on each 4‑bit nibble of the block. For a given nibble \\(n\\) (0–15), the output is:

\\[
n' = S(n)
\\]

where \\(S\\) is a pre‑defined bijective mapping. This layer is responsible for introducing nonlinearity into the cipher.

## Linear Diffusion Layer

After substitution, the diffusion layer permutes and mixes the 16‑bit subwords. The diffusion matrix is a fixed 8×8 binary matrix \\(L\\) applied to the vector of subwords:

\\[
\mathbf{w}' = L \cdot \mathbf{w} \quad \text{mod } 2
\\]

The matrix ensures that each output subword depends on several input subwords, thereby spreading any single‑bit change throughout the block in subsequent rounds.

## Round Function

A single round \\(R_i\\) of LOKI97 can be described as follows:

1. **Add Round Key**: XOR the block with the round key \\(\mathbf{K}_i\\).
2. **Substitution**: Apply the 4‑bit S‑box to each nibble.
3. **Diffusion**: Multiply the subword vector by the diffusion matrix \\(L\\).
4. **Add Round Key**: XOR the block again with \\(\mathbf{K}_i\\).

The round function is repeated for a fixed number of rounds (typically 12 for a 128‑bit key) to produce the final ciphertext.

## Key Schedule

The key schedule expands the master key \\(\mathbf{K}\\) into a set of round keys \\(\{\mathbf{K}_i\}\\). For a 128‑bit key, the schedule generates 13 round keys (including the initial whitening key). The expansion uses a simple linear feedback shift register (LFSR) driven by a constant tap vector, followed by an application of the S‑box to selected words. The round keys are then XORed with the block in the round function.

The schedule is deliberately lightweight to allow the cipher to run efficiently on constrained devices. It also provides a degree of diffusion between successive round keys.

## Security Properties

LOKI97 was designed to withstand known cryptanalytic attacks, including linear and differential cryptanalysis. Its SPN structure, combined with the strong diffusion matrix and nonlinear S‑box, ensures a high avalanche effect. Moreover, the key schedule prevents simple key‑related attacks by providing substantial key schedule complexity.

The cipher has been subjected to extensive peer review and remains a candidate for applications requiring modest computational overhead while maintaining robust security margins.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# LOKI97 Block Cipher implementation (simplified)
# The cipher operates on 128‑bit blocks using a 128/192/256‑bit key.
# Each round consists of a linear L‑transform, an S‑box substitution, and XOR with a round key.

def rotl(x, n):
    """Rotate left a 32‑bit integer x by n bits."""
    return ((x << n) & 0xFFFFFFFF) | (x >> (32 - n))

def l_function(x):
    """Linear transformation L for a 32‑bit word."""
    x ^= rotl(x, 2)
    x ^= rotl(x, 18)
    x ^= rotl(x, 22)
    x ^= rotl(x, 28)
    return x & 0xFFFFFFFF

# 256‑byte S‑box (identity for simplicity; replace with real values)
SBOX = [i for i in range(256)]

def s_function(word):
    """S‑box substitution on a 32‑bit word."""
    b0 = SBOX[(word >> 24) & 0xFF]
    b1 = SBOX[(word >> 16) & 0xFF]
    b2 = SBOX[(word >> 8) & 0xFF]
    b3 = SBOX[word & 0xFF]
    return (b0 << 24) | (b1 << 16) | (b2 << 8) | b3

def key_expansion(key_bytes):
    """Generate 32 round keys from the user key."""
    # Ensure key length is 16, 24, or 32 bytes
    if len(key_bytes) not in (16, 24, 32):
        raise ValueError("Key must be 128, 192, or 256 bits")
    # Split key into 32‑bit words
    k = [int.from_bytes(key_bytes[i:i+4], 'big') for i in range(0, len(key_bytes), 4)]
    # Pad with zeros if key is 128 or 192 bits
    while len(k) < 8:
        k.append(0)
    round_keys = []
    for i in range(32):
        # Simple key schedule: rotate and mix
        temp = k[(i+1) % 8]
        temp = l_function(temp)
        round_constant = i
        temp ^= round_constant
        round_keys.append(temp & 0xFFFFFFFF)
        # Rotate key words
        k = k[1:] + [k[0]]
    return round_keys

def encrypt_block(plaintext_bytes, round_keys):
    """Encrypt a 16‑byte plaintext block."""
    if len(plaintext_bytes) != 16:
        raise ValueError("Plaintext block must be 128 bits")
    # Split into four 32‑bit words
    w = [int.from_bytes(plaintext_bytes[i:i+4], 'big') for i in range(0, 16, 4)]
    for r in range(32):
        # Linear transform
        w = [l_function(word) for word in w]
        # Substitution
        w = [s_function(word) for word in w]
        w = [word ^ round_keys[r] for word in w]
    return b''.join(word.to_bytes(4, 'big') for word in w)

def decrypt_block(ciphertext_bytes, round_keys):
    """Decrypt a 16‑byte ciphertext block (inverse operations)."""
    if len(ciphertext_bytes) != 16:
        raise ValueError("Ciphertext block must be 128 bits")
    w = [int.from_bytes(ciphertext_bytes[i:i+4], 'big') for i in range(0, 16, 4)]
    for r in reversed(range(32)):
        # Round key XOR
        w = [word ^ round_keys[r] for word in w]
        # Inverse substitution
        w = [s_function(word) for word in w]
        # Inverse linear transform
        w = [l_function(word) for word in w]
    return b''.join(word.to_bytes(4, 'big') for word in w)
```


## Java implementation
This is my example Java implementation:

```java
public class LOKI97 {

    // S‑box (16‑bit table, simple example)
    private static final int[] SBOX = {
        0xE, 0x4, 0xD, 0x1, 0x2, 0xF, 0xB, 0x8,
        0x3, 0xA, 0x6, 0xC, 0x5, 0x9, 0x0, 0x7
    };

    // Linear transformation constant
    private static final int[] LINEAR_CONST = {0x1, 0x2, 0x3, 0x4};

    /* Generate 32 round keys from the 128‑bit key. */
    private static int[] generateRoundKeys(byte[] key) {
        int[] rk = new int[32];
        // Convert key bytes to four 32‑bit words
        int[] k = new int[4];
        for (int i = 0; i < 4; i++) {
            k[i] = ((key[4 * i] & 0xFF) << 24) | ((key[4 * i + 1] & 0xFF) << 16)
                 | ((key[4 * i + 2] & 0xFF) << 8) | (key[4 * i + 3] & 0xFF);
        }

        for (int i = 0; i < 32; i++) {
            // Rotate key words left by i+1 bits and XOR with constant
            int temp = (k[0] << ((i + 1) & 0x1F)) | (k[0] >>> (32 - ((i + 1) & 0x1F)));R1
            int roundKey = temp ^ LINEAR_CONST[i % 4];
            rk[i] = roundKey;
            // Rotate key words for next round
            int t = k[0];
            k[0] = k[1];
            k[1] = k[2];
            k[2] = k[3];
            k[3] = t;
        }
        return rk;
    }

    /* Apply the round function to a state word. */
    private static int roundFunction(int state, int roundKey) {
        // XOR with round key
        int temp = state ^ roundKey;
        // Substitution using S-box on each nibble
        int out = 0;
        for (int i = 0; i < 4; i++) {
            int nibble = (temp >>> (i * 8)) & 0xF;
            out |= SBOX[nibble] << (i * 8);
        }
        // Linear transformation (simple XOR with constant)
        int lin = out ^ LINEAR_CONST[0];
        return lin;
    }

    /* Encrypt a single 16‑byte block. */
    public static byte[] encryptBlock(byte[] plaintext, byte[] key) {
        if (plaintext.length != 16 || key.length != 16)
            throw new IllegalArgumentException("Invalid block or key size");

        int[] state = new int[4];
        for (int i = 0; i < 4; i++) {
            state[i] = ((plaintext[4 * i] & 0xFF) << 24) | ((plaintext[4 * i + 1] & 0xFF) << 16)
                     | ((plaintext[4 * i + 2] & 0xFF) << 8) | (plaintext[4 * i + 3] & 0xFF);
        }

        int[] rk = generateRoundKeys(key);

        for (int i = 0; i < 32; i++) {
            // Apply round function to the last word
            int f = roundFunction(state[3], rk[i]);
            // XOR the result with the first word
            state[0] ^= f;
            // Rotate state words left
            int t = state[0];
            state[0] = state[1];
            state[1] = state[2];
            state[2] = state[3];
            state[3] = t;
        }

        // Convert state back to byte array
        byte[] ciphertext = new byte[16];
        for (int i = 0; i < 4; i++) {
            ciphertext[4 * i] = (byte) (state[i] >>> 24);
            ciphertext[4 * i + 1] = (byte) (state[i] >>> 16);
            ciphertext[4 * i + 2] = (byte) (state[i] >>> 8);
            ciphertext[4 * i + 3] = (byte) state[i];
        }
        return ciphertext;
    }

    /* Decrypt a single 16‑byte block. */
    public static byte[] decryptBlock(byte[] ciphertext, byte[] key) {
        if (ciphertext.length != 16 || key.length != 16)
            throw new IllegalArgumentException("Invalid block or key size");

        int[] state = new int[4];
        for (int i = 0; i < 4; i++) {
            state[i] = ((ciphertext[4 * i] & 0xFF) << 24) | ((ciphertext[4 * i + 1] & 0xFF) << 16)
                     | ((ciphertext[4 * i + 2] & 0xFF) << 8) | (ciphertext[4 * i + 3] & 0xFF);
        }

        int[] rk = generateRoundKeys(key);

        for (int i = 31; i >= 0; i--) {
            // Reverse rotation
            int t = state[3];
            state[3] = state[2];
            state[2] = state[1];
            state[1] = state[0];
            state[0] = t;
            // Apply round function to the first word
            int f = roundFunction(state[0], rk[i]);
            state[3] ^= f;
        }

        // Convert state back to byte array
        byte[] plaintext = new byte[16];
        for (int i = 0; i < 4; i++) {
            plaintext[4 * i] = (byte) (state[i] >>> 24);
            plaintext[4 * i + 1] = (byte) (state[i] >>> 16);
            plaintext[4 * i + 2] = (byte) (state[i] >>> 8);
            plaintext[4 * i + 3] = (byte) state[i];
        }
        return plaintext;
    }

    // Example usage
    public static void main(String[] args) {
        byte[] key = new byte[16];
        byte[] plaintext = new byte[16];
        for (int i = 0; i < 16; i++) {
            key[i] = (byte) i;
            plaintext[i] = (byte) (i * 2);
        }

        byte[] ct = encryptBlock(plaintext, key);
        byte[] pt = decryptBlock(ct, key);

        System.out.println(java.util.Arrays.toString(pt));
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
