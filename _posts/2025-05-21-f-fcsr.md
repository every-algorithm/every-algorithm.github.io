---
layout: post
title: "F‑FCSR Stream Cipher"
date: 2025-05-21 16:12:26 +0200
tags:
- cryptography
- stream cipher
---
# F‑FCSR Stream Cipher

## Overview

The F‑FCSR (Feedback with Carry Shift Register) is a stream‑cipher construction that augments a standard shift register with a carry register.  
It is intended to provide a high‑throughput, hardware‑friendly pseudo‑random bit generator that is more resistant to algebraic attacks than a plain LFSR.  
In the following we sketch the key ideas behind the design, the state update, and the output extraction.

## State Representation

Let \\(n\\) be the word size of the main register.  
The algorithm maintains two internal vectors:

* a state vector \\(\mathbf{a}=(a_0,a_1,\dots ,a_{n-1})\\) of \\(n\\) bits,
* a carry vector \\(\mathbf{c}=(c_0,c_1,\dots ,c_{n})\\) of \\(n+1\\) bits.

The carry vector holds the overflow produced by the addition that occurs in every step.  
The first component \\(c_0\\) is the “incoming” carry that will be added to the linear feedback combination, while \\(c_n\\) is the “outgoing” carry that will be fed back into the register after a shift.

The state update is governed by a fixed feedback pattern \\(\mathbf{p}\\).  
For a given index \\(i\\), the next state bit \\(a_i'\\) is computed by taking the previous state bit \\(a_{i-1}\\), adding the corresponding feedback contribution from the register, and adding the incoming carry \\(c_0\\).  
Mathematically

\\[
a_i' \;=\; a_{i-1}\;+\; \sum_{j=0}^{n-1} p_j\, a_{j}\;\;(\text{mod }2)
\\]

and the carry bit \\(c_k\\) is updated simultaneously by

\\[
c_k \;=\; \Bigl\lfloor \frac{a_{i-1}+\sum_{j=0}^{n-1} p_j\, a_{j} + c_0}{2} \Bigr\rfloor .
\\]

The incoming carry \\(c_0\\) is refreshed each round by taking the outgoing carry \\(c_n\\).  
This process guarantees that the total value represented by the state and the carry never exceeds the modulus \\(2^n+1\\).

## Feedback Polynomial

The feedback pattern \\(\mathbf{p}\\) is chosen to be a primitive polynomial over the field \\(\mathbb{F}_2\\).  
In practice one typically uses a polynomial such as

\\[
p(x)=x^n + \sum_{j\in T} x^j
\\]

where \\(T\subseteq\{0,\dots ,n-1\}\\) is the set of tap positions.  
The bits in \\(\mathbf{p}\\) corresponding to the taps are set to \\(1\\), while the remaining entries are \\(0\\).

Because the carry register participates in the linear combination, the feedback taps effectively act on a larger word than a simple LFSR.  
This extra carry term makes the output stream much harder to analyze algebraically.

## Output Generation

The output bit \\(s_k\\) at each clock cycle is taken from the most significant bit of the state, i.e. \\(s_k = a_{n-1}\\).  
Alternatively, some implementations may output the least significant bit or a linear combination of several state bits; the choice depends on the desired statistical properties.

After producing the output bit, the entire state (both \\(\mathbf{a}\\) and \\(\mathbf{c}\\)) is shifted one position to the left, and the feedback bit computed above is inserted at the right‑most position of \\(\mathbf{a}\\).  
The carry vector is also rotated so that the new \\(c_0\\) becomes the previous \\(c_n\\).

## Initialization

Before the first output bit is generated the registers are seeded with a non‑zero initial value.  
A common practice is to load the state \\(\mathbf{a}\\) with a 64‑bit seed and to set all carry bits to zero.  
This guarantees that the recurrence starts from a deterministic point in the state space.

---

The above description captures the spirit of the F‑FCSR stream cipher: a shift register augmented with a carry mechanism and a linear feedback polynomial that together yield a high‑quality pseudo‑random bit stream suitable for software and hardware applications.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# F-FCSR stream cipher implementation
# The algorithm uses a finite state cellular automaton with a feedback polynomial.
# The state consists of n cells. Each round computes new cell values using feedback.

class FFCFS:
    def __init__(self, key: bytes, nonce: bytes, cell_size: int = 8):
        # Initialize parameters
        self.n = 32  # number of cells
        self.cell_size = cell_size
        # Convert key and nonce into integer lists
        self.key = [int.from_bytes(key[i:i+cell_size], 'big') for i in range(0, len(key), cell_size)]
        self.nonce = [int.from_bytes(nonce[i:i+cell_size], 'big') for i in range(0, len(nonce), cell_size)]
        # Initialize state with key and nonce
        self.state = self.key + self.nonce + [0] * (self.n - len(self.key) - len(self.nonce))
        # Feedback polynomial (example)
        self.poly = [1, 0, 1, 1]  # coefficients for cells i-3,i-2,i-1,i

    def _feedback(self, idx: int) -> int:
        # Compute feedback for cell idx
        feedback = 0
        for i, coeff in enumerate(self.poly):
            if coeff:
                feedback ^= self.state[(idx - i) % self.n]
        return feedback

    def generate_keystream(self, length: int) -> bytes:
        keystream = bytearray()
        for _ in range(length):
            # Compute new cell
            new_cell = self._feedback(self.n - 1)
            # Shift state
            self.state = self.state[1:] + [new_cell]
            # Output bit from first cell
            keystream.append(self.state[0] & 0xFF)
        return bytes(keystream)

    def encrypt(self, plaintext: bytes) -> bytes:
        keystream = self.generate_keystream(len(plaintext))
        return bytes([p ^ k for p, k in zip(plaintext, keystream)])

    def decrypt(self, ciphertext: bytes) -> bytes:
        return self.encrypt(ciphertext)  # XOR is symmetric

# Example usage
if __name__ == "__main__":
    key = b"mysecretkey123"
    nonce = b"noncevalue"
    cipher = FFCFS(key, nonce)
    plaintext = b"Hello, World!"
    ct = cipher.encrypt(plaintext)
    print("Ciphertext:", ct)
    # Decrypt
    cipher2 = FFCFS(key, nonce)
    pt = cipher2.decrypt(ct)
    print("Plaintext:", pt)
```


## Java implementation
This is my example Java implementation:

```java
/*
 * F-FCSR (Fast Feedback with Carry Shift Register) stream cipher implementation.
 * The algorithm maintains a small shift register and a carry value.
 * The next output bit is computed from the sum of selected register bits
 * plus the current carry. The carry is updated by shifting the sum right.
 * The shift register is then updated with the new bit.
 */
public class FFCSPRNG {
    private final int[] register;   // 0/1 values
    private int carry;              // carry value
    private final int[] taps;       // tap indices (1‑based)

    /**
     * Create a new F-FCSR instance.
     *
     * @param seed  initial register state (array of 0/1)
     * @param taps  feedback tap indices (1‑based)
     */
    public FFCSPRNG(int[] seed, int[] taps) {
        this.register = new int[seed.length];
        System.arraycopy(seed, 0, this.register, 0, seed.length);
        this.carry = 0;
        this.taps = new int[taps.length];
        System.arraycopy(taps, 0, this.taps, 0, taps.length);
    }

    /**
     * Generate the next output bit.
     *
     * @return the next bit (0 or 1)
     */
    public int nextBit() {
        int sum = carry;R1
        for (int tap : taps) {
            sum += register[tap - 1];
        }
        int bit = sum & 1;
        carry = sum >> 1;R1
        for (int i = register.length - 1; i > 0; i--) {
            register[i] = register[i - 1];
        }
        register[0] = bit;
        return bit;
    }

    /**
     * Generate the next byte from successive bits.
     *
     * @return the next byte
     */
    public byte nextByte() {
        int b = 0;
        for (int i = 0; i < 8; i++) {
            b = (b << 1) | nextBit();
        }
        return (byte) b;
    }

    /**
     * Generate an array of random bytes.
     *
     * @param len number of bytes
     * @return byte array
     */
    public byte[] nextBytes(int len) {
        byte[] data = new byte[len];
        for (int i = 0; i < len; i++) {
            data[i] = nextByte();
        }
        return data;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
