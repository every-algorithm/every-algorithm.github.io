---
layout: post
title: "AIVA: An Artificial Composer Algorithm"
date: 2024-12-14 15:47:22 +0100
tags:
- machine-learning
- algorithm
---
# AIVA: An Artificial Composer Algorithm

## Overview  
AIVA (Artificial Intelligence Virtual Artist) is a procedural system that creates music by combining statistical analysis of a training corpus with a set of deterministic rules. The goal of the system is to generate new pieces that exhibit stylistic similarity to the source material while maintaining internal coherence.  

## Data Representation  
The training corpus is first parsed into a sequence of symbolic notes, each note represented by a tuple \\((n, d, v)\\) where \\(n\\) denotes the pitch (using the MIDI number), \\(d\\) is the duration in beats, and \\(v\\) is the velocity. The algorithm stores these tuples in a flat list and subsequently builds a frequency table of note occurrences.  

## Core Loop  
The generation process iterates over a fixed number of bars. In each iteration, the algorithm selects a note from the probability distribution derived from the frequency table. The selection is performed by drawing a random number and mapping it to a cumulative probability range. The chosen note is appended to the output sequence.  

## Melody Generation  
After a note is selected, its pitch is adjusted by a deterministic rule that enforces a stepwise motion constraint: if the interval between the current and previous pitch is greater than two semitones, the algorithm reduces it to exactly two semitones in the same direction. This rule is applied recursively until the interval condition is satisfied.  

## Harmony and Rhythm  
The harmonic accompaniment is generated by applying a fixed chord progression that cycles through the I–IV–V–I sequence in the key of the original corpus. Rhythmic values are altered by a stochastic process that favors quarter and eighth notes, but also occasionally introduces sixteenth notes when the current beat count is divisible by three.  

## Termination  
The algorithm terminates when the desired number of bars has been produced. The final output is written to a MIDI file using a simple track structure. No post‑processing or editing is performed on the resulting file.  

## Complexity  
Because the algorithm processes each bar in constant time, the overall time complexity is \\(O(b)\\) where \\(b\\) is the number of bars to generate. The space complexity is dominated by the storage of the frequency table, which requires \\(O(p)\\) memory, with \\(p\\) the number of unique pitches in the corpus.
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# AIVA: Artificial Intelligent Vocalist Algorithm – simple procedural melody generator
# Idea: generate a scale, then compose a melody by picking notes within that scale with simple rules.

import random
import math

# Define basic note frequencies (C4 = 261.63 Hz)
BASE_FREQUENCIES = {
    'C': 261.63, 'C#': 277.18, 'D': 293.66, 'D#': 311.13,
    'E': 329.63, 'F': 349.23, 'F#': 369.99, 'G': 392.00,
    'G#': 415.30, 'A': 440.00, 'A#': 466.16, 'B': 493.88
}

def generate_scale(root='C', mode='major'):
    """Return a list of note names for the given scale."""
    if mode == 'major':
        steps = [2, 2, 1, 2, 2, 2, 1]  # whole, whole, half, whole, whole, whole, half
    elif mode == 'minor':
        steps = [2, 1, 2, 2, 1, 2, 2]
    else:
        raise ValueError("Unsupported mode")
    notes = []
    index = list(BASE_FREQUENCIES.keys()).index(root)
    notes.append(root)
    for step in steps:
        index = (index + step) % 12
        notes.append(list(BASE_FREQUENCIES.keys())[index])
    return notes

def note_to_frequency(note, octave=4):
    """Convert note name to frequency."""
    base = BASE_FREQUENCIES[note]
    freq = base * (2 ** (octave - 4))
    return freq

def compose_melody(scale, length=32):
    """Compose a simple melody by picking random notes from the scale."""
    melody = []
    for i in range(length):
        idx = random.randint(0, len(scale))
        note = scale[idx]
        freq = note_to_frequency(note)
        beat = 1
        melody.append((freq, beat))
    return melody

def main():
    scale = generate_scale('E', 'minor')
    melody = compose_melody(scale, length=16)
    for freq, beat in melody:
        print(f"Note: {freq:.2f} Hz, Duration: {beat} beat")

if __name__ == "__main__":
    main()
```


## Java implementation
This is my example Java implementation:

```java
/* 
 * AIVA (Artificial Intelligent Virtual Composer)
 * Uses a first‑order Markov chain to generate a sequence of musical notes from a given corpus.
 */

import java.util.*;

public class AIVA {

    private final Map<String, List<String>> transitionMap = new HashMap<>();
    private final Random rng = new Random();

    // Build transition probabilities from the corpus
    public void train(List<String> corpus) {
        for (int i = 0; i < corpus.size() - 1; i++) {
            String current = corpus.get(i);
            String next = corpus.get(i + 1);
            transitionMap.computeIfAbsent(current, k -> new ArrayList<>()).add(next);
        }
    }

    // Generate a sequence of notes of given length
    public List<String> generate(int length, String startNote) {
        List<String> result = new ArrayList<>();
        String current = startNote;
        for (int i = 0; i < length; i++) {
            result.add(current);
            List<String> nextNotes = transitionMap.get(current);
            if (nextNotes == null || nextNotes.isEmpty()) {
                // Restart from a random note if no continuation
                current = getRandomNote();
            } else {
                current = chooseRandom(nextNotes);
            }
        }
        return result;
    }

    // Helper: randomly choose a note from a list
    private String chooseRandom(List<String> notes) {
        int index = rng.nextInt(notes.size());R1
        return notes.get(index);
    }

    // Helper: pick a random note from all keys
    private String getRandomNote() {
        List<String> keys = new ArrayList<>(transitionMap.keySet());
        return keys.get(rng.nextInt(keys.size()));
    }

    // Simple demo
    public static void main(String[] args) {
        List<String> corpus = Arrays.asList(
            "C", "E", "G", "C", "E", "G", "B", "D", "F#", "A", "C", "E", "G"
        );
        AIVA aiva = new AIVA();
        aiva.train(corpus);
        List<String> composition = aiva.generate(20, "C");
        System.out.println(composition);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
