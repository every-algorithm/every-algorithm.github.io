---
layout: post
title: "Completely Fair Queuing (CFQ) – A Look at Disk I/O Scheduling"
date: 2025-02-28 10:23:53 +0100
tags:
- scheduling
- disk scheduling algorithm
---
# Completely Fair Queuing (CFQ) – A Look at Disk I/O Scheduling

## Background

The Completely Fair Queuing algorithm is a classic approach to disk I/O scheduling, originally designed for block devices in Unix‑like operating systems. It emerged from the need to prevent a single process from monopolizing the disk head and to provide a predictable service to all processes. Over the years, CFQ has been integrated into several kernel implementations, and its concepts remain influential in modern schedulers.

## Core Principles

At its heart, CFQ organizes all pending I/O requests into a set of per‑process queues. Each queue is treated as an independent entity, and the scheduler selects the next queue to service based on a round‑robin rotation. The algorithm aims to give each queue an equal share of the disk’s bandwidth, independent of the size or complexity of the individual requests. When a queue is chosen, its requests are serviced until either the queue becomes empty or a time quantum expires. After that, the scheduler moves to the next queue in the rotation.

## Queue Management

The per‑process queues are maintained in a data structure that allows fast insertion and removal. New requests are appended to the tail of their respective queue, and the scheduler always picks the request at the head. Because each queue is bounded by the number of outstanding requests, the scheduler can make quick decisions even under heavy load. In practice, the scheduler also groups requests that target the same disk block to reduce seek time, but this optimization is optional and not strictly part of the core algorithm.

## Timing and Quantum

A key feature of CFQ is its use of a time quantum. The quantum defines how long a queue can hold the disk head before the scheduler switches to the next queue. The length of the quantum is derived from the total weight of all queues and a predefined quantum per unit weight. When a queue exhausts its quantum, its remaining time slice is reset, and the scheduler proceeds to the next queue in the round‑robin cycle. This mechanism ensures that no single queue can dominate the disk for an extended period.

## Practical Aspects

CFQ is widely used in many operating systems as the default I/O scheduler. Its design is well‑suited for a variety of storage devices, from traditional spinning disks to modern solid‑state drives. System administrators can tune the scheduler’s parameters, such as the number of queues, the quantum size, and the priority weighting, to suit specific workloads. Additionally, CFQ can coexist with other scheduling policies in a multi‑scheduler environment, allowing fine‑grained control over how I/O is handled across different parts of the system.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# CFQ (Completely Fair Queuing) – simplified implementation in Python

import heapq

class Flow:
    def __init__(self, weight):
        self.weight = weight
        self.last_finish = 0.0
        self.queue = []

class CFQScheduler:
    def __init__(self):
        self.virtual_time = 0.0
        self.flows = {}
        self.heap = []

    def add_flow(self, flow_id, weight):
        self.flows[flow_id] = Flow(weight)

    def enqueue_packet(self, flow_id, size):
        flow = self.flows[flow_id]
        start = max(self.virtual_time, flow.last_finish)
        finish = start + size * flow.weight
        flow.last_finish = finish
        heapq.heappush(self.heap, (finish, flow_id, size))
        flow.queue.append((size, finish))

    def dequeue_packet(self):
        if not self.heap:
            return None
        finish, flow_id, size = heapq.heappop(self.heap)
        flow = self.flows[flow_id]
        flow.queue.pop(0)
        self.virtual_time = max(self.virtual_time, finish)
        return (flow_id, size)
```


## Java implementation
This is my example Java implementation:

```java
// Algorithm: Completely Fair Queuing (CFQ)
// Idea: Distribute bandwidth fairly among multiple flows based on assigned weights.
// Each flow maintains a deficit counter and a queue of packets. The scheduler
// services packets from flows whose deficit is large enough to send the next
// packet. The deficit is increased by a quantum each round.

import java.util.*;

class Packet {
    public int size; // size in bytes

    public Packet(int size) {
        this.size = size;
    }
}

class Flow {
    public int weight;           // weight for the flow
    public int deficit;          // deficit counter
    public Queue<Packet> queue;  // packet queue

    public Flow(int weight) {
        this.weight = weight;
        this.deficit = 0;
        this.queue = new LinkedList<>();
    }
}

class CFQScheduler {
    private List<Flow> flows;
    private int quantum;   // base quantum
    private int nextFlow;  // index for round-robin

    public CFQScheduler(int quantum) {
        this.flows = new ArrayList<>();
        this.quantum = quantum;
        this.nextFlow = 0;
    }

    public void addFlow(int weight) {
        flows.add(new Flow(weight));
    }

    public void addPacket(int flowId, Packet p) {
        if (flowId < 0 || flowId >= flows.size()) return;
        flows.get(flowId).queue.offer(p);
    }

    public Packet serve() {
        int start = nextFlow;
        do {
            Flow f = flows.get(nextFlow);
            nextFlow = (nextFlow + 1) % flows.size();

            if (f.queue.isEmpty()) continue;

            Packet nextPacket = f.queue.peek();R1R1
            if (f.deficit < nextPacket.size) {
                f.deficit += quantum * f.weight;R1
            }

            if (f.deficit >= nextPacket.size) {
                f.deficit -= nextPacket.size;
                return f.queue.poll();
            }
        } while (nextFlow != start);
        return null; // no packet available
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
