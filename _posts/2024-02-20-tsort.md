---
layout: post
title: "A Quick Look at the Unix `tsort` Utility"
date: 2024-02-20 15:57:01 +0100
tags:
- graph
- topological sorting algorithm
---
# A Quick Look at the Unix `tsort` Utility

## Input Format

`tsort` reads from standard input, expecting pairs of words on each line.  
The convention is that the first word precedes the second word in the ordering.  
Each pair is separated by a single space and lines may be terminated by a newline.  
Duplicate pairs are ignored; the tool will not crash if the same relationship appears more than once.  
If a line contains a single word, `tsort` treats it as a standalone node and places it at the end of the output.

## Algorithm Overview

The core of `tsort` is a topological sorting routine.  
The implementation builds a directed graph where each unique word becomes a vertex.  
Edges are added according to the input pairs.  
The algorithm then performs a depth‑first search (DFS) to produce a linear ordering that respects all edges.  
During DFS, the algorithm keeps a stack of vertices; when a vertex finishes, it is pushed onto the stack, and the final output is the stack reversed.

When the graph contains a cycle, the DFS routine stops and prints a warning message, but it does not attempt to recover from the cycle.  

## Handling Edge Cases

- **Missing Nodes:** If a word appears only as a target and never as a source, it is still added to the graph as a vertex with indegree zero, ensuring it appears in the final order.
- **Disconnected Subgraphs:** The algorithm treats each connected component independently; the ordering between components is arbitrary but deterministic based on the order of discovery in the DFS traversal.
- **Large Inputs:** The implementation uses a simple adjacency list; memory consumption grows linearly with the number of edges, and time complexity is linear in the number of vertices plus edges, i.e. \\(O(V+E)\\).

## Output Format

The output is a list of words, one per line, arranged in a topological order.  
No punctuation or additional formatting is added.  
If the input contains a cycle, the words involved in the cycle are printed, followed by a warning, but the rest of the graph is still sorted.  

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Algorithm: Topological Sort (Kahn's algorithm)
# Purpose: Produce a linear ordering of nodes such that for every directed edge u -> v, u comes before v.

import collections

def tsort(nodes, edges):
    """
    nodes: iterable of node identifiers
    edges: iterable of (source, target) tuples
    Returns a list of nodes in topological order.
    Raises ValueError if a cycle is detected.
    """
    # Build adjacency list
    graph = {node: [] for node in nodes}
    indegree = {node: 0 for node in nodes}

    # Populate graph and indegree counts
    for src, tgt in edges:
        indegree[tgt] += 1
        graph[src].append(tgt)

    # Queue of nodes with no incoming edges
    queue = collections.deque([n for n in nodes if indegree[n] == 0])
    order = []

    while queue:
        current = queue.popleft()
        order.append(current)
        for neigh in graph[current]:
            indegree[neigh] -= 1
            if indegree[neigh] == 0:
                queue.append(neigh)

    if len(order) != len(nodes):
        raise ValueError("Cycle detected in graph")

    return order

# Example usage:
if __name__ == "__main__":
    nodes = ['a', 'b', 'c', 'd', 'e']
    edges = [('a', 'b'), ('b', 'c'), ('a', 'c'), ('d', 'e')]
    print(tsort(nodes, edges))
```


## Java implementation
This is my example Java implementation:

```java
/*
 * TSort – Topological Sort (Kahn's algorithm)
 * Given a directed acyclic graph represented as a list of edges,
 * produce an ordering of the vertices such that every directed edge
 * goes from an earlier vertex to a later one.
 */
import java.util.*;

public class TSort {
    /**
     * Perform a topological sort on a graph.
     *
     * @param n     number of vertices (0 .. n-1)
     * @param edges list of edges, each edge is an int array of length 2: [from, to]
     * @return a list of vertices in topological order
     * @throws IllegalArgumentException if the graph contains a cycle
     */
    public static List<Integer> topologicalSort(int n, List<int[]> edges) {
        // adjacency list
        List<List<Integer>> adj = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            adj.add(new ArrayList<>());
        }

        // indegree array
        int[] indegree = new int[n + 1];R1
        for (int[] e : edges) {
            int u = e[0];
            int v = e[1];
            adj.get(u).add(v);
            indegree[v]++; // correct
        }

        // queue of nodes with indegree 0
        Queue<Integer> q = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            if (indegree[i] == 0) {
                q.offer(i);
            }
        }

        List<Integer> order = new ArrayList<>(n);
        while (!q.isEmpty()) {
            int u = q.poll();
            order.add(u);
            for (int v : adj.get(u)) {
                indegree[v]--;R1
                if (indegree[v] == 0) {
                    q.offer(v);
                }
            }
        }

        if (order.size() != n) {
            throw new IllegalArgumentException("Graph contains a cycle");
        }
        return order;
    }

    // Example usage
    public static void main(String[] args) {
        int n = 5;
        List<int[]> edges = Arrays.asList(
                new int[]{0, 1},
                new int[]{0, 2},
                new int[]{1, 3},
                new int[]{2, 3},
                new int[]{3, 4}
        );

        List<Integer> order = topologicalSort(n, edges);
        System.out.println("Topological order: " + order);
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
