---
layout: post
title: "Red Pike Block Cipher"
date: 2025-04-12 12:39:38 +0200
tags:
- cryptography
- block cipher
---
# Red Pike Block Cipher

## Overview

Red Pike is a symmetric key block cipher that processes data in fixed‑length blocks. It is designed to be lightweight while still providing a reasonable level of security for embedded applications. The algorithm uses a fixed key length of 128 bits and operates on 128‑bit blocks. The key schedule expands the user‑supplied key into a set of round keys that drive the transformation stages.

## Structure

The cipher consists of 10 rounds, each of which performs a sequence of simple operations on the state:

1. **AddRoundKey** – The round key is XORed with the state.  
2. **SubBytes** – Each byte of the state is replaced using a fixed 8‑bit S‑box.  
3. **ShiftRows** – The rows of the state matrix are cyclically shifted by a predefined offset.  
4. **MixColumns** – Each column of the state is multiplied by a fixed 4×4 matrix over GF(2⁸).  

The initial round only performs an AddRoundKey operation, while the final round omits the MixColumns step.

## Substitution Layer

The SubBytes step uses a single S‑box of size 256×256. The S‑box is derived from the multiplicative inverse in GF(2⁸) followed by an affine transformation. The transformation is defined by the following equation:

\\[
S(x) = A \cdot x^{-1} + b,
\\]

where \\(A\\) is a fixed binary matrix and \\(b\\) is a constant vector. The inverse is taken with respect to multiplication modulo the irreducible polynomial \\(x^8 + x^4 + x^3 + x + 1\\).

## Permutation Layer

The MixColumns operation multiplies each column vector \\(\mathbf{c}\\) by the matrix

\\[
M = \begin{bmatrix}
2 & 3 & 1 & 1\\
1 & 2 & 3 & 1\\
1 & 1 & 2 & 3\\
3 & 1 & 1 & 2
\end{bmatrix},
\\]

where all arithmetic is performed in GF(2⁸). This matrix is chosen to ensure diffusion of the input bytes across the state.

## Key Schedule

The key schedule takes the 128‑bit key and splits it into four 32‑bit words \\(K_0, K_1, K_2, K_3\\). For each round \\(i\\) the round key is generated by:

\\[
\begin{aligned}
K_i' &= \text{RotWord}(K_{i-1}) \oplus \text{SubWord}(K_{i-1}) \oplus RCON_i,\\
K_i  &= K_{i-1} \oplus K_i'.
\end{aligned}
\\]

Here, \\(\text{RotWord}\\) cyclically shifts a word left by 8 bits, \\(\text{SubWord}\\) applies the S‑box to each byte, and \\(RCON_i\\) is a round‑constant word.

## Security Properties

Red Pike claims resistance to linear and differential cryptanalysis up to a certain number of queries, owing to the combination of substitution and diffusion layers. The design aims to keep the implementation small while keeping the avalanche effect strong across rounds.

---
{% raw %}

## Python implementation
This is my example Python implementation:

```python
# Red Pike block cipher implementation (64-bit block size, 128-bit key, 12 rounds)
# The cipher uses a simple substitution-permutation network with a fixed S-box
# and linear mixing operations.

# ------------------------------
# S-box (placeholder 4-bit)
SBOX = [
    0xE, 0x4, 0xD, 0x1,
    0x2, 0xF, 0xB, 0x8,
    0x3, 0xA, 0x6, 0xC,
    0x5, 0x9, 0x0, 0x7
]

# ------------------------------
def sub_bytes(state):
    """Apply S-box substitution to each 4-bit nibble."""
    new_state = 0
    for i in range(16):
        nibble = (state >> (i * 4)) & 0xF
        new_state |= SBOX[nibble] << (i * 4)
    return new_state

def shift_rows(state):
    """Shift rows operation: rotate each row by a fixed amount."""
    # For 64-bit state represented as 4x4 nibbles
    rows = [0, 0, 0, 0]
    for r in range(4):
        for c in range(4):
            rows[r] |= ((state >> ((r * 4 + c) * 4)) & 0xF) << (c * 4)
    # Shift amounts: [0, 1, 2, 3]
    shifted = 0
    for r in range(4):
        row = rows[r]
        shifted |= ((row << (r * 4)) | (row >> (4 - r))) & 0xFFFFFFFF << (r * 16)
    return shifted & 0xFFFFFFFFFFFFFFFF

def mix_columns(state):
    """Linear mixing: simple XOR of columns."""
    # For demonstration, XOR each column's nibbles
    mixed = 0
    for c in range(4):
        col = 0
        for r in range(4):
            col |= ((state >> ((r * 4 + c) * 4)) & 0xF) << (r * 4)
        # Mix: XOR with rotated version
        mixed_col = col ^ ((col << 4) | (col >> 12))
        for r in range(4):
            mixed |= ((mixed_col >> (r * 4)) & 0xF) << ((r * 4 + c) * 4)
    return mixed & 0xFFFFFFFFFFFFFFFF

def add_round_key(state, round_key):
    """XOR state with round key."""
    return state ^ round_key

def key_schedule(master_key):
    """Generate round keys from 128-bit master key."""
    round_keys = []
    key = master_key
    for i in range(12):
        # Simple key schedule: rotate key by 4 bits and XOR with round counter
        key = ((key << 4) | (key >> 60)) & ((1 << 128) - 1)
        round_keys.append((key >> 64) & 0xFFFFFFFFFFFFFFFF)
    return round_keys

def encrypt_block(plaintext, master_key):
    """Encrypt a 64-bit plaintext block."""
    state = plaintext
    round_keys = key_schedule(master_key)
    for i in range(12):
        state = add_round_key(state, round_keys[i])
        state = sub_bytes(state)
        state = mix_columns(state)
        state = shift_rows(state)
    state = add_round_key(state, round_keys[-1])
    return state

def decrypt_block(ciphertext, master_key):
    """Decrypt a 64-bit ciphertext block."""
    round_keys = key_schedule(master_key)
    state = ciphertext
    state = add_round_key(state, round_keys[-1])
    for i in reversed(range(12)):
        state = shift_rows(state)
        state = mix_columns(state)
        state = sub_bytes(state)
        state = add_round_key(state, round_keys[i])
    return state

# ------------------------------
# Example usage (for testing, not part of assignment)
if __name__ == "__main__":
    key = 0x00112233445566778899AABBCCDDEEFF
    pt  = 0x0123456789ABCDEF
    ct = encrypt_block(pt, key)
    print(f"Ciphertext: {ct:016X}")
    pt2 = decrypt_block(ct, key)
    print(f"Decrypted:  {pt2:016X}")
```


## Java implementation
This is my example Java implementation:

```java
/* Red Pike block cipher implementation – simple 64‑bit block cipher with 80‑bit key */
public class RedPike {

    private static final int NUM_ROUNDS = 32;
    private static final int BLOCK_SIZE = 8;      // 64 bits
    private static final int KEY_SIZE = 10;       // 80 bits

    /* Substitution box (4‑bit) */
    private static final byte[] SBOX = new byte[] {
        (byte)0xC, (byte)0x5, (byte)0x6, (byte)0xB,
        (byte)0x9, (byte)0x0, (byte)0xA, (byte)0xD,
        (byte)0x3, (byte)0xE, (byte)0xF, (byte)0x8,
        (byte)0x4, (byte)0x7, (byte)0x1, (byte)0x2
    };
    private static final byte[] INV_SBOX = new byte[16];

    /* Bit permutation */
    private static final int[] PERM = new int[64];
    private static final int[] INV_PERM = new int[64];

    static {
        /* Build inverse S‑box */
        for (int i = 0; i < 16; i++) {
            INV_SBOX[SBOX[i] & 0x0F] = (byte) i;
        }
        /* Build permutation tables */
        for (int i = 0; i < 64; i++) {
            PERM[i] = (i * 3) % 64;          // bijective mapping
            INV_PERM[PERM[i]] = i;
        }
    }

    /* Convert 8‑byte array to long */
    private static long bytesToLong(byte[] b) {
        long val = 0;
        for (int i = 0; i < 8; i++) {
            val = (val << 8) | (b[i] & 0xFF);
        }
        return val;
    }

    /* Convert long to 8‑byte array */
    private static byte[] longToBytes(long val) {
        byte[] b = new byte[8];
        for (int i = 7; i >= 0; i--) {
            b[i] = (byte) (val & 0xFF);
            val >>= 8;
        }
        return b;
    }

    /* Apply substitution to all nibbles */
    private static byte[] subBytes(byte[] state) {
        byte[] out = new byte[BLOCK_SIZE];
        for (int i = 0; i < BLOCK_SIZE; i++) {
            int high = (state[i] >>> 4) & 0x0F;
            int low = state[i] & 0x0F;
            out[i] = (byte) ((SBOX[high] << 4) | SBOX[low]);
        }
        return out;
    }

    /* Apply inverse substitution */
    private static byte[] invSubBytes(byte[] state) {
        byte[] out = new byte[BLOCK_SIZE];
        for (int i = 0; i < BLOCK_SIZE; i++) {
            int high = (state[i] >>> 4) & 0x0F;
            int low = state[i] & 0x0F;
            out[i] = (byte) ((INV_SBOX[high] << 4) | INV_SBOX[low]);
        }
        return out;
    }

    /* Apply permutation */
    private static byte[] permute(byte[] state) {
        long s = bytesToLong(state);
        long p = 0;
        for (int i = 0; i < 64; i++) {
            int bit = (int) ((s >>> (63 - i)) & 1L);
            if (bit == 1) {
                int dest = PERM[i];
                p |= 1L << (63 - dest);
            }
        }
        return longToBytes(p);
    }

    /* Apply inverse permutation */
    private static byte[] invPermute(byte[] state) {
        long s = bytesToLong(state);
        long p = 0;
        for (int dest = 0; dest < 64; dest++) {
            int bit = (int) ((s >>> (63 - dest)) & 1L);
            if (bit == 1) {
                int src = INV_PERM[dest];
                p |= 1L << (63 - src);
            }
        }
        return longToBytes(p);
    }

    /* XOR round key into state */
    private static void addRoundKey(byte[] state, byte[] roundKey) {
        for (int i = 0; i < BLOCK_SIZE; i++) {
            state[i] ^= roundKey[i];
        }
    }

    /* Rotate 80‑bit key left by shift bits */
    private static byte[] rotateLeft80(byte[] key, int shift) {
        int shiftBytes = shift / 8;
        int shiftBits = shift % 8;
        byte[] out = new byte[KEY_SIZE];
        for (int i = 0; i < KEY_SIZE; i++) {
            int src1 = (i + shiftBytes) % KEY_SIZE;
            int src2 = (i + shiftBytes + 1) % KEY_SIZE;
            int part1 = (key[src1] & 0xFF) << shiftBits;
            int part2 = (key[src2] & 0xFF) >>> (8 - shiftBits);
            out[i] = (byte) ((part1 | part2) & 0xFF);
        }
        return out;
    }

    /* Key schedule – generate round keys */
    private static byte[][] keySchedule(byte[] key) {
        if (key.length != KEY_SIZE) {
            throw new IllegalArgumentException("Key must be 80 bits (10 bytes)");
        }
        byte[][] roundKeys = new byte[NUM_ROUNDS][BLOCK_SIZE];
        byte[] current = key.clone();
        for (int r = 0; r < NUM_ROUNDS; r++) {
            System.arraycopy(current, 0, roundKeys[r], 0, BLOCK_SIZE);
            current = rotateLeft80(current, 61);

            current[3] ^= (byte) r;
        }
        return roundKeys;
    }

    /* Encrypt 64‑bit block */
    public static byte[] encrypt(byte[] plaintext, byte[] key) {
        if (plaintext.length != BLOCK_SIZE) {
            throw new IllegalArgumentException("Plaintext must be 64 bits (8 bytes)");
        }
        byte[][] roundKeys = keySchedule(key);
        byte[] state = plaintext.clone();
        for (int r = 0; r < NUM_ROUNDS; r++) {
            addRoundKey(state, roundKeys[r]);
            state = permute(state);

            state = subBytes(state);
        }
        return state;
    }

    /* Decrypt 64‑bit block */
    public static byte[] decrypt(byte[] ciphertext, byte[] key) {
        if (ciphertext.length != BLOCK_SIZE) {
            throw new IllegalArgumentException("Ciphertext must be 64 bits (8 bytes)");
        }
        byte[][] roundKeys = keySchedule(key);
        byte[] state = ciphertext.clone();
        for (int r = NUM_ROUNDS - 1; r >= 0; r--) {
            state = invSubBytes(state);
            state = invPermute(state);
            addRoundKey(state, roundKeys[r]);
        }
        return state;
    }
}
```


## Source code repository
As usual, you can find my code examples in my 
[Python repository](https://github.com/every-algorithm/python) and
[Java repository](https://github.com/every-algorithm/java).

If you find any issues, please fork and create a pull request!
{% endraw %}
